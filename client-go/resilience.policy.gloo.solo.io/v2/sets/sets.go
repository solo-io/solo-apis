// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./sets.go -destination mocks/sets.go

package v2sets

import (
	resilience_policy_gloo_solo_io_v2 "github.com/solo-io/solo-apis/client-go/resilience.policy.gloo.solo.io/v2"

	"github.com/rotisserie/eris"
	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"k8s.io/apimachinery/pkg/util/sets"
)

type GraphQLPersistedQueryCachePolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) bool) []*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) bool) []*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy
	// Insert a resource into the set.
	Insert(graphQLPersistedQueryCachePolicy ...*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(graphQLPersistedQueryCachePolicySet GraphQLPersistedQueryCachePolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(graphQLPersistedQueryCachePolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(graphQLPersistedQueryCachePolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set GraphQLPersistedQueryCachePolicySet) GraphQLPersistedQueryCachePolicySet
	// Return the difference with the provided set
	Difference(set GraphQLPersistedQueryCachePolicySet) GraphQLPersistedQueryCachePolicySet
	// Return the intersection with the provided set
	Intersection(set GraphQLPersistedQueryCachePolicySet) GraphQLPersistedQueryCachePolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another GraphQLPersistedQueryCachePolicySet
	Delta(newSet GraphQLPersistedQueryCachePolicySet) sksets.ResourceDelta
	// Create a deep copy of the current GraphQLPersistedQueryCachePolicySet
	Clone() GraphQLPersistedQueryCachePolicySet
}

func makeGenericGraphQLPersistedQueryCachePolicySet(graphQLPersistedQueryCachePolicyList []*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range graphQLPersistedQueryCachePolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type graphQLPersistedQueryCachePolicySet struct {
	set sksets.ResourceSet
}

func NewGraphQLPersistedQueryCachePolicySet(graphQLPersistedQueryCachePolicyList ...*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) GraphQLPersistedQueryCachePolicySet {
	return &graphQLPersistedQueryCachePolicySet{set: makeGenericGraphQLPersistedQueryCachePolicySet(graphQLPersistedQueryCachePolicyList)}
}

func NewGraphQLPersistedQueryCachePolicySetFromList(graphQLPersistedQueryCachePolicyList *resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicyList) GraphQLPersistedQueryCachePolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy, 0, len(graphQLPersistedQueryCachePolicyList.Items))
	for idx := range graphQLPersistedQueryCachePolicyList.Items {
		list = append(list, &graphQLPersistedQueryCachePolicyList.Items[idx])
	}
	return &graphQLPersistedQueryCachePolicySet{set: makeGenericGraphQLPersistedQueryCachePolicySet(list)}
}

func (s *graphQLPersistedQueryCachePolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *graphQLPersistedQueryCachePolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) bool) []*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	graphQLPersistedQueryCachePolicyList := make([]*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy, 0, len(objs))
	for _, obj := range objs {
		graphQLPersistedQueryCachePolicyList = append(graphQLPersistedQueryCachePolicyList, obj.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy))
	}
	return graphQLPersistedQueryCachePolicyList
}

func (s *graphQLPersistedQueryCachePolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) bool) []*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy))
		})
	}

	var graphQLPersistedQueryCachePolicyList []*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		graphQLPersistedQueryCachePolicyList = append(graphQLPersistedQueryCachePolicyList, obj.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy))
	}
	return graphQLPersistedQueryCachePolicyList
}

func (s *graphQLPersistedQueryCachePolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy)
	}
	return newMap
}

func (s *graphQLPersistedQueryCachePolicySet) Insert(
	graphQLPersistedQueryCachePolicyList ...*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range graphQLPersistedQueryCachePolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *graphQLPersistedQueryCachePolicySet) Has(graphQLPersistedQueryCachePolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(graphQLPersistedQueryCachePolicy)
}

func (s *graphQLPersistedQueryCachePolicySet) Equal(
	graphQLPersistedQueryCachePolicySet GraphQLPersistedQueryCachePolicySet,
) bool {
	if s == nil {
		return graphQLPersistedQueryCachePolicySet == nil
	}
	return s.Generic().Equal(graphQLPersistedQueryCachePolicySet.Generic())
}

func (s *graphQLPersistedQueryCachePolicySet) Delete(GraphQLPersistedQueryCachePolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(GraphQLPersistedQueryCachePolicy)
}

func (s *graphQLPersistedQueryCachePolicySet) Union(set GraphQLPersistedQueryCachePolicySet) GraphQLPersistedQueryCachePolicySet {
	if s == nil {
		return set
	}
	return NewGraphQLPersistedQueryCachePolicySet(append(s.List(), set.List()...)...)
}

func (s *graphQLPersistedQueryCachePolicySet) Difference(set GraphQLPersistedQueryCachePolicySet) GraphQLPersistedQueryCachePolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &graphQLPersistedQueryCachePolicySet{set: newSet}
}

func (s *graphQLPersistedQueryCachePolicySet) Intersection(set GraphQLPersistedQueryCachePolicySet) GraphQLPersistedQueryCachePolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var graphQLPersistedQueryCachePolicyList []*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy
	for _, obj := range newSet.List() {
		graphQLPersistedQueryCachePolicyList = append(graphQLPersistedQueryCachePolicyList, obj.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy))
	}
	return NewGraphQLPersistedQueryCachePolicySet(graphQLPersistedQueryCachePolicyList...)
}

func (s *graphQLPersistedQueryCachePolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find GraphQLPersistedQueryCachePolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy), nil
}

func (s *graphQLPersistedQueryCachePolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *graphQLPersistedQueryCachePolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *graphQLPersistedQueryCachePolicySet) Delta(newSet GraphQLPersistedQueryCachePolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *graphQLPersistedQueryCachePolicySet) Clone() GraphQLPersistedQueryCachePolicySet {
	if s == nil {
		return nil
	}
	return &graphQLPersistedQueryCachePolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type FailoverPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FailoverPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FailoverPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FailoverPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FailoverPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.FailoverPolicy
	// Insert a resource into the set.
	Insert(failoverPolicy ...*resilience_policy_gloo_solo_io_v2.FailoverPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(failoverPolicySet FailoverPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(failoverPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(failoverPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set FailoverPolicySet) FailoverPolicySet
	// Return the difference with the provided set
	Difference(set FailoverPolicySet) FailoverPolicySet
	// Return the intersection with the provided set
	Intersection(set FailoverPolicySet) FailoverPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.FailoverPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another FailoverPolicySet
	Delta(newSet FailoverPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current FailoverPolicySet
	Clone() FailoverPolicySet
}

func makeGenericFailoverPolicySet(failoverPolicyList []*resilience_policy_gloo_solo_io_v2.FailoverPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range failoverPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type failoverPolicySet struct {
	set sksets.ResourceSet
}

func NewFailoverPolicySet(failoverPolicyList ...*resilience_policy_gloo_solo_io_v2.FailoverPolicy) FailoverPolicySet {
	return &failoverPolicySet{set: makeGenericFailoverPolicySet(failoverPolicyList)}
}

func NewFailoverPolicySetFromList(failoverPolicyList *resilience_policy_gloo_solo_io_v2.FailoverPolicyList) FailoverPolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.FailoverPolicy, 0, len(failoverPolicyList.Items))
	for idx := range failoverPolicyList.Items {
		list = append(list, &failoverPolicyList.Items[idx])
	}
	return &failoverPolicySet{set: makeGenericFailoverPolicySet(list)}
}

func (s *failoverPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *failoverPolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FailoverPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FailoverPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	failoverPolicyList := make([]*resilience_policy_gloo_solo_io_v2.FailoverPolicy, 0, len(objs))
	for _, obj := range objs {
		failoverPolicyList = append(failoverPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy))
	}
	return failoverPolicyList
}

func (s *failoverPolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FailoverPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FailoverPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy))
		})
	}

	var failoverPolicyList []*resilience_policy_gloo_solo_io_v2.FailoverPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		failoverPolicyList = append(failoverPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy))
	}
	return failoverPolicyList
}

func (s *failoverPolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.FailoverPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.FailoverPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy)
	}
	return newMap
}

func (s *failoverPolicySet) Insert(
	failoverPolicyList ...*resilience_policy_gloo_solo_io_v2.FailoverPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range failoverPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *failoverPolicySet) Has(failoverPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(failoverPolicy)
}

func (s *failoverPolicySet) Equal(
	failoverPolicySet FailoverPolicySet,
) bool {
	if s == nil {
		return failoverPolicySet == nil
	}
	return s.Generic().Equal(failoverPolicySet.Generic())
}

func (s *failoverPolicySet) Delete(FailoverPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(FailoverPolicy)
}

func (s *failoverPolicySet) Union(set FailoverPolicySet) FailoverPolicySet {
	if s == nil {
		return set
	}
	return NewFailoverPolicySet(append(s.List(), set.List()...)...)
}

func (s *failoverPolicySet) Difference(set FailoverPolicySet) FailoverPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &failoverPolicySet{set: newSet}
}

func (s *failoverPolicySet) Intersection(set FailoverPolicySet) FailoverPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var failoverPolicyList []*resilience_policy_gloo_solo_io_v2.FailoverPolicy
	for _, obj := range newSet.List() {
		failoverPolicyList = append(failoverPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy))
	}
	return NewFailoverPolicySet(failoverPolicyList...)
}

func (s *failoverPolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.FailoverPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find FailoverPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.FailoverPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy), nil
}

func (s *failoverPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *failoverPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *failoverPolicySet) Delta(newSet FailoverPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *failoverPolicySet) Clone() FailoverPolicySet {
	if s == nil {
		return nil
	}
	return &failoverPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type OutlierDetectionPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy
	// Insert a resource into the set.
	Insert(outlierDetectionPolicy ...*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(outlierDetectionPolicySet OutlierDetectionPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(outlierDetectionPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(outlierDetectionPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set OutlierDetectionPolicySet) OutlierDetectionPolicySet
	// Return the difference with the provided set
	Difference(set OutlierDetectionPolicySet) OutlierDetectionPolicySet
	// Return the intersection with the provided set
	Intersection(set OutlierDetectionPolicySet) OutlierDetectionPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another OutlierDetectionPolicySet
	Delta(newSet OutlierDetectionPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current OutlierDetectionPolicySet
	Clone() OutlierDetectionPolicySet
}

func makeGenericOutlierDetectionPolicySet(outlierDetectionPolicyList []*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range outlierDetectionPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type outlierDetectionPolicySet struct {
	set sksets.ResourceSet
}

func NewOutlierDetectionPolicySet(outlierDetectionPolicyList ...*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) OutlierDetectionPolicySet {
	return &outlierDetectionPolicySet{set: makeGenericOutlierDetectionPolicySet(outlierDetectionPolicyList)}
}

func NewOutlierDetectionPolicySetFromList(outlierDetectionPolicyList *resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicyList) OutlierDetectionPolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy, 0, len(outlierDetectionPolicyList.Items))
	for idx := range outlierDetectionPolicyList.Items {
		list = append(list, &outlierDetectionPolicyList.Items[idx])
	}
	return &outlierDetectionPolicySet{set: makeGenericOutlierDetectionPolicySet(list)}
}

func (s *outlierDetectionPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *outlierDetectionPolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	outlierDetectionPolicyList := make([]*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy, 0, len(objs))
	for _, obj := range objs {
		outlierDetectionPolicyList = append(outlierDetectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy))
	}
	return outlierDetectionPolicyList
}

func (s *outlierDetectionPolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy))
		})
	}

	var outlierDetectionPolicyList []*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		outlierDetectionPolicyList = append(outlierDetectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy))
	}
	return outlierDetectionPolicyList
}

func (s *outlierDetectionPolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy)
	}
	return newMap
}

func (s *outlierDetectionPolicySet) Insert(
	outlierDetectionPolicyList ...*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range outlierDetectionPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *outlierDetectionPolicySet) Has(outlierDetectionPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(outlierDetectionPolicy)
}

func (s *outlierDetectionPolicySet) Equal(
	outlierDetectionPolicySet OutlierDetectionPolicySet,
) bool {
	if s == nil {
		return outlierDetectionPolicySet == nil
	}
	return s.Generic().Equal(outlierDetectionPolicySet.Generic())
}

func (s *outlierDetectionPolicySet) Delete(OutlierDetectionPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(OutlierDetectionPolicy)
}

func (s *outlierDetectionPolicySet) Union(set OutlierDetectionPolicySet) OutlierDetectionPolicySet {
	if s == nil {
		return set
	}
	return NewOutlierDetectionPolicySet(append(s.List(), set.List()...)...)
}

func (s *outlierDetectionPolicySet) Difference(set OutlierDetectionPolicySet) OutlierDetectionPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &outlierDetectionPolicySet{set: newSet}
}

func (s *outlierDetectionPolicySet) Intersection(set OutlierDetectionPolicySet) OutlierDetectionPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var outlierDetectionPolicyList []*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy
	for _, obj := range newSet.List() {
		outlierDetectionPolicyList = append(outlierDetectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy))
	}
	return NewOutlierDetectionPolicySet(outlierDetectionPolicyList...)
}

func (s *outlierDetectionPolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find OutlierDetectionPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy), nil
}

func (s *outlierDetectionPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *outlierDetectionPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *outlierDetectionPolicySet) Delta(newSet OutlierDetectionPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *outlierDetectionPolicySet) Clone() OutlierDetectionPolicySet {
	if s == nil {
		return nil
	}
	return &outlierDetectionPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type FaultInjectionPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy
	// Insert a resource into the set.
	Insert(faultInjectionPolicy ...*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(faultInjectionPolicySet FaultInjectionPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(faultInjectionPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(faultInjectionPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set FaultInjectionPolicySet) FaultInjectionPolicySet
	// Return the difference with the provided set
	Difference(set FaultInjectionPolicySet) FaultInjectionPolicySet
	// Return the intersection with the provided set
	Intersection(set FaultInjectionPolicySet) FaultInjectionPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another FaultInjectionPolicySet
	Delta(newSet FaultInjectionPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current FaultInjectionPolicySet
	Clone() FaultInjectionPolicySet
}

func makeGenericFaultInjectionPolicySet(faultInjectionPolicyList []*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range faultInjectionPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type faultInjectionPolicySet struct {
	set sksets.ResourceSet
}

func NewFaultInjectionPolicySet(faultInjectionPolicyList ...*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) FaultInjectionPolicySet {
	return &faultInjectionPolicySet{set: makeGenericFaultInjectionPolicySet(faultInjectionPolicyList)}
}

func NewFaultInjectionPolicySetFromList(faultInjectionPolicyList *resilience_policy_gloo_solo_io_v2.FaultInjectionPolicyList) FaultInjectionPolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy, 0, len(faultInjectionPolicyList.Items))
	for idx := range faultInjectionPolicyList.Items {
		list = append(list, &faultInjectionPolicyList.Items[idx])
	}
	return &faultInjectionPolicySet{set: makeGenericFaultInjectionPolicySet(list)}
}

func (s *faultInjectionPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *faultInjectionPolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	faultInjectionPolicyList := make([]*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy, 0, len(objs))
	for _, obj := range objs {
		faultInjectionPolicyList = append(faultInjectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy))
	}
	return faultInjectionPolicyList
}

func (s *faultInjectionPolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy))
		})
	}

	var faultInjectionPolicyList []*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		faultInjectionPolicyList = append(faultInjectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy))
	}
	return faultInjectionPolicyList
}

func (s *faultInjectionPolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy)
	}
	return newMap
}

func (s *faultInjectionPolicySet) Insert(
	faultInjectionPolicyList ...*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range faultInjectionPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *faultInjectionPolicySet) Has(faultInjectionPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(faultInjectionPolicy)
}

func (s *faultInjectionPolicySet) Equal(
	faultInjectionPolicySet FaultInjectionPolicySet,
) bool {
	if s == nil {
		return faultInjectionPolicySet == nil
	}
	return s.Generic().Equal(faultInjectionPolicySet.Generic())
}

func (s *faultInjectionPolicySet) Delete(FaultInjectionPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(FaultInjectionPolicy)
}

func (s *faultInjectionPolicySet) Union(set FaultInjectionPolicySet) FaultInjectionPolicySet {
	if s == nil {
		return set
	}
	return NewFaultInjectionPolicySet(append(s.List(), set.List()...)...)
}

func (s *faultInjectionPolicySet) Difference(set FaultInjectionPolicySet) FaultInjectionPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &faultInjectionPolicySet{set: newSet}
}

func (s *faultInjectionPolicySet) Intersection(set FaultInjectionPolicySet) FaultInjectionPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var faultInjectionPolicyList []*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy
	for _, obj := range newSet.List() {
		faultInjectionPolicyList = append(faultInjectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy))
	}
	return NewFaultInjectionPolicySet(faultInjectionPolicyList...)
}

func (s *faultInjectionPolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find FaultInjectionPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy), nil
}

func (s *faultInjectionPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *faultInjectionPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *faultInjectionPolicySet) Delta(newSet FaultInjectionPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *faultInjectionPolicySet) Clone() FaultInjectionPolicySet {
	if s == nil {
		return nil
	}
	return &faultInjectionPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type RetryTimeoutPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) bool) []*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) bool) []*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy
	// Insert a resource into the set.
	Insert(retryTimeoutPolicy ...*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(retryTimeoutPolicySet RetryTimeoutPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(retryTimeoutPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(retryTimeoutPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set RetryTimeoutPolicySet) RetryTimeoutPolicySet
	// Return the difference with the provided set
	Difference(set RetryTimeoutPolicySet) RetryTimeoutPolicySet
	// Return the intersection with the provided set
	Intersection(set RetryTimeoutPolicySet) RetryTimeoutPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another RetryTimeoutPolicySet
	Delta(newSet RetryTimeoutPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current RetryTimeoutPolicySet
	Clone() RetryTimeoutPolicySet
}

func makeGenericRetryTimeoutPolicySet(retryTimeoutPolicyList []*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range retryTimeoutPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type retryTimeoutPolicySet struct {
	set sksets.ResourceSet
}

func NewRetryTimeoutPolicySet(retryTimeoutPolicyList ...*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) RetryTimeoutPolicySet {
	return &retryTimeoutPolicySet{set: makeGenericRetryTimeoutPolicySet(retryTimeoutPolicyList)}
}

func NewRetryTimeoutPolicySetFromList(retryTimeoutPolicyList *resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicyList) RetryTimeoutPolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy, 0, len(retryTimeoutPolicyList.Items))
	for idx := range retryTimeoutPolicyList.Items {
		list = append(list, &retryTimeoutPolicyList.Items[idx])
	}
	return &retryTimeoutPolicySet{set: makeGenericRetryTimeoutPolicySet(list)}
}

func (s *retryTimeoutPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *retryTimeoutPolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) bool) []*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	retryTimeoutPolicyList := make([]*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy, 0, len(objs))
	for _, obj := range objs {
		retryTimeoutPolicyList = append(retryTimeoutPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy))
	}
	return retryTimeoutPolicyList
}

func (s *retryTimeoutPolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) bool) []*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy))
		})
	}

	var retryTimeoutPolicyList []*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		retryTimeoutPolicyList = append(retryTimeoutPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy))
	}
	return retryTimeoutPolicyList
}

func (s *retryTimeoutPolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy)
	}
	return newMap
}

func (s *retryTimeoutPolicySet) Insert(
	retryTimeoutPolicyList ...*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range retryTimeoutPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *retryTimeoutPolicySet) Has(retryTimeoutPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(retryTimeoutPolicy)
}

func (s *retryTimeoutPolicySet) Equal(
	retryTimeoutPolicySet RetryTimeoutPolicySet,
) bool {
	if s == nil {
		return retryTimeoutPolicySet == nil
	}
	return s.Generic().Equal(retryTimeoutPolicySet.Generic())
}

func (s *retryTimeoutPolicySet) Delete(RetryTimeoutPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(RetryTimeoutPolicy)
}

func (s *retryTimeoutPolicySet) Union(set RetryTimeoutPolicySet) RetryTimeoutPolicySet {
	if s == nil {
		return set
	}
	return NewRetryTimeoutPolicySet(append(s.List(), set.List()...)...)
}

func (s *retryTimeoutPolicySet) Difference(set RetryTimeoutPolicySet) RetryTimeoutPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &retryTimeoutPolicySet{set: newSet}
}

func (s *retryTimeoutPolicySet) Intersection(set RetryTimeoutPolicySet) RetryTimeoutPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var retryTimeoutPolicyList []*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy
	for _, obj := range newSet.List() {
		retryTimeoutPolicyList = append(retryTimeoutPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy))
	}
	return NewRetryTimeoutPolicySet(retryTimeoutPolicyList...)
}

func (s *retryTimeoutPolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find RetryTimeoutPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy), nil
}

func (s *retryTimeoutPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *retryTimeoutPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *retryTimeoutPolicySet) Delta(newSet RetryTimeoutPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *retryTimeoutPolicySet) Clone() RetryTimeoutPolicySet {
	if s == nil {
		return nil
	}
	return &retryTimeoutPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type ConnectionPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ConnectionPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ConnectionPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_policy_gloo_solo_io_v2.ConnectionPolicy
	// Insert a resource into the set.
	Insert(connectionPolicy ...*resilience_policy_gloo_solo_io_v2.ConnectionPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(connectionPolicySet ConnectionPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(connectionPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(connectionPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set ConnectionPolicySet) ConnectionPolicySet
	// Return the difference with the provided set
	Difference(set ConnectionPolicySet) ConnectionPolicySet
	// Return the intersection with the provided set
	Intersection(set ConnectionPolicySet) ConnectionPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.ConnectionPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another ConnectionPolicySet
	Delta(newSet ConnectionPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current ConnectionPolicySet
	Clone() ConnectionPolicySet
}

func makeGenericConnectionPolicySet(connectionPolicyList []*resilience_policy_gloo_solo_io_v2.ConnectionPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range connectionPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type connectionPolicySet struct {
	set sksets.ResourceSet
}

func NewConnectionPolicySet(connectionPolicyList ...*resilience_policy_gloo_solo_io_v2.ConnectionPolicy) ConnectionPolicySet {
	return &connectionPolicySet{set: makeGenericConnectionPolicySet(connectionPolicyList)}
}

func NewConnectionPolicySetFromList(connectionPolicyList *resilience_policy_gloo_solo_io_v2.ConnectionPolicyList) ConnectionPolicySet {
	list := make([]*resilience_policy_gloo_solo_io_v2.ConnectionPolicy, 0, len(connectionPolicyList.Items))
	for idx := range connectionPolicyList.Items {
		list = append(list, &connectionPolicyList.Items[idx])
	}
	return &connectionPolicySet{set: makeGenericConnectionPolicySet(list)}
}

func (s *connectionPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *connectionPolicySet) List(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ConnectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	connectionPolicyList := make([]*resilience_policy_gloo_solo_io_v2.ConnectionPolicy, 0, len(objs))
	for _, obj := range objs {
		connectionPolicyList = append(connectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy))
	}
	return connectionPolicyList
}

func (s *connectionPolicySet) UnsortedList(filterResource ...func(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy) bool) []*resilience_policy_gloo_solo_io_v2.ConnectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy))
		})
	}

	var connectionPolicyList []*resilience_policy_gloo_solo_io_v2.ConnectionPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		connectionPolicyList = append(connectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy))
	}
	return connectionPolicyList
}

func (s *connectionPolicySet) Map() map[string]*resilience_policy_gloo_solo_io_v2.ConnectionPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_policy_gloo_solo_io_v2.ConnectionPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy)
	}
	return newMap
}

func (s *connectionPolicySet) Insert(
	connectionPolicyList ...*resilience_policy_gloo_solo_io_v2.ConnectionPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range connectionPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *connectionPolicySet) Has(connectionPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(connectionPolicy)
}

func (s *connectionPolicySet) Equal(
	connectionPolicySet ConnectionPolicySet,
) bool {
	if s == nil {
		return connectionPolicySet == nil
	}
	return s.Generic().Equal(connectionPolicySet.Generic())
}

func (s *connectionPolicySet) Delete(ConnectionPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(ConnectionPolicy)
}

func (s *connectionPolicySet) Union(set ConnectionPolicySet) ConnectionPolicySet {
	if s == nil {
		return set
	}
	return NewConnectionPolicySet(append(s.List(), set.List()...)...)
}

func (s *connectionPolicySet) Difference(set ConnectionPolicySet) ConnectionPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &connectionPolicySet{set: newSet}
}

func (s *connectionPolicySet) Intersection(set ConnectionPolicySet) ConnectionPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var connectionPolicyList []*resilience_policy_gloo_solo_io_v2.ConnectionPolicy
	for _, obj := range newSet.List() {
		connectionPolicyList = append(connectionPolicyList, obj.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy))
	}
	return NewConnectionPolicySet(connectionPolicyList...)
}

func (s *connectionPolicySet) Find(id ezkube.ResourceId) (*resilience_policy_gloo_solo_io_v2.ConnectionPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find ConnectionPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_policy_gloo_solo_io_v2.ConnectionPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy), nil
}

func (s *connectionPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *connectionPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *connectionPolicySet) Delta(newSet ConnectionPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *connectionPolicySet) Clone() ConnectionPolicySet {
	if s == nil {
		return nil
	}
	return &connectionPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}
