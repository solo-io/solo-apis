// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./clients.go -destination mocks/clients.go

package v2

import (
	"context"

	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// MulticlusterClientset for the resilience.policy.gloo.solo.io/v2 APIs
type MulticlusterClientset interface {
	// Cluster returns a Clientset for the given cluster
	Cluster(cluster string) (Clientset, error)
}

type multiclusterClientset struct {
	client multicluster.Client
}

func NewMulticlusterClientset(client multicluster.Client) MulticlusterClientset {
	return &multiclusterClientset{client: client}
}

func (m *multiclusterClientset) Cluster(cluster string) (Clientset, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

// clienset for the resilience.policy.gloo.solo.io/v2 APIs
type Clientset interface {
	// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
	GraphQLPersistedQueryCachePolicies() GraphQLPersistedQueryCachePolicyClient
	// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
	FailoverPolicies() FailoverPolicyClient
	// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
	OutlierDetectionPolicies() OutlierDetectionPolicyClient
	// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
	AdaptiveRequestConcurrencyPolicies() AdaptiveRequestConcurrencyPolicyClient
	// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
	FaultInjectionPolicies() FaultInjectionPolicyClient
	// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
	RetryTimeoutPolicies() RetryTimeoutPolicyClient
	// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
	ConnectionPolicies() ConnectionPolicyClient
	// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
	TrimProxyConfigPolicies() TrimProxyConfigPolicyClient
	// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
	ActiveHealthCheckPolicies() ActiveHealthCheckPolicyClient
	// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
	ListenerConnectionPolicies() ListenerConnectionPolicyClient
}

type clientSet struct {
	client client.Client
}

func NewClientsetFromConfig(cfg *rest.Config) (Clientset, error) {
	scheme := scheme.Scheme
	if err := SchemeBuilder.AddToScheme(scheme); err != nil {
		return nil, err
	}
	client, err := client.New(cfg, client.Options{
		Scheme: scheme,
	})
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

func NewClientset(client client.Client) Clientset {
	return &clientSet{client: client}
}

// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) GraphQLPersistedQueryCachePolicies() GraphQLPersistedQueryCachePolicyClient {
	return NewGraphQLPersistedQueryCachePolicyClient(c.client)
}

// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) FailoverPolicies() FailoverPolicyClient {
	return NewFailoverPolicyClient(c.client)
}

// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) OutlierDetectionPolicies() OutlierDetectionPolicyClient {
	return NewOutlierDetectionPolicyClient(c.client)
}

// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) AdaptiveRequestConcurrencyPolicies() AdaptiveRequestConcurrencyPolicyClient {
	return NewAdaptiveRequestConcurrencyPolicyClient(c.client)
}

// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) FaultInjectionPolicies() FaultInjectionPolicyClient {
	return NewFaultInjectionPolicyClient(c.client)
}

// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) RetryTimeoutPolicies() RetryTimeoutPolicyClient {
	return NewRetryTimeoutPolicyClient(c.client)
}

// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) ConnectionPolicies() ConnectionPolicyClient {
	return NewConnectionPolicyClient(c.client)
}

// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) TrimProxyConfigPolicies() TrimProxyConfigPolicyClient {
	return NewTrimProxyConfigPolicyClient(c.client)
}

// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) ActiveHealthCheckPolicies() ActiveHealthCheckPolicyClient {
	return NewActiveHealthCheckPolicyClient(c.client)
}

// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) ListenerConnectionPolicies() ListenerConnectionPolicyClient {
	return NewListenerConnectionPolicyClient(c.client)
}

// Reader knows how to read and list GraphQLPersistedQueryCachePolicys.
type GraphQLPersistedQueryCachePolicyReader interface {
	// Get retrieves a GraphQLPersistedQueryCachePolicy for the given object key
	GetGraphQLPersistedQueryCachePolicy(ctx context.Context, key client.ObjectKey) (*GraphQLPersistedQueryCachePolicy, error)

	// List retrieves list of GraphQLPersistedQueryCachePolicys for a given namespace and list options.
	ListGraphQLPersistedQueryCachePolicy(ctx context.Context, opts ...client.ListOption) (*GraphQLPersistedQueryCachePolicyList, error)
}

// GraphQLPersistedQueryCachePolicyTransitionFunction instructs the GraphQLPersistedQueryCachePolicyWriter how to transition between an existing
// GraphQLPersistedQueryCachePolicy object and a desired on an Upsert
type GraphQLPersistedQueryCachePolicyTransitionFunction func(existing, desired *GraphQLPersistedQueryCachePolicy) error

// Writer knows how to create, delete, and update GraphQLPersistedQueryCachePolicys.
type GraphQLPersistedQueryCachePolicyWriter interface {
	// Create saves the GraphQLPersistedQueryCachePolicy object.
	CreateGraphQLPersistedQueryCachePolicy(ctx context.Context, obj *GraphQLPersistedQueryCachePolicy, opts ...client.CreateOption) error

	// Delete deletes the GraphQLPersistedQueryCachePolicy object.
	DeleteGraphQLPersistedQueryCachePolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given GraphQLPersistedQueryCachePolicy object.
	UpdateGraphQLPersistedQueryCachePolicy(ctx context.Context, obj *GraphQLPersistedQueryCachePolicy, opts ...client.UpdateOption) error

	// Patch patches the given GraphQLPersistedQueryCachePolicy object.
	PatchGraphQLPersistedQueryCachePolicy(ctx context.Context, obj *GraphQLPersistedQueryCachePolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all GraphQLPersistedQueryCachePolicy objects matching the given options.
	DeleteAllOfGraphQLPersistedQueryCachePolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the GraphQLPersistedQueryCachePolicy object.
	UpsertGraphQLPersistedQueryCachePolicy(ctx context.Context, obj *GraphQLPersistedQueryCachePolicy, transitionFuncs ...GraphQLPersistedQueryCachePolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a GraphQLPersistedQueryCachePolicy object.
type GraphQLPersistedQueryCachePolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given GraphQLPersistedQueryCachePolicy object.
	UpdateGraphQLPersistedQueryCachePolicyStatus(ctx context.Context, obj *GraphQLPersistedQueryCachePolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given GraphQLPersistedQueryCachePolicy object's subresource.
	PatchGraphQLPersistedQueryCachePolicyStatus(ctx context.Context, obj *GraphQLPersistedQueryCachePolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on GraphQLPersistedQueryCachePolicys.
type GraphQLPersistedQueryCachePolicyClient interface {
	GraphQLPersistedQueryCachePolicyReader
	GraphQLPersistedQueryCachePolicyWriter
	GraphQLPersistedQueryCachePolicyStatusWriter
}

type graphQLPersistedQueryCachePolicyClient struct {
	client client.Client
}

func NewGraphQLPersistedQueryCachePolicyClient(client client.Client) *graphQLPersistedQueryCachePolicyClient {
	return &graphQLPersistedQueryCachePolicyClient{client: client}
}

func (c *graphQLPersistedQueryCachePolicyClient) GetGraphQLPersistedQueryCachePolicy(ctx context.Context, key client.ObjectKey) (*GraphQLPersistedQueryCachePolicy, error) {
	obj := &GraphQLPersistedQueryCachePolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *graphQLPersistedQueryCachePolicyClient) ListGraphQLPersistedQueryCachePolicy(ctx context.Context, opts ...client.ListOption) (*GraphQLPersistedQueryCachePolicyList, error) {
	list := &GraphQLPersistedQueryCachePolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *graphQLPersistedQueryCachePolicyClient) CreateGraphQLPersistedQueryCachePolicy(ctx context.Context, obj *GraphQLPersistedQueryCachePolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *graphQLPersistedQueryCachePolicyClient) DeleteGraphQLPersistedQueryCachePolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &GraphQLPersistedQueryCachePolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *graphQLPersistedQueryCachePolicyClient) UpdateGraphQLPersistedQueryCachePolicy(ctx context.Context, obj *GraphQLPersistedQueryCachePolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *graphQLPersistedQueryCachePolicyClient) PatchGraphQLPersistedQueryCachePolicy(ctx context.Context, obj *GraphQLPersistedQueryCachePolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *graphQLPersistedQueryCachePolicyClient) DeleteAllOfGraphQLPersistedQueryCachePolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &GraphQLPersistedQueryCachePolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *graphQLPersistedQueryCachePolicyClient) UpsertGraphQLPersistedQueryCachePolicy(ctx context.Context, obj *GraphQLPersistedQueryCachePolicy, transitionFuncs ...GraphQLPersistedQueryCachePolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*GraphQLPersistedQueryCachePolicy), desired.(*GraphQLPersistedQueryCachePolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *graphQLPersistedQueryCachePolicyClient) UpdateGraphQLPersistedQueryCachePolicyStatus(ctx context.Context, obj *GraphQLPersistedQueryCachePolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *graphQLPersistedQueryCachePolicyClient) PatchGraphQLPersistedQueryCachePolicyStatus(ctx context.Context, obj *GraphQLPersistedQueryCachePolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides GraphQLPersistedQueryCachePolicyClients for multiple clusters.
type MulticlusterGraphQLPersistedQueryCachePolicyClient interface {
	// Cluster returns a GraphQLPersistedQueryCachePolicyClient for the given cluster
	Cluster(cluster string) (GraphQLPersistedQueryCachePolicyClient, error)
}

type multiclusterGraphQLPersistedQueryCachePolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterGraphQLPersistedQueryCachePolicyClient(client multicluster.Client) MulticlusterGraphQLPersistedQueryCachePolicyClient {
	return &multiclusterGraphQLPersistedQueryCachePolicyClient{client: client}
}

func (m *multiclusterGraphQLPersistedQueryCachePolicyClient) Cluster(cluster string) (GraphQLPersistedQueryCachePolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewGraphQLPersistedQueryCachePolicyClient(client), nil
}

// Reader knows how to read and list FailoverPolicys.
type FailoverPolicyReader interface {
	// Get retrieves a FailoverPolicy for the given object key
	GetFailoverPolicy(ctx context.Context, key client.ObjectKey) (*FailoverPolicy, error)

	// List retrieves list of FailoverPolicys for a given namespace and list options.
	ListFailoverPolicy(ctx context.Context, opts ...client.ListOption) (*FailoverPolicyList, error)
}

// FailoverPolicyTransitionFunction instructs the FailoverPolicyWriter how to transition between an existing
// FailoverPolicy object and a desired on an Upsert
type FailoverPolicyTransitionFunction func(existing, desired *FailoverPolicy) error

// Writer knows how to create, delete, and update FailoverPolicys.
type FailoverPolicyWriter interface {
	// Create saves the FailoverPolicy object.
	CreateFailoverPolicy(ctx context.Context, obj *FailoverPolicy, opts ...client.CreateOption) error

	// Delete deletes the FailoverPolicy object.
	DeleteFailoverPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given FailoverPolicy object.
	UpdateFailoverPolicy(ctx context.Context, obj *FailoverPolicy, opts ...client.UpdateOption) error

	// Patch patches the given FailoverPolicy object.
	PatchFailoverPolicy(ctx context.Context, obj *FailoverPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all FailoverPolicy objects matching the given options.
	DeleteAllOfFailoverPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the FailoverPolicy object.
	UpsertFailoverPolicy(ctx context.Context, obj *FailoverPolicy, transitionFuncs ...FailoverPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a FailoverPolicy object.
type FailoverPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given FailoverPolicy object.
	UpdateFailoverPolicyStatus(ctx context.Context, obj *FailoverPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given FailoverPolicy object's subresource.
	PatchFailoverPolicyStatus(ctx context.Context, obj *FailoverPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on FailoverPolicys.
type FailoverPolicyClient interface {
	FailoverPolicyReader
	FailoverPolicyWriter
	FailoverPolicyStatusWriter
}

type failoverPolicyClient struct {
	client client.Client
}

func NewFailoverPolicyClient(client client.Client) *failoverPolicyClient {
	return &failoverPolicyClient{client: client}
}

func (c *failoverPolicyClient) GetFailoverPolicy(ctx context.Context, key client.ObjectKey) (*FailoverPolicy, error) {
	obj := &FailoverPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *failoverPolicyClient) ListFailoverPolicy(ctx context.Context, opts ...client.ListOption) (*FailoverPolicyList, error) {
	list := &FailoverPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *failoverPolicyClient) CreateFailoverPolicy(ctx context.Context, obj *FailoverPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *failoverPolicyClient) DeleteFailoverPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &FailoverPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *failoverPolicyClient) UpdateFailoverPolicy(ctx context.Context, obj *FailoverPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *failoverPolicyClient) PatchFailoverPolicy(ctx context.Context, obj *FailoverPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *failoverPolicyClient) DeleteAllOfFailoverPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &FailoverPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *failoverPolicyClient) UpsertFailoverPolicy(ctx context.Context, obj *FailoverPolicy, transitionFuncs ...FailoverPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*FailoverPolicy), desired.(*FailoverPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *failoverPolicyClient) UpdateFailoverPolicyStatus(ctx context.Context, obj *FailoverPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *failoverPolicyClient) PatchFailoverPolicyStatus(ctx context.Context, obj *FailoverPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides FailoverPolicyClients for multiple clusters.
type MulticlusterFailoverPolicyClient interface {
	// Cluster returns a FailoverPolicyClient for the given cluster
	Cluster(cluster string) (FailoverPolicyClient, error)
}

type multiclusterFailoverPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterFailoverPolicyClient(client multicluster.Client) MulticlusterFailoverPolicyClient {
	return &multiclusterFailoverPolicyClient{client: client}
}

func (m *multiclusterFailoverPolicyClient) Cluster(cluster string) (FailoverPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewFailoverPolicyClient(client), nil
}

// Reader knows how to read and list OutlierDetectionPolicys.
type OutlierDetectionPolicyReader interface {
	// Get retrieves a OutlierDetectionPolicy for the given object key
	GetOutlierDetectionPolicy(ctx context.Context, key client.ObjectKey) (*OutlierDetectionPolicy, error)

	// List retrieves list of OutlierDetectionPolicys for a given namespace and list options.
	ListOutlierDetectionPolicy(ctx context.Context, opts ...client.ListOption) (*OutlierDetectionPolicyList, error)
}

// OutlierDetectionPolicyTransitionFunction instructs the OutlierDetectionPolicyWriter how to transition between an existing
// OutlierDetectionPolicy object and a desired on an Upsert
type OutlierDetectionPolicyTransitionFunction func(existing, desired *OutlierDetectionPolicy) error

// Writer knows how to create, delete, and update OutlierDetectionPolicys.
type OutlierDetectionPolicyWriter interface {
	// Create saves the OutlierDetectionPolicy object.
	CreateOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, opts ...client.CreateOption) error

	// Delete deletes the OutlierDetectionPolicy object.
	DeleteOutlierDetectionPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given OutlierDetectionPolicy object.
	UpdateOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, opts ...client.UpdateOption) error

	// Patch patches the given OutlierDetectionPolicy object.
	PatchOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all OutlierDetectionPolicy objects matching the given options.
	DeleteAllOfOutlierDetectionPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the OutlierDetectionPolicy object.
	UpsertOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, transitionFuncs ...OutlierDetectionPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a OutlierDetectionPolicy object.
type OutlierDetectionPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given OutlierDetectionPolicy object.
	UpdateOutlierDetectionPolicyStatus(ctx context.Context, obj *OutlierDetectionPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given OutlierDetectionPolicy object's subresource.
	PatchOutlierDetectionPolicyStatus(ctx context.Context, obj *OutlierDetectionPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on OutlierDetectionPolicys.
type OutlierDetectionPolicyClient interface {
	OutlierDetectionPolicyReader
	OutlierDetectionPolicyWriter
	OutlierDetectionPolicyStatusWriter
}

type outlierDetectionPolicyClient struct {
	client client.Client
}

func NewOutlierDetectionPolicyClient(client client.Client) *outlierDetectionPolicyClient {
	return &outlierDetectionPolicyClient{client: client}
}

func (c *outlierDetectionPolicyClient) GetOutlierDetectionPolicy(ctx context.Context, key client.ObjectKey) (*OutlierDetectionPolicy, error) {
	obj := &OutlierDetectionPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *outlierDetectionPolicyClient) ListOutlierDetectionPolicy(ctx context.Context, opts ...client.ListOption) (*OutlierDetectionPolicyList, error) {
	list := &OutlierDetectionPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *outlierDetectionPolicyClient) CreateOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *outlierDetectionPolicyClient) DeleteOutlierDetectionPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &OutlierDetectionPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *outlierDetectionPolicyClient) UpdateOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *outlierDetectionPolicyClient) PatchOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *outlierDetectionPolicyClient) DeleteAllOfOutlierDetectionPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &OutlierDetectionPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *outlierDetectionPolicyClient) UpsertOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, transitionFuncs ...OutlierDetectionPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*OutlierDetectionPolicy), desired.(*OutlierDetectionPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *outlierDetectionPolicyClient) UpdateOutlierDetectionPolicyStatus(ctx context.Context, obj *OutlierDetectionPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *outlierDetectionPolicyClient) PatchOutlierDetectionPolicyStatus(ctx context.Context, obj *OutlierDetectionPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides OutlierDetectionPolicyClients for multiple clusters.
type MulticlusterOutlierDetectionPolicyClient interface {
	// Cluster returns a OutlierDetectionPolicyClient for the given cluster
	Cluster(cluster string) (OutlierDetectionPolicyClient, error)
}

type multiclusterOutlierDetectionPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterOutlierDetectionPolicyClient(client multicluster.Client) MulticlusterOutlierDetectionPolicyClient {
	return &multiclusterOutlierDetectionPolicyClient{client: client}
}

func (m *multiclusterOutlierDetectionPolicyClient) Cluster(cluster string) (OutlierDetectionPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewOutlierDetectionPolicyClient(client), nil
}

// Reader knows how to read and list AdaptiveRequestConcurrencyPolicys.
type AdaptiveRequestConcurrencyPolicyReader interface {
	// Get retrieves a AdaptiveRequestConcurrencyPolicy for the given object key
	GetAdaptiveRequestConcurrencyPolicy(ctx context.Context, key client.ObjectKey) (*AdaptiveRequestConcurrencyPolicy, error)

	// List retrieves list of AdaptiveRequestConcurrencyPolicys for a given namespace and list options.
	ListAdaptiveRequestConcurrencyPolicy(ctx context.Context, opts ...client.ListOption) (*AdaptiveRequestConcurrencyPolicyList, error)
}

// AdaptiveRequestConcurrencyPolicyTransitionFunction instructs the AdaptiveRequestConcurrencyPolicyWriter how to transition between an existing
// AdaptiveRequestConcurrencyPolicy object and a desired on an Upsert
type AdaptiveRequestConcurrencyPolicyTransitionFunction func(existing, desired *AdaptiveRequestConcurrencyPolicy) error

// Writer knows how to create, delete, and update AdaptiveRequestConcurrencyPolicys.
type AdaptiveRequestConcurrencyPolicyWriter interface {
	// Create saves the AdaptiveRequestConcurrencyPolicy object.
	CreateAdaptiveRequestConcurrencyPolicy(ctx context.Context, obj *AdaptiveRequestConcurrencyPolicy, opts ...client.CreateOption) error

	// Delete deletes the AdaptiveRequestConcurrencyPolicy object.
	DeleteAdaptiveRequestConcurrencyPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given AdaptiveRequestConcurrencyPolicy object.
	UpdateAdaptiveRequestConcurrencyPolicy(ctx context.Context, obj *AdaptiveRequestConcurrencyPolicy, opts ...client.UpdateOption) error

	// Patch patches the given AdaptiveRequestConcurrencyPolicy object.
	PatchAdaptiveRequestConcurrencyPolicy(ctx context.Context, obj *AdaptiveRequestConcurrencyPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all AdaptiveRequestConcurrencyPolicy objects matching the given options.
	DeleteAllOfAdaptiveRequestConcurrencyPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the AdaptiveRequestConcurrencyPolicy object.
	UpsertAdaptiveRequestConcurrencyPolicy(ctx context.Context, obj *AdaptiveRequestConcurrencyPolicy, transitionFuncs ...AdaptiveRequestConcurrencyPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a AdaptiveRequestConcurrencyPolicy object.
type AdaptiveRequestConcurrencyPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given AdaptiveRequestConcurrencyPolicy object.
	UpdateAdaptiveRequestConcurrencyPolicyStatus(ctx context.Context, obj *AdaptiveRequestConcurrencyPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given AdaptiveRequestConcurrencyPolicy object's subresource.
	PatchAdaptiveRequestConcurrencyPolicyStatus(ctx context.Context, obj *AdaptiveRequestConcurrencyPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on AdaptiveRequestConcurrencyPolicys.
type AdaptiveRequestConcurrencyPolicyClient interface {
	AdaptiveRequestConcurrencyPolicyReader
	AdaptiveRequestConcurrencyPolicyWriter
	AdaptiveRequestConcurrencyPolicyStatusWriter
}

type adaptiveRequestConcurrencyPolicyClient struct {
	client client.Client
}

func NewAdaptiveRequestConcurrencyPolicyClient(client client.Client) *adaptiveRequestConcurrencyPolicyClient {
	return &adaptiveRequestConcurrencyPolicyClient{client: client}
}

func (c *adaptiveRequestConcurrencyPolicyClient) GetAdaptiveRequestConcurrencyPolicy(ctx context.Context, key client.ObjectKey) (*AdaptiveRequestConcurrencyPolicy, error) {
	obj := &AdaptiveRequestConcurrencyPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *adaptiveRequestConcurrencyPolicyClient) ListAdaptiveRequestConcurrencyPolicy(ctx context.Context, opts ...client.ListOption) (*AdaptiveRequestConcurrencyPolicyList, error) {
	list := &AdaptiveRequestConcurrencyPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *adaptiveRequestConcurrencyPolicyClient) CreateAdaptiveRequestConcurrencyPolicy(ctx context.Context, obj *AdaptiveRequestConcurrencyPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *adaptiveRequestConcurrencyPolicyClient) DeleteAdaptiveRequestConcurrencyPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &AdaptiveRequestConcurrencyPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *adaptiveRequestConcurrencyPolicyClient) UpdateAdaptiveRequestConcurrencyPolicy(ctx context.Context, obj *AdaptiveRequestConcurrencyPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *adaptiveRequestConcurrencyPolicyClient) PatchAdaptiveRequestConcurrencyPolicy(ctx context.Context, obj *AdaptiveRequestConcurrencyPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *adaptiveRequestConcurrencyPolicyClient) DeleteAllOfAdaptiveRequestConcurrencyPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &AdaptiveRequestConcurrencyPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *adaptiveRequestConcurrencyPolicyClient) UpsertAdaptiveRequestConcurrencyPolicy(ctx context.Context, obj *AdaptiveRequestConcurrencyPolicy, transitionFuncs ...AdaptiveRequestConcurrencyPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*AdaptiveRequestConcurrencyPolicy), desired.(*AdaptiveRequestConcurrencyPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *adaptiveRequestConcurrencyPolicyClient) UpdateAdaptiveRequestConcurrencyPolicyStatus(ctx context.Context, obj *AdaptiveRequestConcurrencyPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *adaptiveRequestConcurrencyPolicyClient) PatchAdaptiveRequestConcurrencyPolicyStatus(ctx context.Context, obj *AdaptiveRequestConcurrencyPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides AdaptiveRequestConcurrencyPolicyClients for multiple clusters.
type MulticlusterAdaptiveRequestConcurrencyPolicyClient interface {
	// Cluster returns a AdaptiveRequestConcurrencyPolicyClient for the given cluster
	Cluster(cluster string) (AdaptiveRequestConcurrencyPolicyClient, error)
}

type multiclusterAdaptiveRequestConcurrencyPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterAdaptiveRequestConcurrencyPolicyClient(client multicluster.Client) MulticlusterAdaptiveRequestConcurrencyPolicyClient {
	return &multiclusterAdaptiveRequestConcurrencyPolicyClient{client: client}
}

func (m *multiclusterAdaptiveRequestConcurrencyPolicyClient) Cluster(cluster string) (AdaptiveRequestConcurrencyPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewAdaptiveRequestConcurrencyPolicyClient(client), nil
}

// Reader knows how to read and list FaultInjectionPolicys.
type FaultInjectionPolicyReader interface {
	// Get retrieves a FaultInjectionPolicy for the given object key
	GetFaultInjectionPolicy(ctx context.Context, key client.ObjectKey) (*FaultInjectionPolicy, error)

	// List retrieves list of FaultInjectionPolicys for a given namespace and list options.
	ListFaultInjectionPolicy(ctx context.Context, opts ...client.ListOption) (*FaultInjectionPolicyList, error)
}

// FaultInjectionPolicyTransitionFunction instructs the FaultInjectionPolicyWriter how to transition between an existing
// FaultInjectionPolicy object and a desired on an Upsert
type FaultInjectionPolicyTransitionFunction func(existing, desired *FaultInjectionPolicy) error

// Writer knows how to create, delete, and update FaultInjectionPolicys.
type FaultInjectionPolicyWriter interface {
	// Create saves the FaultInjectionPolicy object.
	CreateFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, opts ...client.CreateOption) error

	// Delete deletes the FaultInjectionPolicy object.
	DeleteFaultInjectionPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given FaultInjectionPolicy object.
	UpdateFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, opts ...client.UpdateOption) error

	// Patch patches the given FaultInjectionPolicy object.
	PatchFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all FaultInjectionPolicy objects matching the given options.
	DeleteAllOfFaultInjectionPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the FaultInjectionPolicy object.
	UpsertFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, transitionFuncs ...FaultInjectionPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a FaultInjectionPolicy object.
type FaultInjectionPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given FaultInjectionPolicy object.
	UpdateFaultInjectionPolicyStatus(ctx context.Context, obj *FaultInjectionPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given FaultInjectionPolicy object's subresource.
	PatchFaultInjectionPolicyStatus(ctx context.Context, obj *FaultInjectionPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on FaultInjectionPolicys.
type FaultInjectionPolicyClient interface {
	FaultInjectionPolicyReader
	FaultInjectionPolicyWriter
	FaultInjectionPolicyStatusWriter
}

type faultInjectionPolicyClient struct {
	client client.Client
}

func NewFaultInjectionPolicyClient(client client.Client) *faultInjectionPolicyClient {
	return &faultInjectionPolicyClient{client: client}
}

func (c *faultInjectionPolicyClient) GetFaultInjectionPolicy(ctx context.Context, key client.ObjectKey) (*FaultInjectionPolicy, error) {
	obj := &FaultInjectionPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *faultInjectionPolicyClient) ListFaultInjectionPolicy(ctx context.Context, opts ...client.ListOption) (*FaultInjectionPolicyList, error) {
	list := &FaultInjectionPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *faultInjectionPolicyClient) CreateFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *faultInjectionPolicyClient) DeleteFaultInjectionPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &FaultInjectionPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *faultInjectionPolicyClient) UpdateFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *faultInjectionPolicyClient) PatchFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *faultInjectionPolicyClient) DeleteAllOfFaultInjectionPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &FaultInjectionPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *faultInjectionPolicyClient) UpsertFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, transitionFuncs ...FaultInjectionPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*FaultInjectionPolicy), desired.(*FaultInjectionPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *faultInjectionPolicyClient) UpdateFaultInjectionPolicyStatus(ctx context.Context, obj *FaultInjectionPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *faultInjectionPolicyClient) PatchFaultInjectionPolicyStatus(ctx context.Context, obj *FaultInjectionPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides FaultInjectionPolicyClients for multiple clusters.
type MulticlusterFaultInjectionPolicyClient interface {
	// Cluster returns a FaultInjectionPolicyClient for the given cluster
	Cluster(cluster string) (FaultInjectionPolicyClient, error)
}

type multiclusterFaultInjectionPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterFaultInjectionPolicyClient(client multicluster.Client) MulticlusterFaultInjectionPolicyClient {
	return &multiclusterFaultInjectionPolicyClient{client: client}
}

func (m *multiclusterFaultInjectionPolicyClient) Cluster(cluster string) (FaultInjectionPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewFaultInjectionPolicyClient(client), nil
}

// Reader knows how to read and list RetryTimeoutPolicys.
type RetryTimeoutPolicyReader interface {
	// Get retrieves a RetryTimeoutPolicy for the given object key
	GetRetryTimeoutPolicy(ctx context.Context, key client.ObjectKey) (*RetryTimeoutPolicy, error)

	// List retrieves list of RetryTimeoutPolicys for a given namespace and list options.
	ListRetryTimeoutPolicy(ctx context.Context, opts ...client.ListOption) (*RetryTimeoutPolicyList, error)
}

// RetryTimeoutPolicyTransitionFunction instructs the RetryTimeoutPolicyWriter how to transition between an existing
// RetryTimeoutPolicy object and a desired on an Upsert
type RetryTimeoutPolicyTransitionFunction func(existing, desired *RetryTimeoutPolicy) error

// Writer knows how to create, delete, and update RetryTimeoutPolicys.
type RetryTimeoutPolicyWriter interface {
	// Create saves the RetryTimeoutPolicy object.
	CreateRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, opts ...client.CreateOption) error

	// Delete deletes the RetryTimeoutPolicy object.
	DeleteRetryTimeoutPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given RetryTimeoutPolicy object.
	UpdateRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, opts ...client.UpdateOption) error

	// Patch patches the given RetryTimeoutPolicy object.
	PatchRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all RetryTimeoutPolicy objects matching the given options.
	DeleteAllOfRetryTimeoutPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the RetryTimeoutPolicy object.
	UpsertRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, transitionFuncs ...RetryTimeoutPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a RetryTimeoutPolicy object.
type RetryTimeoutPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given RetryTimeoutPolicy object.
	UpdateRetryTimeoutPolicyStatus(ctx context.Context, obj *RetryTimeoutPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given RetryTimeoutPolicy object's subresource.
	PatchRetryTimeoutPolicyStatus(ctx context.Context, obj *RetryTimeoutPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on RetryTimeoutPolicys.
type RetryTimeoutPolicyClient interface {
	RetryTimeoutPolicyReader
	RetryTimeoutPolicyWriter
	RetryTimeoutPolicyStatusWriter
}

type retryTimeoutPolicyClient struct {
	client client.Client
}

func NewRetryTimeoutPolicyClient(client client.Client) *retryTimeoutPolicyClient {
	return &retryTimeoutPolicyClient{client: client}
}

func (c *retryTimeoutPolicyClient) GetRetryTimeoutPolicy(ctx context.Context, key client.ObjectKey) (*RetryTimeoutPolicy, error) {
	obj := &RetryTimeoutPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *retryTimeoutPolicyClient) ListRetryTimeoutPolicy(ctx context.Context, opts ...client.ListOption) (*RetryTimeoutPolicyList, error) {
	list := &RetryTimeoutPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *retryTimeoutPolicyClient) CreateRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *retryTimeoutPolicyClient) DeleteRetryTimeoutPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &RetryTimeoutPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *retryTimeoutPolicyClient) UpdateRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *retryTimeoutPolicyClient) PatchRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *retryTimeoutPolicyClient) DeleteAllOfRetryTimeoutPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &RetryTimeoutPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *retryTimeoutPolicyClient) UpsertRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, transitionFuncs ...RetryTimeoutPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*RetryTimeoutPolicy), desired.(*RetryTimeoutPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *retryTimeoutPolicyClient) UpdateRetryTimeoutPolicyStatus(ctx context.Context, obj *RetryTimeoutPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *retryTimeoutPolicyClient) PatchRetryTimeoutPolicyStatus(ctx context.Context, obj *RetryTimeoutPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides RetryTimeoutPolicyClients for multiple clusters.
type MulticlusterRetryTimeoutPolicyClient interface {
	// Cluster returns a RetryTimeoutPolicyClient for the given cluster
	Cluster(cluster string) (RetryTimeoutPolicyClient, error)
}

type multiclusterRetryTimeoutPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterRetryTimeoutPolicyClient(client multicluster.Client) MulticlusterRetryTimeoutPolicyClient {
	return &multiclusterRetryTimeoutPolicyClient{client: client}
}

func (m *multiclusterRetryTimeoutPolicyClient) Cluster(cluster string) (RetryTimeoutPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewRetryTimeoutPolicyClient(client), nil
}

// Reader knows how to read and list ConnectionPolicys.
type ConnectionPolicyReader interface {
	// Get retrieves a ConnectionPolicy for the given object key
	GetConnectionPolicy(ctx context.Context, key client.ObjectKey) (*ConnectionPolicy, error)

	// List retrieves list of ConnectionPolicys for a given namespace and list options.
	ListConnectionPolicy(ctx context.Context, opts ...client.ListOption) (*ConnectionPolicyList, error)
}

// ConnectionPolicyTransitionFunction instructs the ConnectionPolicyWriter how to transition between an existing
// ConnectionPolicy object and a desired on an Upsert
type ConnectionPolicyTransitionFunction func(existing, desired *ConnectionPolicy) error

// Writer knows how to create, delete, and update ConnectionPolicys.
type ConnectionPolicyWriter interface {
	// Create saves the ConnectionPolicy object.
	CreateConnectionPolicy(ctx context.Context, obj *ConnectionPolicy, opts ...client.CreateOption) error

	// Delete deletes the ConnectionPolicy object.
	DeleteConnectionPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given ConnectionPolicy object.
	UpdateConnectionPolicy(ctx context.Context, obj *ConnectionPolicy, opts ...client.UpdateOption) error

	// Patch patches the given ConnectionPolicy object.
	PatchConnectionPolicy(ctx context.Context, obj *ConnectionPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all ConnectionPolicy objects matching the given options.
	DeleteAllOfConnectionPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the ConnectionPolicy object.
	UpsertConnectionPolicy(ctx context.Context, obj *ConnectionPolicy, transitionFuncs ...ConnectionPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a ConnectionPolicy object.
type ConnectionPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given ConnectionPolicy object.
	UpdateConnectionPolicyStatus(ctx context.Context, obj *ConnectionPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given ConnectionPolicy object's subresource.
	PatchConnectionPolicyStatus(ctx context.Context, obj *ConnectionPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on ConnectionPolicys.
type ConnectionPolicyClient interface {
	ConnectionPolicyReader
	ConnectionPolicyWriter
	ConnectionPolicyStatusWriter
}

type connectionPolicyClient struct {
	client client.Client
}

func NewConnectionPolicyClient(client client.Client) *connectionPolicyClient {
	return &connectionPolicyClient{client: client}
}

func (c *connectionPolicyClient) GetConnectionPolicy(ctx context.Context, key client.ObjectKey) (*ConnectionPolicy, error) {
	obj := &ConnectionPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *connectionPolicyClient) ListConnectionPolicy(ctx context.Context, opts ...client.ListOption) (*ConnectionPolicyList, error) {
	list := &ConnectionPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *connectionPolicyClient) CreateConnectionPolicy(ctx context.Context, obj *ConnectionPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *connectionPolicyClient) DeleteConnectionPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &ConnectionPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *connectionPolicyClient) UpdateConnectionPolicy(ctx context.Context, obj *ConnectionPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *connectionPolicyClient) PatchConnectionPolicy(ctx context.Context, obj *ConnectionPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *connectionPolicyClient) DeleteAllOfConnectionPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &ConnectionPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *connectionPolicyClient) UpsertConnectionPolicy(ctx context.Context, obj *ConnectionPolicy, transitionFuncs ...ConnectionPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*ConnectionPolicy), desired.(*ConnectionPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *connectionPolicyClient) UpdateConnectionPolicyStatus(ctx context.Context, obj *ConnectionPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *connectionPolicyClient) PatchConnectionPolicyStatus(ctx context.Context, obj *ConnectionPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides ConnectionPolicyClients for multiple clusters.
type MulticlusterConnectionPolicyClient interface {
	// Cluster returns a ConnectionPolicyClient for the given cluster
	Cluster(cluster string) (ConnectionPolicyClient, error)
}

type multiclusterConnectionPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterConnectionPolicyClient(client multicluster.Client) MulticlusterConnectionPolicyClient {
	return &multiclusterConnectionPolicyClient{client: client}
}

func (m *multiclusterConnectionPolicyClient) Cluster(cluster string) (ConnectionPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewConnectionPolicyClient(client), nil
}

// Reader knows how to read and list TrimProxyConfigPolicys.
type TrimProxyConfigPolicyReader interface {
	// Get retrieves a TrimProxyConfigPolicy for the given object key
	GetTrimProxyConfigPolicy(ctx context.Context, key client.ObjectKey) (*TrimProxyConfigPolicy, error)

	// List retrieves list of TrimProxyConfigPolicys for a given namespace and list options.
	ListTrimProxyConfigPolicy(ctx context.Context, opts ...client.ListOption) (*TrimProxyConfigPolicyList, error)
}

// TrimProxyConfigPolicyTransitionFunction instructs the TrimProxyConfigPolicyWriter how to transition between an existing
// TrimProxyConfigPolicy object and a desired on an Upsert
type TrimProxyConfigPolicyTransitionFunction func(existing, desired *TrimProxyConfigPolicy) error

// Writer knows how to create, delete, and update TrimProxyConfigPolicys.
type TrimProxyConfigPolicyWriter interface {
	// Create saves the TrimProxyConfigPolicy object.
	CreateTrimProxyConfigPolicy(ctx context.Context, obj *TrimProxyConfigPolicy, opts ...client.CreateOption) error

	// Delete deletes the TrimProxyConfigPolicy object.
	DeleteTrimProxyConfigPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given TrimProxyConfigPolicy object.
	UpdateTrimProxyConfigPolicy(ctx context.Context, obj *TrimProxyConfigPolicy, opts ...client.UpdateOption) error

	// Patch patches the given TrimProxyConfigPolicy object.
	PatchTrimProxyConfigPolicy(ctx context.Context, obj *TrimProxyConfigPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all TrimProxyConfigPolicy objects matching the given options.
	DeleteAllOfTrimProxyConfigPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the TrimProxyConfigPolicy object.
	UpsertTrimProxyConfigPolicy(ctx context.Context, obj *TrimProxyConfigPolicy, transitionFuncs ...TrimProxyConfigPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a TrimProxyConfigPolicy object.
type TrimProxyConfigPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given TrimProxyConfigPolicy object.
	UpdateTrimProxyConfigPolicyStatus(ctx context.Context, obj *TrimProxyConfigPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given TrimProxyConfigPolicy object's subresource.
	PatchTrimProxyConfigPolicyStatus(ctx context.Context, obj *TrimProxyConfigPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on TrimProxyConfigPolicys.
type TrimProxyConfigPolicyClient interface {
	TrimProxyConfigPolicyReader
	TrimProxyConfigPolicyWriter
	TrimProxyConfigPolicyStatusWriter
}

type trimProxyConfigPolicyClient struct {
	client client.Client
}

func NewTrimProxyConfigPolicyClient(client client.Client) *trimProxyConfigPolicyClient {
	return &trimProxyConfigPolicyClient{client: client}
}

func (c *trimProxyConfigPolicyClient) GetTrimProxyConfigPolicy(ctx context.Context, key client.ObjectKey) (*TrimProxyConfigPolicy, error) {
	obj := &TrimProxyConfigPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *trimProxyConfigPolicyClient) ListTrimProxyConfigPolicy(ctx context.Context, opts ...client.ListOption) (*TrimProxyConfigPolicyList, error) {
	list := &TrimProxyConfigPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *trimProxyConfigPolicyClient) CreateTrimProxyConfigPolicy(ctx context.Context, obj *TrimProxyConfigPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *trimProxyConfigPolicyClient) DeleteTrimProxyConfigPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &TrimProxyConfigPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *trimProxyConfigPolicyClient) UpdateTrimProxyConfigPolicy(ctx context.Context, obj *TrimProxyConfigPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *trimProxyConfigPolicyClient) PatchTrimProxyConfigPolicy(ctx context.Context, obj *TrimProxyConfigPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *trimProxyConfigPolicyClient) DeleteAllOfTrimProxyConfigPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &TrimProxyConfigPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *trimProxyConfigPolicyClient) UpsertTrimProxyConfigPolicy(ctx context.Context, obj *TrimProxyConfigPolicy, transitionFuncs ...TrimProxyConfigPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*TrimProxyConfigPolicy), desired.(*TrimProxyConfigPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *trimProxyConfigPolicyClient) UpdateTrimProxyConfigPolicyStatus(ctx context.Context, obj *TrimProxyConfigPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *trimProxyConfigPolicyClient) PatchTrimProxyConfigPolicyStatus(ctx context.Context, obj *TrimProxyConfigPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides TrimProxyConfigPolicyClients for multiple clusters.
type MulticlusterTrimProxyConfigPolicyClient interface {
	// Cluster returns a TrimProxyConfigPolicyClient for the given cluster
	Cluster(cluster string) (TrimProxyConfigPolicyClient, error)
}

type multiclusterTrimProxyConfigPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterTrimProxyConfigPolicyClient(client multicluster.Client) MulticlusterTrimProxyConfigPolicyClient {
	return &multiclusterTrimProxyConfigPolicyClient{client: client}
}

func (m *multiclusterTrimProxyConfigPolicyClient) Cluster(cluster string) (TrimProxyConfigPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewTrimProxyConfigPolicyClient(client), nil
}

// Reader knows how to read and list ActiveHealthCheckPolicys.
type ActiveHealthCheckPolicyReader interface {
	// Get retrieves a ActiveHealthCheckPolicy for the given object key
	GetActiveHealthCheckPolicy(ctx context.Context, key client.ObjectKey) (*ActiveHealthCheckPolicy, error)

	// List retrieves list of ActiveHealthCheckPolicys for a given namespace and list options.
	ListActiveHealthCheckPolicy(ctx context.Context, opts ...client.ListOption) (*ActiveHealthCheckPolicyList, error)
}

// ActiveHealthCheckPolicyTransitionFunction instructs the ActiveHealthCheckPolicyWriter how to transition between an existing
// ActiveHealthCheckPolicy object and a desired on an Upsert
type ActiveHealthCheckPolicyTransitionFunction func(existing, desired *ActiveHealthCheckPolicy) error

// Writer knows how to create, delete, and update ActiveHealthCheckPolicys.
type ActiveHealthCheckPolicyWriter interface {
	// Create saves the ActiveHealthCheckPolicy object.
	CreateActiveHealthCheckPolicy(ctx context.Context, obj *ActiveHealthCheckPolicy, opts ...client.CreateOption) error

	// Delete deletes the ActiveHealthCheckPolicy object.
	DeleteActiveHealthCheckPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given ActiveHealthCheckPolicy object.
	UpdateActiveHealthCheckPolicy(ctx context.Context, obj *ActiveHealthCheckPolicy, opts ...client.UpdateOption) error

	// Patch patches the given ActiveHealthCheckPolicy object.
	PatchActiveHealthCheckPolicy(ctx context.Context, obj *ActiveHealthCheckPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all ActiveHealthCheckPolicy objects matching the given options.
	DeleteAllOfActiveHealthCheckPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the ActiveHealthCheckPolicy object.
	UpsertActiveHealthCheckPolicy(ctx context.Context, obj *ActiveHealthCheckPolicy, transitionFuncs ...ActiveHealthCheckPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a ActiveHealthCheckPolicy object.
type ActiveHealthCheckPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given ActiveHealthCheckPolicy object.
	UpdateActiveHealthCheckPolicyStatus(ctx context.Context, obj *ActiveHealthCheckPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given ActiveHealthCheckPolicy object's subresource.
	PatchActiveHealthCheckPolicyStatus(ctx context.Context, obj *ActiveHealthCheckPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on ActiveHealthCheckPolicys.
type ActiveHealthCheckPolicyClient interface {
	ActiveHealthCheckPolicyReader
	ActiveHealthCheckPolicyWriter
	ActiveHealthCheckPolicyStatusWriter
}

type activeHealthCheckPolicyClient struct {
	client client.Client
}

func NewActiveHealthCheckPolicyClient(client client.Client) *activeHealthCheckPolicyClient {
	return &activeHealthCheckPolicyClient{client: client}
}

func (c *activeHealthCheckPolicyClient) GetActiveHealthCheckPolicy(ctx context.Context, key client.ObjectKey) (*ActiveHealthCheckPolicy, error) {
	obj := &ActiveHealthCheckPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *activeHealthCheckPolicyClient) ListActiveHealthCheckPolicy(ctx context.Context, opts ...client.ListOption) (*ActiveHealthCheckPolicyList, error) {
	list := &ActiveHealthCheckPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *activeHealthCheckPolicyClient) CreateActiveHealthCheckPolicy(ctx context.Context, obj *ActiveHealthCheckPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *activeHealthCheckPolicyClient) DeleteActiveHealthCheckPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &ActiveHealthCheckPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *activeHealthCheckPolicyClient) UpdateActiveHealthCheckPolicy(ctx context.Context, obj *ActiveHealthCheckPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *activeHealthCheckPolicyClient) PatchActiveHealthCheckPolicy(ctx context.Context, obj *ActiveHealthCheckPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *activeHealthCheckPolicyClient) DeleteAllOfActiveHealthCheckPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &ActiveHealthCheckPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *activeHealthCheckPolicyClient) UpsertActiveHealthCheckPolicy(ctx context.Context, obj *ActiveHealthCheckPolicy, transitionFuncs ...ActiveHealthCheckPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*ActiveHealthCheckPolicy), desired.(*ActiveHealthCheckPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *activeHealthCheckPolicyClient) UpdateActiveHealthCheckPolicyStatus(ctx context.Context, obj *ActiveHealthCheckPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *activeHealthCheckPolicyClient) PatchActiveHealthCheckPolicyStatus(ctx context.Context, obj *ActiveHealthCheckPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides ActiveHealthCheckPolicyClients for multiple clusters.
type MulticlusterActiveHealthCheckPolicyClient interface {
	// Cluster returns a ActiveHealthCheckPolicyClient for the given cluster
	Cluster(cluster string) (ActiveHealthCheckPolicyClient, error)
}

type multiclusterActiveHealthCheckPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterActiveHealthCheckPolicyClient(client multicluster.Client) MulticlusterActiveHealthCheckPolicyClient {
	return &multiclusterActiveHealthCheckPolicyClient{client: client}
}

func (m *multiclusterActiveHealthCheckPolicyClient) Cluster(cluster string) (ActiveHealthCheckPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewActiveHealthCheckPolicyClient(client), nil
}

// Reader knows how to read and list ListenerConnectionPolicys.
type ListenerConnectionPolicyReader interface {
	// Get retrieves a ListenerConnectionPolicy for the given object key
	GetListenerConnectionPolicy(ctx context.Context, key client.ObjectKey) (*ListenerConnectionPolicy, error)

	// List retrieves list of ListenerConnectionPolicys for a given namespace and list options.
	ListListenerConnectionPolicy(ctx context.Context, opts ...client.ListOption) (*ListenerConnectionPolicyList, error)
}

// ListenerConnectionPolicyTransitionFunction instructs the ListenerConnectionPolicyWriter how to transition between an existing
// ListenerConnectionPolicy object and a desired on an Upsert
type ListenerConnectionPolicyTransitionFunction func(existing, desired *ListenerConnectionPolicy) error

// Writer knows how to create, delete, and update ListenerConnectionPolicys.
type ListenerConnectionPolicyWriter interface {
	// Create saves the ListenerConnectionPolicy object.
	CreateListenerConnectionPolicy(ctx context.Context, obj *ListenerConnectionPolicy, opts ...client.CreateOption) error

	// Delete deletes the ListenerConnectionPolicy object.
	DeleteListenerConnectionPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given ListenerConnectionPolicy object.
	UpdateListenerConnectionPolicy(ctx context.Context, obj *ListenerConnectionPolicy, opts ...client.UpdateOption) error

	// Patch patches the given ListenerConnectionPolicy object.
	PatchListenerConnectionPolicy(ctx context.Context, obj *ListenerConnectionPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all ListenerConnectionPolicy objects matching the given options.
	DeleteAllOfListenerConnectionPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the ListenerConnectionPolicy object.
	UpsertListenerConnectionPolicy(ctx context.Context, obj *ListenerConnectionPolicy, transitionFuncs ...ListenerConnectionPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a ListenerConnectionPolicy object.
type ListenerConnectionPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given ListenerConnectionPolicy object.
	UpdateListenerConnectionPolicyStatus(ctx context.Context, obj *ListenerConnectionPolicy, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given ListenerConnectionPolicy object's subresource.
	PatchListenerConnectionPolicyStatus(ctx context.Context, obj *ListenerConnectionPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on ListenerConnectionPolicys.
type ListenerConnectionPolicyClient interface {
	ListenerConnectionPolicyReader
	ListenerConnectionPolicyWriter
	ListenerConnectionPolicyStatusWriter
}

type listenerConnectionPolicyClient struct {
	client client.Client
}

func NewListenerConnectionPolicyClient(client client.Client) *listenerConnectionPolicyClient {
	return &listenerConnectionPolicyClient{client: client}
}

func (c *listenerConnectionPolicyClient) GetListenerConnectionPolicy(ctx context.Context, key client.ObjectKey) (*ListenerConnectionPolicy, error) {
	obj := &ListenerConnectionPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *listenerConnectionPolicyClient) ListListenerConnectionPolicy(ctx context.Context, opts ...client.ListOption) (*ListenerConnectionPolicyList, error) {
	list := &ListenerConnectionPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *listenerConnectionPolicyClient) CreateListenerConnectionPolicy(ctx context.Context, obj *ListenerConnectionPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *listenerConnectionPolicyClient) DeleteListenerConnectionPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &ListenerConnectionPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *listenerConnectionPolicyClient) UpdateListenerConnectionPolicy(ctx context.Context, obj *ListenerConnectionPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *listenerConnectionPolicyClient) PatchListenerConnectionPolicy(ctx context.Context, obj *ListenerConnectionPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *listenerConnectionPolicyClient) DeleteAllOfListenerConnectionPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &ListenerConnectionPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *listenerConnectionPolicyClient) UpsertListenerConnectionPolicy(ctx context.Context, obj *ListenerConnectionPolicy, transitionFuncs ...ListenerConnectionPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*ListenerConnectionPolicy), desired.(*ListenerConnectionPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *listenerConnectionPolicyClient) UpdateListenerConnectionPolicyStatus(ctx context.Context, obj *ListenerConnectionPolicy, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *listenerConnectionPolicyClient) PatchListenerConnectionPolicyStatus(ctx context.Context, obj *ListenerConnectionPolicy, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides ListenerConnectionPolicyClients for multiple clusters.
type MulticlusterListenerConnectionPolicyClient interface {
	// Cluster returns a ListenerConnectionPolicyClient for the given cluster
	Cluster(cluster string) (ListenerConnectionPolicyClient, error)
}

type multiclusterListenerConnectionPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterListenerConnectionPolicyClient(client multicluster.Client) MulticlusterListenerConnectionPolicyClient {
	return &multiclusterListenerConnectionPolicyClient{client: client}
}

func (m *multiclusterListenerConnectionPolicyClient) Cluster(cluster string) (ListenerConnectionPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewListenerConnectionPolicyClient(client), nil
}
