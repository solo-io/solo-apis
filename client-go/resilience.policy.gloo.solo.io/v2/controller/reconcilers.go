// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./reconcilers.go -destination mocks/reconcilers.go

// Definitions for the Kubernetes Controllers
package controller

import (
	"context"

	resilience_policy_gloo_solo_io_v2 "github.com/solo-io/solo-apis/client-go/resilience.policy.gloo.solo.io/v2"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the GraphQLPersistedQueryCachePolicy Resource.
// implemented by the user
type GraphQLPersistedQueryCachePolicyReconciler interface {
	ReconcileGraphQLPersistedQueryCachePolicy(obj *resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the GraphQLPersistedQueryCachePolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type GraphQLPersistedQueryCachePolicyDeletionReconciler interface {
	ReconcileGraphQLPersistedQueryCachePolicyDeletion(req reconcile.Request) error
}

type GraphQLPersistedQueryCachePolicyReconcilerFuncs struct {
	OnReconcileGraphQLPersistedQueryCachePolicy         func(obj *resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) (reconcile.Result, error)
	OnReconcileGraphQLPersistedQueryCachePolicyDeletion func(req reconcile.Request) error
}

func (f *GraphQLPersistedQueryCachePolicyReconcilerFuncs) ReconcileGraphQLPersistedQueryCachePolicy(obj *resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) (reconcile.Result, error) {
	if f.OnReconcileGraphQLPersistedQueryCachePolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileGraphQLPersistedQueryCachePolicy(obj)
}

func (f *GraphQLPersistedQueryCachePolicyReconcilerFuncs) ReconcileGraphQLPersistedQueryCachePolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileGraphQLPersistedQueryCachePolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileGraphQLPersistedQueryCachePolicyDeletion(req)
}

// Reconcile and finalize the GraphQLPersistedQueryCachePolicy Resource
// implemented by the user
type GraphQLPersistedQueryCachePolicyFinalizer interface {
	GraphQLPersistedQueryCachePolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	GraphQLPersistedQueryCachePolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeGraphQLPersistedQueryCachePolicy(obj *resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy) error
}

type GraphQLPersistedQueryCachePolicyReconcileLoop interface {
	RunGraphQLPersistedQueryCachePolicyReconciler(ctx context.Context, rec GraphQLPersistedQueryCachePolicyReconciler, predicates ...predicate.Predicate) error
}

type graphQLPersistedQueryCachePolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewGraphQLPersistedQueryCachePolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) GraphQLPersistedQueryCachePolicyReconcileLoop {
	return &graphQLPersistedQueryCachePolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy{}, options),
	}
}

func (c *graphQLPersistedQueryCachePolicyReconcileLoop) RunGraphQLPersistedQueryCachePolicyReconciler(ctx context.Context, reconciler GraphQLPersistedQueryCachePolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericGraphQLPersistedQueryCachePolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(GraphQLPersistedQueryCachePolicyFinalizer); ok {
		reconcilerWrapper = genericGraphQLPersistedQueryCachePolicyFinalizer{
			genericGraphQLPersistedQueryCachePolicyReconciler: genericReconciler,
			finalizingReconciler:                              finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericGraphQLPersistedQueryCachePolicyHandler implements a generic reconcile.Reconciler
type genericGraphQLPersistedQueryCachePolicyReconciler struct {
	reconciler GraphQLPersistedQueryCachePolicyReconciler
}

func (r genericGraphQLPersistedQueryCachePolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: GraphQLPersistedQueryCachePolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileGraphQLPersistedQueryCachePolicy(obj)
}

func (r genericGraphQLPersistedQueryCachePolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(GraphQLPersistedQueryCachePolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileGraphQLPersistedQueryCachePolicyDeletion(request)
	}
	return nil
}

// genericGraphQLPersistedQueryCachePolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericGraphQLPersistedQueryCachePolicyFinalizer struct {
	genericGraphQLPersistedQueryCachePolicyReconciler
	finalizingReconciler GraphQLPersistedQueryCachePolicyFinalizer
}

func (r genericGraphQLPersistedQueryCachePolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.GraphQLPersistedQueryCachePolicyFinalizerName()
}

func (r genericGraphQLPersistedQueryCachePolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.GraphQLPersistedQueryCachePolicy)
	if !ok {
		return errors.Errorf("internal error: GraphQLPersistedQueryCachePolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeGraphQLPersistedQueryCachePolicy(obj)
}

// Reconcile Upsert events for the FailoverPolicy Resource.
// implemented by the user
type FailoverPolicyReconciler interface {
	ReconcileFailoverPolicy(obj *resilience_policy_gloo_solo_io_v2.FailoverPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the FailoverPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type FailoverPolicyDeletionReconciler interface {
	ReconcileFailoverPolicyDeletion(req reconcile.Request) error
}

type FailoverPolicyReconcilerFuncs struct {
	OnReconcileFailoverPolicy         func(obj *resilience_policy_gloo_solo_io_v2.FailoverPolicy) (reconcile.Result, error)
	OnReconcileFailoverPolicyDeletion func(req reconcile.Request) error
}

func (f *FailoverPolicyReconcilerFuncs) ReconcileFailoverPolicy(obj *resilience_policy_gloo_solo_io_v2.FailoverPolicy) (reconcile.Result, error) {
	if f.OnReconcileFailoverPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileFailoverPolicy(obj)
}

func (f *FailoverPolicyReconcilerFuncs) ReconcileFailoverPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileFailoverPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileFailoverPolicyDeletion(req)
}

// Reconcile and finalize the FailoverPolicy Resource
// implemented by the user
type FailoverPolicyFinalizer interface {
	FailoverPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	FailoverPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeFailoverPolicy(obj *resilience_policy_gloo_solo_io_v2.FailoverPolicy) error
}

type FailoverPolicyReconcileLoop interface {
	RunFailoverPolicyReconciler(ctx context.Context, rec FailoverPolicyReconciler, predicates ...predicate.Predicate) error
}

type failoverPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewFailoverPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) FailoverPolicyReconcileLoop {
	return &failoverPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.FailoverPolicy{}, options),
	}
}

func (c *failoverPolicyReconcileLoop) RunFailoverPolicyReconciler(ctx context.Context, reconciler FailoverPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericFailoverPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(FailoverPolicyFinalizer); ok {
		reconcilerWrapper = genericFailoverPolicyFinalizer{
			genericFailoverPolicyReconciler: genericReconciler,
			finalizingReconciler:            finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericFailoverPolicyHandler implements a generic reconcile.Reconciler
type genericFailoverPolicyReconciler struct {
	reconciler FailoverPolicyReconciler
}

func (r genericFailoverPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: FailoverPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileFailoverPolicy(obj)
}

func (r genericFailoverPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(FailoverPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileFailoverPolicyDeletion(request)
	}
	return nil
}

// genericFailoverPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericFailoverPolicyFinalizer struct {
	genericFailoverPolicyReconciler
	finalizingReconciler FailoverPolicyFinalizer
}

func (r genericFailoverPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.FailoverPolicyFinalizerName()
}

func (r genericFailoverPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.FailoverPolicy)
	if !ok {
		return errors.Errorf("internal error: FailoverPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeFailoverPolicy(obj)
}

// Reconcile Upsert events for the OutlierDetectionPolicy Resource.
// implemented by the user
type OutlierDetectionPolicyReconciler interface {
	ReconcileOutlierDetectionPolicy(obj *resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the OutlierDetectionPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type OutlierDetectionPolicyDeletionReconciler interface {
	ReconcileOutlierDetectionPolicyDeletion(req reconcile.Request) error
}

type OutlierDetectionPolicyReconcilerFuncs struct {
	OnReconcileOutlierDetectionPolicy         func(obj *resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) (reconcile.Result, error)
	OnReconcileOutlierDetectionPolicyDeletion func(req reconcile.Request) error
}

func (f *OutlierDetectionPolicyReconcilerFuncs) ReconcileOutlierDetectionPolicy(obj *resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) (reconcile.Result, error) {
	if f.OnReconcileOutlierDetectionPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileOutlierDetectionPolicy(obj)
}

func (f *OutlierDetectionPolicyReconcilerFuncs) ReconcileOutlierDetectionPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileOutlierDetectionPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileOutlierDetectionPolicyDeletion(req)
}

// Reconcile and finalize the OutlierDetectionPolicy Resource
// implemented by the user
type OutlierDetectionPolicyFinalizer interface {
	OutlierDetectionPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	OutlierDetectionPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeOutlierDetectionPolicy(obj *resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy) error
}

type OutlierDetectionPolicyReconcileLoop interface {
	RunOutlierDetectionPolicyReconciler(ctx context.Context, rec OutlierDetectionPolicyReconciler, predicates ...predicate.Predicate) error
}

type outlierDetectionPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewOutlierDetectionPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) OutlierDetectionPolicyReconcileLoop {
	return &outlierDetectionPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy{}, options),
	}
}

func (c *outlierDetectionPolicyReconcileLoop) RunOutlierDetectionPolicyReconciler(ctx context.Context, reconciler OutlierDetectionPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericOutlierDetectionPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(OutlierDetectionPolicyFinalizer); ok {
		reconcilerWrapper = genericOutlierDetectionPolicyFinalizer{
			genericOutlierDetectionPolicyReconciler: genericReconciler,
			finalizingReconciler:                    finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericOutlierDetectionPolicyHandler implements a generic reconcile.Reconciler
type genericOutlierDetectionPolicyReconciler struct {
	reconciler OutlierDetectionPolicyReconciler
}

func (r genericOutlierDetectionPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: OutlierDetectionPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileOutlierDetectionPolicy(obj)
}

func (r genericOutlierDetectionPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(OutlierDetectionPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileOutlierDetectionPolicyDeletion(request)
	}
	return nil
}

// genericOutlierDetectionPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericOutlierDetectionPolicyFinalizer struct {
	genericOutlierDetectionPolicyReconciler
	finalizingReconciler OutlierDetectionPolicyFinalizer
}

func (r genericOutlierDetectionPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.OutlierDetectionPolicyFinalizerName()
}

func (r genericOutlierDetectionPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.OutlierDetectionPolicy)
	if !ok {
		return errors.Errorf("internal error: OutlierDetectionPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeOutlierDetectionPolicy(obj)
}

// Reconcile Upsert events for the FaultInjectionPolicy Resource.
// implemented by the user
type FaultInjectionPolicyReconciler interface {
	ReconcileFaultInjectionPolicy(obj *resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the FaultInjectionPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type FaultInjectionPolicyDeletionReconciler interface {
	ReconcileFaultInjectionPolicyDeletion(req reconcile.Request) error
}

type FaultInjectionPolicyReconcilerFuncs struct {
	OnReconcileFaultInjectionPolicy         func(obj *resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) (reconcile.Result, error)
	OnReconcileFaultInjectionPolicyDeletion func(req reconcile.Request) error
}

func (f *FaultInjectionPolicyReconcilerFuncs) ReconcileFaultInjectionPolicy(obj *resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) (reconcile.Result, error) {
	if f.OnReconcileFaultInjectionPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileFaultInjectionPolicy(obj)
}

func (f *FaultInjectionPolicyReconcilerFuncs) ReconcileFaultInjectionPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileFaultInjectionPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileFaultInjectionPolicyDeletion(req)
}

// Reconcile and finalize the FaultInjectionPolicy Resource
// implemented by the user
type FaultInjectionPolicyFinalizer interface {
	FaultInjectionPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	FaultInjectionPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeFaultInjectionPolicy(obj *resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy) error
}

type FaultInjectionPolicyReconcileLoop interface {
	RunFaultInjectionPolicyReconciler(ctx context.Context, rec FaultInjectionPolicyReconciler, predicates ...predicate.Predicate) error
}

type faultInjectionPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewFaultInjectionPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) FaultInjectionPolicyReconcileLoop {
	return &faultInjectionPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy{}, options),
	}
}

func (c *faultInjectionPolicyReconcileLoop) RunFaultInjectionPolicyReconciler(ctx context.Context, reconciler FaultInjectionPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericFaultInjectionPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(FaultInjectionPolicyFinalizer); ok {
		reconcilerWrapper = genericFaultInjectionPolicyFinalizer{
			genericFaultInjectionPolicyReconciler: genericReconciler,
			finalizingReconciler:                  finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericFaultInjectionPolicyHandler implements a generic reconcile.Reconciler
type genericFaultInjectionPolicyReconciler struct {
	reconciler FaultInjectionPolicyReconciler
}

func (r genericFaultInjectionPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: FaultInjectionPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileFaultInjectionPolicy(obj)
}

func (r genericFaultInjectionPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(FaultInjectionPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileFaultInjectionPolicyDeletion(request)
	}
	return nil
}

// genericFaultInjectionPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericFaultInjectionPolicyFinalizer struct {
	genericFaultInjectionPolicyReconciler
	finalizingReconciler FaultInjectionPolicyFinalizer
}

func (r genericFaultInjectionPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.FaultInjectionPolicyFinalizerName()
}

func (r genericFaultInjectionPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.FaultInjectionPolicy)
	if !ok {
		return errors.Errorf("internal error: FaultInjectionPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeFaultInjectionPolicy(obj)
}

// Reconcile Upsert events for the RetryTimeoutPolicy Resource.
// implemented by the user
type RetryTimeoutPolicyReconciler interface {
	ReconcileRetryTimeoutPolicy(obj *resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the RetryTimeoutPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type RetryTimeoutPolicyDeletionReconciler interface {
	ReconcileRetryTimeoutPolicyDeletion(req reconcile.Request) error
}

type RetryTimeoutPolicyReconcilerFuncs struct {
	OnReconcileRetryTimeoutPolicy         func(obj *resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) (reconcile.Result, error)
	OnReconcileRetryTimeoutPolicyDeletion func(req reconcile.Request) error
}

func (f *RetryTimeoutPolicyReconcilerFuncs) ReconcileRetryTimeoutPolicy(obj *resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) (reconcile.Result, error) {
	if f.OnReconcileRetryTimeoutPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileRetryTimeoutPolicy(obj)
}

func (f *RetryTimeoutPolicyReconcilerFuncs) ReconcileRetryTimeoutPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileRetryTimeoutPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileRetryTimeoutPolicyDeletion(req)
}

// Reconcile and finalize the RetryTimeoutPolicy Resource
// implemented by the user
type RetryTimeoutPolicyFinalizer interface {
	RetryTimeoutPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	RetryTimeoutPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeRetryTimeoutPolicy(obj *resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy) error
}

type RetryTimeoutPolicyReconcileLoop interface {
	RunRetryTimeoutPolicyReconciler(ctx context.Context, rec RetryTimeoutPolicyReconciler, predicates ...predicate.Predicate) error
}

type retryTimeoutPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewRetryTimeoutPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) RetryTimeoutPolicyReconcileLoop {
	return &retryTimeoutPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy{}, options),
	}
}

func (c *retryTimeoutPolicyReconcileLoop) RunRetryTimeoutPolicyReconciler(ctx context.Context, reconciler RetryTimeoutPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericRetryTimeoutPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(RetryTimeoutPolicyFinalizer); ok {
		reconcilerWrapper = genericRetryTimeoutPolicyFinalizer{
			genericRetryTimeoutPolicyReconciler: genericReconciler,
			finalizingReconciler:                finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericRetryTimeoutPolicyHandler implements a generic reconcile.Reconciler
type genericRetryTimeoutPolicyReconciler struct {
	reconciler RetryTimeoutPolicyReconciler
}

func (r genericRetryTimeoutPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: RetryTimeoutPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileRetryTimeoutPolicy(obj)
}

func (r genericRetryTimeoutPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(RetryTimeoutPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileRetryTimeoutPolicyDeletion(request)
	}
	return nil
}

// genericRetryTimeoutPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericRetryTimeoutPolicyFinalizer struct {
	genericRetryTimeoutPolicyReconciler
	finalizingReconciler RetryTimeoutPolicyFinalizer
}

func (r genericRetryTimeoutPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.RetryTimeoutPolicyFinalizerName()
}

func (r genericRetryTimeoutPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.RetryTimeoutPolicy)
	if !ok {
		return errors.Errorf("internal error: RetryTimeoutPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeRetryTimeoutPolicy(obj)
}

// Reconcile Upsert events for the ConnectionPolicy Resource.
// implemented by the user
type ConnectionPolicyReconciler interface {
	ReconcileConnectionPolicy(obj *resilience_policy_gloo_solo_io_v2.ConnectionPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the ConnectionPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type ConnectionPolicyDeletionReconciler interface {
	ReconcileConnectionPolicyDeletion(req reconcile.Request) error
}

type ConnectionPolicyReconcilerFuncs struct {
	OnReconcileConnectionPolicy         func(obj *resilience_policy_gloo_solo_io_v2.ConnectionPolicy) (reconcile.Result, error)
	OnReconcileConnectionPolicyDeletion func(req reconcile.Request) error
}

func (f *ConnectionPolicyReconcilerFuncs) ReconcileConnectionPolicy(obj *resilience_policy_gloo_solo_io_v2.ConnectionPolicy) (reconcile.Result, error) {
	if f.OnReconcileConnectionPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileConnectionPolicy(obj)
}

func (f *ConnectionPolicyReconcilerFuncs) ReconcileConnectionPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileConnectionPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileConnectionPolicyDeletion(req)
}

// Reconcile and finalize the ConnectionPolicy Resource
// implemented by the user
type ConnectionPolicyFinalizer interface {
	ConnectionPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	ConnectionPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeConnectionPolicy(obj *resilience_policy_gloo_solo_io_v2.ConnectionPolicy) error
}

type ConnectionPolicyReconcileLoop interface {
	RunConnectionPolicyReconciler(ctx context.Context, rec ConnectionPolicyReconciler, predicates ...predicate.Predicate) error
}

type connectionPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewConnectionPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) ConnectionPolicyReconcileLoop {
	return &connectionPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &resilience_policy_gloo_solo_io_v2.ConnectionPolicy{}, options),
	}
}

func (c *connectionPolicyReconcileLoop) RunConnectionPolicyReconciler(ctx context.Context, reconciler ConnectionPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericConnectionPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(ConnectionPolicyFinalizer); ok {
		reconcilerWrapper = genericConnectionPolicyFinalizer{
			genericConnectionPolicyReconciler: genericReconciler,
			finalizingReconciler:              finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericConnectionPolicyHandler implements a generic reconcile.Reconciler
type genericConnectionPolicyReconciler struct {
	reconciler ConnectionPolicyReconciler
}

func (r genericConnectionPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ConnectionPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileConnectionPolicy(obj)
}

func (r genericConnectionPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(ConnectionPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileConnectionPolicyDeletion(request)
	}
	return nil
}

// genericConnectionPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericConnectionPolicyFinalizer struct {
	genericConnectionPolicyReconciler
	finalizingReconciler ConnectionPolicyFinalizer
}

func (r genericConnectionPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.ConnectionPolicyFinalizerName()
}

func (r genericConnectionPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*resilience_policy_gloo_solo_io_v2.ConnectionPolicy)
	if !ok {
		return errors.Errorf("internal error: ConnectionPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeConnectionPolicy(obj)
}
