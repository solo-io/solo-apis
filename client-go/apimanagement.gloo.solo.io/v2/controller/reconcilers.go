// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./reconcilers.go -destination mocks/reconcilers.go

// Definitions for the Kubernetes Controllers
package controller

import (
	"context"

	apimanagement_gloo_solo_io_v2 "github.com/solo-io/solo-apis/client-go/apimanagement.gloo.solo.io/v2"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the GraphQLStitchedSchema Resource.
// implemented by the user
type GraphQLStitchedSchemaReconciler interface {
	ReconcileGraphQLStitchedSchema(obj *apimanagement_gloo_solo_io_v2.GraphQLStitchedSchema) (reconcile.Result, error)
}

// Reconcile deletion events for the GraphQLStitchedSchema Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type GraphQLStitchedSchemaDeletionReconciler interface {
	ReconcileGraphQLStitchedSchemaDeletion(req reconcile.Request) error
}

type GraphQLStitchedSchemaReconcilerFuncs struct {
	OnReconcileGraphQLStitchedSchema         func(obj *apimanagement_gloo_solo_io_v2.GraphQLStitchedSchema) (reconcile.Result, error)
	OnReconcileGraphQLStitchedSchemaDeletion func(req reconcile.Request) error
}

func (f *GraphQLStitchedSchemaReconcilerFuncs) ReconcileGraphQLStitchedSchema(obj *apimanagement_gloo_solo_io_v2.GraphQLStitchedSchema) (reconcile.Result, error) {
	if f.OnReconcileGraphQLStitchedSchema == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileGraphQLStitchedSchema(obj)
}

func (f *GraphQLStitchedSchemaReconcilerFuncs) ReconcileGraphQLStitchedSchemaDeletion(req reconcile.Request) error {
	if f.OnReconcileGraphQLStitchedSchemaDeletion == nil {
		return nil
	}
	return f.OnReconcileGraphQLStitchedSchemaDeletion(req)
}

// Reconcile and finalize the GraphQLStitchedSchema Resource
// implemented by the user
type GraphQLStitchedSchemaFinalizer interface {
	GraphQLStitchedSchemaReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	GraphQLStitchedSchemaFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeGraphQLStitchedSchema(obj *apimanagement_gloo_solo_io_v2.GraphQLStitchedSchema) error
}

type GraphQLStitchedSchemaReconcileLoop interface {
	RunGraphQLStitchedSchemaReconciler(ctx context.Context, rec GraphQLStitchedSchemaReconciler, predicates ...predicate.Predicate) error
}

type graphQLStitchedSchemaReconcileLoop struct {
	loop reconcile.Loop
}

func NewGraphQLStitchedSchemaReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) GraphQLStitchedSchemaReconcileLoop {
	return &graphQLStitchedSchemaReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &apimanagement_gloo_solo_io_v2.GraphQLStitchedSchema{}, options),
	}
}

func (c *graphQLStitchedSchemaReconcileLoop) RunGraphQLStitchedSchemaReconciler(ctx context.Context, reconciler GraphQLStitchedSchemaReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericGraphQLStitchedSchemaReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(GraphQLStitchedSchemaFinalizer); ok {
		reconcilerWrapper = genericGraphQLStitchedSchemaFinalizer{
			genericGraphQLStitchedSchemaReconciler: genericReconciler,
			finalizingReconciler:                   finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericGraphQLStitchedSchemaHandler implements a generic reconcile.Reconciler
type genericGraphQLStitchedSchemaReconciler struct {
	reconciler GraphQLStitchedSchemaReconciler
}

func (r genericGraphQLStitchedSchemaReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.GraphQLStitchedSchema)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: GraphQLStitchedSchema handler received event for %T", object)
	}
	return r.reconciler.ReconcileGraphQLStitchedSchema(obj)
}

func (r genericGraphQLStitchedSchemaReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(GraphQLStitchedSchemaDeletionReconciler); ok {
		return deletionReconciler.ReconcileGraphQLStitchedSchemaDeletion(request)
	}
	return nil
}

// genericGraphQLStitchedSchemaFinalizer implements a generic reconcile.FinalizingReconciler
type genericGraphQLStitchedSchemaFinalizer struct {
	genericGraphQLStitchedSchemaReconciler
	finalizingReconciler GraphQLStitchedSchemaFinalizer
}

func (r genericGraphQLStitchedSchemaFinalizer) FinalizerName() string {
	return r.finalizingReconciler.GraphQLStitchedSchemaFinalizerName()
}

func (r genericGraphQLStitchedSchemaFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.GraphQLStitchedSchema)
	if !ok {
		return errors.Errorf("internal error: GraphQLStitchedSchema handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeGraphQLStitchedSchema(obj)
}

// Reconcile Upsert events for the GraphQLResolverMap Resource.
// implemented by the user
type GraphQLResolverMapReconciler interface {
	ReconcileGraphQLResolverMap(obj *apimanagement_gloo_solo_io_v2.GraphQLResolverMap) (reconcile.Result, error)
}

// Reconcile deletion events for the GraphQLResolverMap Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type GraphQLResolverMapDeletionReconciler interface {
	ReconcileGraphQLResolverMapDeletion(req reconcile.Request) error
}

type GraphQLResolverMapReconcilerFuncs struct {
	OnReconcileGraphQLResolverMap         func(obj *apimanagement_gloo_solo_io_v2.GraphQLResolverMap) (reconcile.Result, error)
	OnReconcileGraphQLResolverMapDeletion func(req reconcile.Request) error
}

func (f *GraphQLResolverMapReconcilerFuncs) ReconcileGraphQLResolverMap(obj *apimanagement_gloo_solo_io_v2.GraphQLResolverMap) (reconcile.Result, error) {
	if f.OnReconcileGraphQLResolverMap == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileGraphQLResolverMap(obj)
}

func (f *GraphQLResolverMapReconcilerFuncs) ReconcileGraphQLResolverMapDeletion(req reconcile.Request) error {
	if f.OnReconcileGraphQLResolverMapDeletion == nil {
		return nil
	}
	return f.OnReconcileGraphQLResolverMapDeletion(req)
}

// Reconcile and finalize the GraphQLResolverMap Resource
// implemented by the user
type GraphQLResolverMapFinalizer interface {
	GraphQLResolverMapReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	GraphQLResolverMapFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeGraphQLResolverMap(obj *apimanagement_gloo_solo_io_v2.GraphQLResolverMap) error
}

type GraphQLResolverMapReconcileLoop interface {
	RunGraphQLResolverMapReconciler(ctx context.Context, rec GraphQLResolverMapReconciler, predicates ...predicate.Predicate) error
}

type graphQLResolverMapReconcileLoop struct {
	loop reconcile.Loop
}

func NewGraphQLResolverMapReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) GraphQLResolverMapReconcileLoop {
	return &graphQLResolverMapReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &apimanagement_gloo_solo_io_v2.GraphQLResolverMap{}, options),
	}
}

func (c *graphQLResolverMapReconcileLoop) RunGraphQLResolverMapReconciler(ctx context.Context, reconciler GraphQLResolverMapReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericGraphQLResolverMapReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(GraphQLResolverMapFinalizer); ok {
		reconcilerWrapper = genericGraphQLResolverMapFinalizer{
			genericGraphQLResolverMapReconciler: genericReconciler,
			finalizingReconciler:                finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericGraphQLResolverMapHandler implements a generic reconcile.Reconciler
type genericGraphQLResolverMapReconciler struct {
	reconciler GraphQLResolverMapReconciler
}

func (r genericGraphQLResolverMapReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.GraphQLResolverMap)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: GraphQLResolverMap handler received event for %T", object)
	}
	return r.reconciler.ReconcileGraphQLResolverMap(obj)
}

func (r genericGraphQLResolverMapReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(GraphQLResolverMapDeletionReconciler); ok {
		return deletionReconciler.ReconcileGraphQLResolverMapDeletion(request)
	}
	return nil
}

// genericGraphQLResolverMapFinalizer implements a generic reconcile.FinalizingReconciler
type genericGraphQLResolverMapFinalizer struct {
	genericGraphQLResolverMapReconciler
	finalizingReconciler GraphQLResolverMapFinalizer
}

func (r genericGraphQLResolverMapFinalizer) FinalizerName() string {
	return r.finalizingReconciler.GraphQLResolverMapFinalizerName()
}

func (r genericGraphQLResolverMapFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.GraphQLResolverMap)
	if !ok {
		return errors.Errorf("internal error: GraphQLResolverMap handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeGraphQLResolverMap(obj)
}

// Reconcile Upsert events for the GraphQLSchema Resource.
// implemented by the user
type GraphQLSchemaReconciler interface {
	ReconcileGraphQLSchema(obj *apimanagement_gloo_solo_io_v2.GraphQLSchema) (reconcile.Result, error)
}

// Reconcile deletion events for the GraphQLSchema Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type GraphQLSchemaDeletionReconciler interface {
	ReconcileGraphQLSchemaDeletion(req reconcile.Request) error
}

type GraphQLSchemaReconcilerFuncs struct {
	OnReconcileGraphQLSchema         func(obj *apimanagement_gloo_solo_io_v2.GraphQLSchema) (reconcile.Result, error)
	OnReconcileGraphQLSchemaDeletion func(req reconcile.Request) error
}

func (f *GraphQLSchemaReconcilerFuncs) ReconcileGraphQLSchema(obj *apimanagement_gloo_solo_io_v2.GraphQLSchema) (reconcile.Result, error) {
	if f.OnReconcileGraphQLSchema == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileGraphQLSchema(obj)
}

func (f *GraphQLSchemaReconcilerFuncs) ReconcileGraphQLSchemaDeletion(req reconcile.Request) error {
	if f.OnReconcileGraphQLSchemaDeletion == nil {
		return nil
	}
	return f.OnReconcileGraphQLSchemaDeletion(req)
}

// Reconcile and finalize the GraphQLSchema Resource
// implemented by the user
type GraphQLSchemaFinalizer interface {
	GraphQLSchemaReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	GraphQLSchemaFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeGraphQLSchema(obj *apimanagement_gloo_solo_io_v2.GraphQLSchema) error
}

type GraphQLSchemaReconcileLoop interface {
	RunGraphQLSchemaReconciler(ctx context.Context, rec GraphQLSchemaReconciler, predicates ...predicate.Predicate) error
}

type graphQLSchemaReconcileLoop struct {
	loop reconcile.Loop
}

func NewGraphQLSchemaReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) GraphQLSchemaReconcileLoop {
	return &graphQLSchemaReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &apimanagement_gloo_solo_io_v2.GraphQLSchema{}, options),
	}
}

func (c *graphQLSchemaReconcileLoop) RunGraphQLSchemaReconciler(ctx context.Context, reconciler GraphQLSchemaReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericGraphQLSchemaReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(GraphQLSchemaFinalizer); ok {
		reconcilerWrapper = genericGraphQLSchemaFinalizer{
			genericGraphQLSchemaReconciler: genericReconciler,
			finalizingReconciler:           finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericGraphQLSchemaHandler implements a generic reconcile.Reconciler
type genericGraphQLSchemaReconciler struct {
	reconciler GraphQLSchemaReconciler
}

func (r genericGraphQLSchemaReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.GraphQLSchema)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: GraphQLSchema handler received event for %T", object)
	}
	return r.reconciler.ReconcileGraphQLSchema(obj)
}

func (r genericGraphQLSchemaReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(GraphQLSchemaDeletionReconciler); ok {
		return deletionReconciler.ReconcileGraphQLSchemaDeletion(request)
	}
	return nil
}

// genericGraphQLSchemaFinalizer implements a generic reconcile.FinalizingReconciler
type genericGraphQLSchemaFinalizer struct {
	genericGraphQLSchemaReconciler
	finalizingReconciler GraphQLSchemaFinalizer
}

func (r genericGraphQLSchemaFinalizer) FinalizerName() string {
	return r.finalizingReconciler.GraphQLSchemaFinalizerName()
}

func (r genericGraphQLSchemaFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.GraphQLSchema)
	if !ok {
		return errors.Errorf("internal error: GraphQLSchema handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeGraphQLSchema(obj)
}

// Reconcile Upsert events for the ApiDoc Resource.
// implemented by the user
type ApiDocReconciler interface {
	ReconcileApiDoc(obj *apimanagement_gloo_solo_io_v2.ApiDoc) (reconcile.Result, error)
}

// Reconcile deletion events for the ApiDoc Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type ApiDocDeletionReconciler interface {
	ReconcileApiDocDeletion(req reconcile.Request) error
}

type ApiDocReconcilerFuncs struct {
	OnReconcileApiDoc         func(obj *apimanagement_gloo_solo_io_v2.ApiDoc) (reconcile.Result, error)
	OnReconcileApiDocDeletion func(req reconcile.Request) error
}

func (f *ApiDocReconcilerFuncs) ReconcileApiDoc(obj *apimanagement_gloo_solo_io_v2.ApiDoc) (reconcile.Result, error) {
	if f.OnReconcileApiDoc == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileApiDoc(obj)
}

func (f *ApiDocReconcilerFuncs) ReconcileApiDocDeletion(req reconcile.Request) error {
	if f.OnReconcileApiDocDeletion == nil {
		return nil
	}
	return f.OnReconcileApiDocDeletion(req)
}

// Reconcile and finalize the ApiDoc Resource
// implemented by the user
type ApiDocFinalizer interface {
	ApiDocReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	ApiDocFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeApiDoc(obj *apimanagement_gloo_solo_io_v2.ApiDoc) error
}

type ApiDocReconcileLoop interface {
	RunApiDocReconciler(ctx context.Context, rec ApiDocReconciler, predicates ...predicate.Predicate) error
}

type apiDocReconcileLoop struct {
	loop reconcile.Loop
}

func NewApiDocReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) ApiDocReconcileLoop {
	return &apiDocReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &apimanagement_gloo_solo_io_v2.ApiDoc{}, options),
	}
}

func (c *apiDocReconcileLoop) RunApiDocReconciler(ctx context.Context, reconciler ApiDocReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericApiDocReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(ApiDocFinalizer); ok {
		reconcilerWrapper = genericApiDocFinalizer{
			genericApiDocReconciler: genericReconciler,
			finalizingReconciler:    finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericApiDocHandler implements a generic reconcile.Reconciler
type genericApiDocReconciler struct {
	reconciler ApiDocReconciler
}

func (r genericApiDocReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.ApiDoc)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ApiDoc handler received event for %T", object)
	}
	return r.reconciler.ReconcileApiDoc(obj)
}

func (r genericApiDocReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(ApiDocDeletionReconciler); ok {
		return deletionReconciler.ReconcileApiDocDeletion(request)
	}
	return nil
}

// genericApiDocFinalizer implements a generic reconcile.FinalizingReconciler
type genericApiDocFinalizer struct {
	genericApiDocReconciler
	finalizingReconciler ApiDocFinalizer
}

func (r genericApiDocFinalizer) FinalizerName() string {
	return r.finalizingReconciler.ApiDocFinalizerName()
}

func (r genericApiDocFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*apimanagement_gloo_solo_io_v2.ApiDoc)
	if !ok {
		return errors.Errorf("internal error: ApiDoc handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeApiDoc(obj)
}
