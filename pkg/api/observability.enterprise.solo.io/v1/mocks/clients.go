// Code generated by MockGen. DO NOT EDIT.
// Source: ./clients.go

// Package mock_v1 is a generated GoMock package.
package mock_v1

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	v1 "github.com/solo-io/solo-apis/pkg/api/observability.enterprise.solo.io/v1"
	client "sigs.k8s.io/controller-runtime/pkg/client"
)

// MockMulticlusterClientset is a mock of MulticlusterClientset interface.
type MockMulticlusterClientset struct {
	ctrl     *gomock.Controller
	recorder *MockMulticlusterClientsetMockRecorder
}

// MockMulticlusterClientsetMockRecorder is the mock recorder for MockMulticlusterClientset.
type MockMulticlusterClientsetMockRecorder struct {
	mock *MockMulticlusterClientset
}

// NewMockMulticlusterClientset creates a new mock instance.
func NewMockMulticlusterClientset(ctrl *gomock.Controller) *MockMulticlusterClientset {
	mock := &MockMulticlusterClientset{ctrl: ctrl}
	mock.recorder = &MockMulticlusterClientsetMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMulticlusterClientset) EXPECT() *MockMulticlusterClientsetMockRecorder {
	return m.recorder
}

// Cluster mocks base method.
func (m *MockMulticlusterClientset) Cluster(cluster string) (v1.Clientset, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cluster", cluster)
	ret0, _ := ret[0].(v1.Clientset)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Cluster indicates an expected call of Cluster.
func (mr *MockMulticlusterClientsetMockRecorder) Cluster(cluster interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cluster", reflect.TypeOf((*MockMulticlusterClientset)(nil).Cluster), cluster)
}

// MockClientset is a mock of Clientset interface.
type MockClientset struct {
	ctrl     *gomock.Controller
	recorder *MockClientsetMockRecorder
}

// MockClientsetMockRecorder is the mock recorder for MockClientset.
type MockClientsetMockRecorder struct {
	mock *MockClientset
}

// NewMockClientset creates a new mock instance.
func NewMockClientset(ctrl *gomock.Controller) *MockClientset {
	mock := &MockClientset{ctrl: ctrl}
	mock.recorder = &MockClientsetMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClientset) EXPECT() *MockClientsetMockRecorder {
	return m.recorder
}

// AccessLogRecords mocks base method.
func (m *MockClientset) AccessLogRecords() v1.AccessLogRecordClient {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AccessLogRecords")
	ret0, _ := ret[0].(v1.AccessLogRecordClient)
	return ret0
}

// AccessLogRecords indicates an expected call of AccessLogRecords.
func (mr *MockClientsetMockRecorder) AccessLogRecords() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AccessLogRecords", reflect.TypeOf((*MockClientset)(nil).AccessLogRecords))
}

// MockAccessLogRecordReader is a mock of AccessLogRecordReader interface.
type MockAccessLogRecordReader struct {
	ctrl     *gomock.Controller
	recorder *MockAccessLogRecordReaderMockRecorder
}

// MockAccessLogRecordReaderMockRecorder is the mock recorder for MockAccessLogRecordReader.
type MockAccessLogRecordReaderMockRecorder struct {
	mock *MockAccessLogRecordReader
}

// NewMockAccessLogRecordReader creates a new mock instance.
func NewMockAccessLogRecordReader(ctrl *gomock.Controller) *MockAccessLogRecordReader {
	mock := &MockAccessLogRecordReader{ctrl: ctrl}
	mock.recorder = &MockAccessLogRecordReaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAccessLogRecordReader) EXPECT() *MockAccessLogRecordReaderMockRecorder {
	return m.recorder
}

// GetAccessLogRecord mocks base method.
func (m *MockAccessLogRecordReader) GetAccessLogRecord(ctx context.Context, key client.ObjectKey) (*v1.AccessLogRecord, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccessLogRecord", ctx, key)
	ret0, _ := ret[0].(*v1.AccessLogRecord)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAccessLogRecord indicates an expected call of GetAccessLogRecord.
func (mr *MockAccessLogRecordReaderMockRecorder) GetAccessLogRecord(ctx, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordReader)(nil).GetAccessLogRecord), ctx, key)
}

// ListAccessLogRecord mocks base method.
func (m *MockAccessLogRecordReader) ListAccessLogRecord(ctx context.Context, opts ...client.ListOption) (*v1.AccessLogRecordList, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListAccessLogRecord", varargs...)
	ret0, _ := ret[0].(*v1.AccessLogRecordList)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAccessLogRecord indicates an expected call of ListAccessLogRecord.
func (mr *MockAccessLogRecordReaderMockRecorder) ListAccessLogRecord(ctx interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordReader)(nil).ListAccessLogRecord), varargs...)
}

// MockAccessLogRecordWriter is a mock of AccessLogRecordWriter interface.
type MockAccessLogRecordWriter struct {
	ctrl     *gomock.Controller
	recorder *MockAccessLogRecordWriterMockRecorder
}

// MockAccessLogRecordWriterMockRecorder is the mock recorder for MockAccessLogRecordWriter.
type MockAccessLogRecordWriterMockRecorder struct {
	mock *MockAccessLogRecordWriter
}

// NewMockAccessLogRecordWriter creates a new mock instance.
func NewMockAccessLogRecordWriter(ctrl *gomock.Controller) *MockAccessLogRecordWriter {
	mock := &MockAccessLogRecordWriter{ctrl: ctrl}
	mock.recorder = &MockAccessLogRecordWriterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAccessLogRecordWriter) EXPECT() *MockAccessLogRecordWriterMockRecorder {
	return m.recorder
}

// CreateAccessLogRecord mocks base method.
func (m *MockAccessLogRecordWriter) CreateAccessLogRecord(ctx context.Context, obj *v1.AccessLogRecord, opts ...client.CreateOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateAccessLogRecord", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateAccessLogRecord indicates an expected call of CreateAccessLogRecord.
func (mr *MockAccessLogRecordWriterMockRecorder) CreateAccessLogRecord(ctx, obj interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordWriter)(nil).CreateAccessLogRecord), varargs...)
}

// DeleteAccessLogRecord mocks base method.
func (m *MockAccessLogRecordWriter) DeleteAccessLogRecord(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteAccessLogRecord", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteAccessLogRecord indicates an expected call of DeleteAccessLogRecord.
func (mr *MockAccessLogRecordWriterMockRecorder) DeleteAccessLogRecord(ctx, key interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordWriter)(nil).DeleteAccessLogRecord), varargs...)
}

// DeleteAllOfAccessLogRecord mocks base method.
func (m *MockAccessLogRecordWriter) DeleteAllOfAccessLogRecord(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteAllOfAccessLogRecord", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteAllOfAccessLogRecord indicates an expected call of DeleteAllOfAccessLogRecord.
func (mr *MockAccessLogRecordWriterMockRecorder) DeleteAllOfAccessLogRecord(ctx interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAllOfAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordWriter)(nil).DeleteAllOfAccessLogRecord), varargs...)
}

// PatchAccessLogRecord mocks base method.
func (m *MockAccessLogRecordWriter) PatchAccessLogRecord(ctx context.Context, obj *v1.AccessLogRecord, patch client.Patch, opts ...client.PatchOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj, patch}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PatchAccessLogRecord", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// PatchAccessLogRecord indicates an expected call of PatchAccessLogRecord.
func (mr *MockAccessLogRecordWriterMockRecorder) PatchAccessLogRecord(ctx, obj, patch interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj, patch}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PatchAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordWriter)(nil).PatchAccessLogRecord), varargs...)
}

// UpdateAccessLogRecord mocks base method.
func (m *MockAccessLogRecordWriter) UpdateAccessLogRecord(ctx context.Context, obj *v1.AccessLogRecord, opts ...client.UpdateOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateAccessLogRecord", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateAccessLogRecord indicates an expected call of UpdateAccessLogRecord.
func (mr *MockAccessLogRecordWriterMockRecorder) UpdateAccessLogRecord(ctx, obj interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordWriter)(nil).UpdateAccessLogRecord), varargs...)
}

// UpsertAccessLogRecord mocks base method.
func (m *MockAccessLogRecordWriter) UpsertAccessLogRecord(ctx context.Context, obj *v1.AccessLogRecord, transitionFuncs ...v1.AccessLogRecordTransitionFunction) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range transitionFuncs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpsertAccessLogRecord", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertAccessLogRecord indicates an expected call of UpsertAccessLogRecord.
func (mr *MockAccessLogRecordWriterMockRecorder) UpsertAccessLogRecord(ctx, obj interface{}, transitionFuncs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, transitionFuncs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordWriter)(nil).UpsertAccessLogRecord), varargs...)
}

// MockAccessLogRecordStatusWriter is a mock of AccessLogRecordStatusWriter interface.
type MockAccessLogRecordStatusWriter struct {
	ctrl     *gomock.Controller
	recorder *MockAccessLogRecordStatusWriterMockRecorder
}

// MockAccessLogRecordStatusWriterMockRecorder is the mock recorder for MockAccessLogRecordStatusWriter.
type MockAccessLogRecordStatusWriterMockRecorder struct {
	mock *MockAccessLogRecordStatusWriter
}

// NewMockAccessLogRecordStatusWriter creates a new mock instance.
func NewMockAccessLogRecordStatusWriter(ctrl *gomock.Controller) *MockAccessLogRecordStatusWriter {
	mock := &MockAccessLogRecordStatusWriter{ctrl: ctrl}
	mock.recorder = &MockAccessLogRecordStatusWriterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAccessLogRecordStatusWriter) EXPECT() *MockAccessLogRecordStatusWriterMockRecorder {
	return m.recorder
}

// PatchAccessLogRecordStatus mocks base method.
func (m *MockAccessLogRecordStatusWriter) PatchAccessLogRecordStatus(ctx context.Context, obj *v1.AccessLogRecord, patch client.Patch, opts ...client.PatchOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj, patch}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PatchAccessLogRecordStatus", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// PatchAccessLogRecordStatus indicates an expected call of PatchAccessLogRecordStatus.
func (mr *MockAccessLogRecordStatusWriterMockRecorder) PatchAccessLogRecordStatus(ctx, obj, patch interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj, patch}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PatchAccessLogRecordStatus", reflect.TypeOf((*MockAccessLogRecordStatusWriter)(nil).PatchAccessLogRecordStatus), varargs...)
}

// UpdateAccessLogRecordStatus mocks base method.
func (m *MockAccessLogRecordStatusWriter) UpdateAccessLogRecordStatus(ctx context.Context, obj *v1.AccessLogRecord, opts ...client.UpdateOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateAccessLogRecordStatus", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateAccessLogRecordStatus indicates an expected call of UpdateAccessLogRecordStatus.
func (mr *MockAccessLogRecordStatusWriterMockRecorder) UpdateAccessLogRecordStatus(ctx, obj interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAccessLogRecordStatus", reflect.TypeOf((*MockAccessLogRecordStatusWriter)(nil).UpdateAccessLogRecordStatus), varargs...)
}

// MockAccessLogRecordClient is a mock of AccessLogRecordClient interface.
type MockAccessLogRecordClient struct {
	ctrl     *gomock.Controller
	recorder *MockAccessLogRecordClientMockRecorder
}

// MockAccessLogRecordClientMockRecorder is the mock recorder for MockAccessLogRecordClient.
type MockAccessLogRecordClientMockRecorder struct {
	mock *MockAccessLogRecordClient
}

// NewMockAccessLogRecordClient creates a new mock instance.
func NewMockAccessLogRecordClient(ctrl *gomock.Controller) *MockAccessLogRecordClient {
	mock := &MockAccessLogRecordClient{ctrl: ctrl}
	mock.recorder = &MockAccessLogRecordClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAccessLogRecordClient) EXPECT() *MockAccessLogRecordClientMockRecorder {
	return m.recorder
}

// CreateAccessLogRecord mocks base method.
func (m *MockAccessLogRecordClient) CreateAccessLogRecord(ctx context.Context, obj *v1.AccessLogRecord, opts ...client.CreateOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateAccessLogRecord", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateAccessLogRecord indicates an expected call of CreateAccessLogRecord.
func (mr *MockAccessLogRecordClientMockRecorder) CreateAccessLogRecord(ctx, obj interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordClient)(nil).CreateAccessLogRecord), varargs...)
}

// DeleteAccessLogRecord mocks base method.
func (m *MockAccessLogRecordClient) DeleteAccessLogRecord(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteAccessLogRecord", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteAccessLogRecord indicates an expected call of DeleteAccessLogRecord.
func (mr *MockAccessLogRecordClientMockRecorder) DeleteAccessLogRecord(ctx, key interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordClient)(nil).DeleteAccessLogRecord), varargs...)
}

// DeleteAllOfAccessLogRecord mocks base method.
func (m *MockAccessLogRecordClient) DeleteAllOfAccessLogRecord(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteAllOfAccessLogRecord", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteAllOfAccessLogRecord indicates an expected call of DeleteAllOfAccessLogRecord.
func (mr *MockAccessLogRecordClientMockRecorder) DeleteAllOfAccessLogRecord(ctx interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAllOfAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordClient)(nil).DeleteAllOfAccessLogRecord), varargs...)
}

// GetAccessLogRecord mocks base method.
func (m *MockAccessLogRecordClient) GetAccessLogRecord(ctx context.Context, key client.ObjectKey) (*v1.AccessLogRecord, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccessLogRecord", ctx, key)
	ret0, _ := ret[0].(*v1.AccessLogRecord)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAccessLogRecord indicates an expected call of GetAccessLogRecord.
func (mr *MockAccessLogRecordClientMockRecorder) GetAccessLogRecord(ctx, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordClient)(nil).GetAccessLogRecord), ctx, key)
}

// ListAccessLogRecord mocks base method.
func (m *MockAccessLogRecordClient) ListAccessLogRecord(ctx context.Context, opts ...client.ListOption) (*v1.AccessLogRecordList, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListAccessLogRecord", varargs...)
	ret0, _ := ret[0].(*v1.AccessLogRecordList)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAccessLogRecord indicates an expected call of ListAccessLogRecord.
func (mr *MockAccessLogRecordClientMockRecorder) ListAccessLogRecord(ctx interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordClient)(nil).ListAccessLogRecord), varargs...)
}

// PatchAccessLogRecord mocks base method.
func (m *MockAccessLogRecordClient) PatchAccessLogRecord(ctx context.Context, obj *v1.AccessLogRecord, patch client.Patch, opts ...client.PatchOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj, patch}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PatchAccessLogRecord", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// PatchAccessLogRecord indicates an expected call of PatchAccessLogRecord.
func (mr *MockAccessLogRecordClientMockRecorder) PatchAccessLogRecord(ctx, obj, patch interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj, patch}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PatchAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordClient)(nil).PatchAccessLogRecord), varargs...)
}

// PatchAccessLogRecordStatus mocks base method.
func (m *MockAccessLogRecordClient) PatchAccessLogRecordStatus(ctx context.Context, obj *v1.AccessLogRecord, patch client.Patch, opts ...client.PatchOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj, patch}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PatchAccessLogRecordStatus", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// PatchAccessLogRecordStatus indicates an expected call of PatchAccessLogRecordStatus.
func (mr *MockAccessLogRecordClientMockRecorder) PatchAccessLogRecordStatus(ctx, obj, patch interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj, patch}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PatchAccessLogRecordStatus", reflect.TypeOf((*MockAccessLogRecordClient)(nil).PatchAccessLogRecordStatus), varargs...)
}

// UpdateAccessLogRecord mocks base method.
func (m *MockAccessLogRecordClient) UpdateAccessLogRecord(ctx context.Context, obj *v1.AccessLogRecord, opts ...client.UpdateOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateAccessLogRecord", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateAccessLogRecord indicates an expected call of UpdateAccessLogRecord.
func (mr *MockAccessLogRecordClientMockRecorder) UpdateAccessLogRecord(ctx, obj interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordClient)(nil).UpdateAccessLogRecord), varargs...)
}

// UpdateAccessLogRecordStatus mocks base method.
func (m *MockAccessLogRecordClient) UpdateAccessLogRecordStatus(ctx context.Context, obj *v1.AccessLogRecord, opts ...client.UpdateOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateAccessLogRecordStatus", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateAccessLogRecordStatus indicates an expected call of UpdateAccessLogRecordStatus.
func (mr *MockAccessLogRecordClientMockRecorder) UpdateAccessLogRecordStatus(ctx, obj interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAccessLogRecordStatus", reflect.TypeOf((*MockAccessLogRecordClient)(nil).UpdateAccessLogRecordStatus), varargs...)
}

// UpsertAccessLogRecord mocks base method.
func (m *MockAccessLogRecordClient) UpsertAccessLogRecord(ctx context.Context, obj *v1.AccessLogRecord, transitionFuncs ...v1.AccessLogRecordTransitionFunction) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range transitionFuncs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpsertAccessLogRecord", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertAccessLogRecord indicates an expected call of UpsertAccessLogRecord.
func (mr *MockAccessLogRecordClientMockRecorder) UpsertAccessLogRecord(ctx, obj interface{}, transitionFuncs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, transitionFuncs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertAccessLogRecord", reflect.TypeOf((*MockAccessLogRecordClient)(nil).UpsertAccessLogRecord), varargs...)
}

// MockMulticlusterAccessLogRecordClient is a mock of MulticlusterAccessLogRecordClient interface.
type MockMulticlusterAccessLogRecordClient struct {
	ctrl     *gomock.Controller
	recorder *MockMulticlusterAccessLogRecordClientMockRecorder
}

// MockMulticlusterAccessLogRecordClientMockRecorder is the mock recorder for MockMulticlusterAccessLogRecordClient.
type MockMulticlusterAccessLogRecordClientMockRecorder struct {
	mock *MockMulticlusterAccessLogRecordClient
}

// NewMockMulticlusterAccessLogRecordClient creates a new mock instance.
func NewMockMulticlusterAccessLogRecordClient(ctrl *gomock.Controller) *MockMulticlusterAccessLogRecordClient {
	mock := &MockMulticlusterAccessLogRecordClient{ctrl: ctrl}
	mock.recorder = &MockMulticlusterAccessLogRecordClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMulticlusterAccessLogRecordClient) EXPECT() *MockMulticlusterAccessLogRecordClientMockRecorder {
	return m.recorder
}

// Cluster mocks base method.
func (m *MockMulticlusterAccessLogRecordClient) Cluster(cluster string) (v1.AccessLogRecordClient, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cluster", cluster)
	ret0, _ := ret[0].(v1.AccessLogRecordClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Cluster indicates an expected call of Cluster.
func (mr *MockMulticlusterAccessLogRecordClientMockRecorder) Cluster(cluster interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cluster", reflect.TypeOf((*MockMulticlusterAccessLogRecordClient)(nil).Cluster), cluster)
}
