// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./clients.go -destination mocks/clients.go

package v2

import (
	"context"

	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// MulticlusterClientset for the trafficcontrol.policy.gloo.solo.io/v2 APIs
type MulticlusterClientset interface {
	// Cluster returns a Clientset for the given cluster
	Cluster(cluster string) (Clientset, error)
}

type multiclusterClientset struct {
	client multicluster.Client
}

func NewMulticlusterClientset(client multicluster.Client) MulticlusterClientset {
	return &multiclusterClientset{client: client}
}

func (m *multiclusterClientset) Cluster(cluster string) (Clientset, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

// clienset for the trafficcontrol.policy.gloo.solo.io/v2 APIs
type Clientset interface {
	// clienset for the trafficcontrol.policy.gloo.solo.io/v2/v2 APIs
	MirrorPolicies() MirrorPolicyClient
	// clienset for the trafficcontrol.policy.gloo.solo.io/v2/v2 APIs
	RateLimitPolicies() RateLimitPolicyClient
	// clienset for the trafficcontrol.policy.gloo.solo.io/v2/v2 APIs
	RateLimitClientConfigs() RateLimitClientConfigClient
	// clienset for the trafficcontrol.policy.gloo.solo.io/v2/v2 APIs
	HeaderManipulationPolicies() HeaderManipulationPolicyClient
	// clienset for the trafficcontrol.policy.gloo.solo.io/v2/v2 APIs
	TransformationPolicies() TransformationPolicyClient
	// clienset for the trafficcontrol.policy.gloo.solo.io/v2/v2 APIs
	ProxyProtocolPolicies() ProxyProtocolPolicyClient
}

type clientSet struct {
	client client.Client
}

func NewClientsetFromConfig(cfg *rest.Config) (Clientset, error) {
	scheme := scheme.Scheme
	if err := AddToScheme(scheme); err != nil {
		return nil, err
	}
	client, err := client.New(cfg, client.Options{
		Scheme: scheme,
	})
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

func NewClientset(client client.Client) Clientset {
	return &clientSet{client: client}
}

// clienset for the trafficcontrol.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) MirrorPolicies() MirrorPolicyClient {
	return NewMirrorPolicyClient(c.client)
}

// clienset for the trafficcontrol.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) RateLimitPolicies() RateLimitPolicyClient {
	return NewRateLimitPolicyClient(c.client)
}

// clienset for the trafficcontrol.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) RateLimitClientConfigs() RateLimitClientConfigClient {
	return NewRateLimitClientConfigClient(c.client)
}

// clienset for the trafficcontrol.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) HeaderManipulationPolicies() HeaderManipulationPolicyClient {
	return NewHeaderManipulationPolicyClient(c.client)
}

// clienset for the trafficcontrol.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) TransformationPolicies() TransformationPolicyClient {
	return NewTransformationPolicyClient(c.client)
}

// clienset for the trafficcontrol.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) ProxyProtocolPolicies() ProxyProtocolPolicyClient {
	return NewProxyProtocolPolicyClient(c.client)
}

// Reader knows how to read and list MirrorPolicys.
type MirrorPolicyReader interface {
	// Get retrieves a MirrorPolicy for the given object key
	GetMirrorPolicy(ctx context.Context, key client.ObjectKey) (*MirrorPolicy, error)

	// List retrieves list of MirrorPolicys for a given namespace and list options.
	ListMirrorPolicy(ctx context.Context, opts ...client.ListOption) (*MirrorPolicyList, error)
}

// MirrorPolicyTransitionFunction instructs the MirrorPolicyWriter how to transition between an existing
// MirrorPolicy object and a desired on an Upsert
type MirrorPolicyTransitionFunction func(existing, desired *MirrorPolicy) error

// Writer knows how to create, delete, and update MirrorPolicys.
type MirrorPolicyWriter interface {
	// Create saves the MirrorPolicy object.
	CreateMirrorPolicy(ctx context.Context, obj *MirrorPolicy, opts ...client.CreateOption) error

	// Delete deletes the MirrorPolicy object.
	DeleteMirrorPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given MirrorPolicy object.
	UpdateMirrorPolicy(ctx context.Context, obj *MirrorPolicy, opts ...client.UpdateOption) error

	// Patch patches the given MirrorPolicy object.
	PatchMirrorPolicy(ctx context.Context, obj *MirrorPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all MirrorPolicy objects matching the given options.
	DeleteAllOfMirrorPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the MirrorPolicy object.
	UpsertMirrorPolicy(ctx context.Context, obj *MirrorPolicy, transitionFuncs ...MirrorPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a MirrorPolicy object.
type MirrorPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given MirrorPolicy object.
	UpdateMirrorPolicyStatus(ctx context.Context, obj *MirrorPolicy, opts ...client.UpdateOption) error

	// Patch patches the given MirrorPolicy object's subresource.
	PatchMirrorPolicyStatus(ctx context.Context, obj *MirrorPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on MirrorPolicys.
type MirrorPolicyClient interface {
	MirrorPolicyReader
	MirrorPolicyWriter
	MirrorPolicyStatusWriter
}

type mirrorPolicyClient struct {
	client client.Client
}

func NewMirrorPolicyClient(client client.Client) *mirrorPolicyClient {
	return &mirrorPolicyClient{client: client}
}

func (c *mirrorPolicyClient) GetMirrorPolicy(ctx context.Context, key client.ObjectKey) (*MirrorPolicy, error) {
	obj := &MirrorPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *mirrorPolicyClient) ListMirrorPolicy(ctx context.Context, opts ...client.ListOption) (*MirrorPolicyList, error) {
	list := &MirrorPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *mirrorPolicyClient) CreateMirrorPolicy(ctx context.Context, obj *MirrorPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *mirrorPolicyClient) DeleteMirrorPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &MirrorPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *mirrorPolicyClient) UpdateMirrorPolicy(ctx context.Context, obj *MirrorPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *mirrorPolicyClient) PatchMirrorPolicy(ctx context.Context, obj *MirrorPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *mirrorPolicyClient) DeleteAllOfMirrorPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &MirrorPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *mirrorPolicyClient) UpsertMirrorPolicy(ctx context.Context, obj *MirrorPolicy, transitionFuncs ...MirrorPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*MirrorPolicy), desired.(*MirrorPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *mirrorPolicyClient) UpdateMirrorPolicyStatus(ctx context.Context, obj *MirrorPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *mirrorPolicyClient) PatchMirrorPolicyStatus(ctx context.Context, obj *MirrorPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides MirrorPolicyClients for multiple clusters.
type MulticlusterMirrorPolicyClient interface {
	// Cluster returns a MirrorPolicyClient for the given cluster
	Cluster(cluster string) (MirrorPolicyClient, error)
}

type multiclusterMirrorPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterMirrorPolicyClient(client multicluster.Client) MulticlusterMirrorPolicyClient {
	return &multiclusterMirrorPolicyClient{client: client}
}

func (m *multiclusterMirrorPolicyClient) Cluster(cluster string) (MirrorPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewMirrorPolicyClient(client), nil
}

// Reader knows how to read and list RateLimitPolicys.
type RateLimitPolicyReader interface {
	// Get retrieves a RateLimitPolicy for the given object key
	GetRateLimitPolicy(ctx context.Context, key client.ObjectKey) (*RateLimitPolicy, error)

	// List retrieves list of RateLimitPolicys for a given namespace and list options.
	ListRateLimitPolicy(ctx context.Context, opts ...client.ListOption) (*RateLimitPolicyList, error)
}

// RateLimitPolicyTransitionFunction instructs the RateLimitPolicyWriter how to transition between an existing
// RateLimitPolicy object and a desired on an Upsert
type RateLimitPolicyTransitionFunction func(existing, desired *RateLimitPolicy) error

// Writer knows how to create, delete, and update RateLimitPolicys.
type RateLimitPolicyWriter interface {
	// Create saves the RateLimitPolicy object.
	CreateRateLimitPolicy(ctx context.Context, obj *RateLimitPolicy, opts ...client.CreateOption) error

	// Delete deletes the RateLimitPolicy object.
	DeleteRateLimitPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given RateLimitPolicy object.
	UpdateRateLimitPolicy(ctx context.Context, obj *RateLimitPolicy, opts ...client.UpdateOption) error

	// Patch patches the given RateLimitPolicy object.
	PatchRateLimitPolicy(ctx context.Context, obj *RateLimitPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all RateLimitPolicy objects matching the given options.
	DeleteAllOfRateLimitPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the RateLimitPolicy object.
	UpsertRateLimitPolicy(ctx context.Context, obj *RateLimitPolicy, transitionFuncs ...RateLimitPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a RateLimitPolicy object.
type RateLimitPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given RateLimitPolicy object.
	UpdateRateLimitPolicyStatus(ctx context.Context, obj *RateLimitPolicy, opts ...client.UpdateOption) error

	// Patch patches the given RateLimitPolicy object's subresource.
	PatchRateLimitPolicyStatus(ctx context.Context, obj *RateLimitPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on RateLimitPolicys.
type RateLimitPolicyClient interface {
	RateLimitPolicyReader
	RateLimitPolicyWriter
	RateLimitPolicyStatusWriter
}

type rateLimitPolicyClient struct {
	client client.Client
}

func NewRateLimitPolicyClient(client client.Client) *rateLimitPolicyClient {
	return &rateLimitPolicyClient{client: client}
}

func (c *rateLimitPolicyClient) GetRateLimitPolicy(ctx context.Context, key client.ObjectKey) (*RateLimitPolicy, error) {
	obj := &RateLimitPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *rateLimitPolicyClient) ListRateLimitPolicy(ctx context.Context, opts ...client.ListOption) (*RateLimitPolicyList, error) {
	list := &RateLimitPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *rateLimitPolicyClient) CreateRateLimitPolicy(ctx context.Context, obj *RateLimitPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *rateLimitPolicyClient) DeleteRateLimitPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &RateLimitPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *rateLimitPolicyClient) UpdateRateLimitPolicy(ctx context.Context, obj *RateLimitPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *rateLimitPolicyClient) PatchRateLimitPolicy(ctx context.Context, obj *RateLimitPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *rateLimitPolicyClient) DeleteAllOfRateLimitPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &RateLimitPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *rateLimitPolicyClient) UpsertRateLimitPolicy(ctx context.Context, obj *RateLimitPolicy, transitionFuncs ...RateLimitPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*RateLimitPolicy), desired.(*RateLimitPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *rateLimitPolicyClient) UpdateRateLimitPolicyStatus(ctx context.Context, obj *RateLimitPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *rateLimitPolicyClient) PatchRateLimitPolicyStatus(ctx context.Context, obj *RateLimitPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides RateLimitPolicyClients for multiple clusters.
type MulticlusterRateLimitPolicyClient interface {
	// Cluster returns a RateLimitPolicyClient for the given cluster
	Cluster(cluster string) (RateLimitPolicyClient, error)
}

type multiclusterRateLimitPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterRateLimitPolicyClient(client multicluster.Client) MulticlusterRateLimitPolicyClient {
	return &multiclusterRateLimitPolicyClient{client: client}
}

func (m *multiclusterRateLimitPolicyClient) Cluster(cluster string) (RateLimitPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewRateLimitPolicyClient(client), nil
}

// Reader knows how to read and list RateLimitClientConfigs.
type RateLimitClientConfigReader interface {
	// Get retrieves a RateLimitClientConfig for the given object key
	GetRateLimitClientConfig(ctx context.Context, key client.ObjectKey) (*RateLimitClientConfig, error)

	// List retrieves list of RateLimitClientConfigs for a given namespace and list options.
	ListRateLimitClientConfig(ctx context.Context, opts ...client.ListOption) (*RateLimitClientConfigList, error)
}

// RateLimitClientConfigTransitionFunction instructs the RateLimitClientConfigWriter how to transition between an existing
// RateLimitClientConfig object and a desired on an Upsert
type RateLimitClientConfigTransitionFunction func(existing, desired *RateLimitClientConfig) error

// Writer knows how to create, delete, and update RateLimitClientConfigs.
type RateLimitClientConfigWriter interface {
	// Create saves the RateLimitClientConfig object.
	CreateRateLimitClientConfig(ctx context.Context, obj *RateLimitClientConfig, opts ...client.CreateOption) error

	// Delete deletes the RateLimitClientConfig object.
	DeleteRateLimitClientConfig(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given RateLimitClientConfig object.
	UpdateRateLimitClientConfig(ctx context.Context, obj *RateLimitClientConfig, opts ...client.UpdateOption) error

	// Patch patches the given RateLimitClientConfig object.
	PatchRateLimitClientConfig(ctx context.Context, obj *RateLimitClientConfig, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all RateLimitClientConfig objects matching the given options.
	DeleteAllOfRateLimitClientConfig(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the RateLimitClientConfig object.
	UpsertRateLimitClientConfig(ctx context.Context, obj *RateLimitClientConfig, transitionFuncs ...RateLimitClientConfigTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a RateLimitClientConfig object.
type RateLimitClientConfigStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given RateLimitClientConfig object.
	UpdateRateLimitClientConfigStatus(ctx context.Context, obj *RateLimitClientConfig, opts ...client.UpdateOption) error

	// Patch patches the given RateLimitClientConfig object's subresource.
	PatchRateLimitClientConfigStatus(ctx context.Context, obj *RateLimitClientConfig, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on RateLimitClientConfigs.
type RateLimitClientConfigClient interface {
	RateLimitClientConfigReader
	RateLimitClientConfigWriter
	RateLimitClientConfigStatusWriter
}

type rateLimitClientConfigClient struct {
	client client.Client
}

func NewRateLimitClientConfigClient(client client.Client) *rateLimitClientConfigClient {
	return &rateLimitClientConfigClient{client: client}
}

func (c *rateLimitClientConfigClient) GetRateLimitClientConfig(ctx context.Context, key client.ObjectKey) (*RateLimitClientConfig, error) {
	obj := &RateLimitClientConfig{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *rateLimitClientConfigClient) ListRateLimitClientConfig(ctx context.Context, opts ...client.ListOption) (*RateLimitClientConfigList, error) {
	list := &RateLimitClientConfigList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *rateLimitClientConfigClient) CreateRateLimitClientConfig(ctx context.Context, obj *RateLimitClientConfig, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *rateLimitClientConfigClient) DeleteRateLimitClientConfig(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &RateLimitClientConfig{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *rateLimitClientConfigClient) UpdateRateLimitClientConfig(ctx context.Context, obj *RateLimitClientConfig, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *rateLimitClientConfigClient) PatchRateLimitClientConfig(ctx context.Context, obj *RateLimitClientConfig, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *rateLimitClientConfigClient) DeleteAllOfRateLimitClientConfig(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &RateLimitClientConfig{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *rateLimitClientConfigClient) UpsertRateLimitClientConfig(ctx context.Context, obj *RateLimitClientConfig, transitionFuncs ...RateLimitClientConfigTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*RateLimitClientConfig), desired.(*RateLimitClientConfig)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *rateLimitClientConfigClient) UpdateRateLimitClientConfigStatus(ctx context.Context, obj *RateLimitClientConfig, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *rateLimitClientConfigClient) PatchRateLimitClientConfigStatus(ctx context.Context, obj *RateLimitClientConfig, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides RateLimitClientConfigClients for multiple clusters.
type MulticlusterRateLimitClientConfigClient interface {
	// Cluster returns a RateLimitClientConfigClient for the given cluster
	Cluster(cluster string) (RateLimitClientConfigClient, error)
}

type multiclusterRateLimitClientConfigClient struct {
	client multicluster.Client
}

func NewMulticlusterRateLimitClientConfigClient(client multicluster.Client) MulticlusterRateLimitClientConfigClient {
	return &multiclusterRateLimitClientConfigClient{client: client}
}

func (m *multiclusterRateLimitClientConfigClient) Cluster(cluster string) (RateLimitClientConfigClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewRateLimitClientConfigClient(client), nil
}

// Reader knows how to read and list HeaderManipulationPolicys.
type HeaderManipulationPolicyReader interface {
	// Get retrieves a HeaderManipulationPolicy for the given object key
	GetHeaderManipulationPolicy(ctx context.Context, key client.ObjectKey) (*HeaderManipulationPolicy, error)

	// List retrieves list of HeaderManipulationPolicys for a given namespace and list options.
	ListHeaderManipulationPolicy(ctx context.Context, opts ...client.ListOption) (*HeaderManipulationPolicyList, error)
}

// HeaderManipulationPolicyTransitionFunction instructs the HeaderManipulationPolicyWriter how to transition between an existing
// HeaderManipulationPolicy object and a desired on an Upsert
type HeaderManipulationPolicyTransitionFunction func(existing, desired *HeaderManipulationPolicy) error

// Writer knows how to create, delete, and update HeaderManipulationPolicys.
type HeaderManipulationPolicyWriter interface {
	// Create saves the HeaderManipulationPolicy object.
	CreateHeaderManipulationPolicy(ctx context.Context, obj *HeaderManipulationPolicy, opts ...client.CreateOption) error

	// Delete deletes the HeaderManipulationPolicy object.
	DeleteHeaderManipulationPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given HeaderManipulationPolicy object.
	UpdateHeaderManipulationPolicy(ctx context.Context, obj *HeaderManipulationPolicy, opts ...client.UpdateOption) error

	// Patch patches the given HeaderManipulationPolicy object.
	PatchHeaderManipulationPolicy(ctx context.Context, obj *HeaderManipulationPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all HeaderManipulationPolicy objects matching the given options.
	DeleteAllOfHeaderManipulationPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the HeaderManipulationPolicy object.
	UpsertHeaderManipulationPolicy(ctx context.Context, obj *HeaderManipulationPolicy, transitionFuncs ...HeaderManipulationPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a HeaderManipulationPolicy object.
type HeaderManipulationPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given HeaderManipulationPolicy object.
	UpdateHeaderManipulationPolicyStatus(ctx context.Context, obj *HeaderManipulationPolicy, opts ...client.UpdateOption) error

	// Patch patches the given HeaderManipulationPolicy object's subresource.
	PatchHeaderManipulationPolicyStatus(ctx context.Context, obj *HeaderManipulationPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on HeaderManipulationPolicys.
type HeaderManipulationPolicyClient interface {
	HeaderManipulationPolicyReader
	HeaderManipulationPolicyWriter
	HeaderManipulationPolicyStatusWriter
}

type headerManipulationPolicyClient struct {
	client client.Client
}

func NewHeaderManipulationPolicyClient(client client.Client) *headerManipulationPolicyClient {
	return &headerManipulationPolicyClient{client: client}
}

func (c *headerManipulationPolicyClient) GetHeaderManipulationPolicy(ctx context.Context, key client.ObjectKey) (*HeaderManipulationPolicy, error) {
	obj := &HeaderManipulationPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *headerManipulationPolicyClient) ListHeaderManipulationPolicy(ctx context.Context, opts ...client.ListOption) (*HeaderManipulationPolicyList, error) {
	list := &HeaderManipulationPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *headerManipulationPolicyClient) CreateHeaderManipulationPolicy(ctx context.Context, obj *HeaderManipulationPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *headerManipulationPolicyClient) DeleteHeaderManipulationPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &HeaderManipulationPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *headerManipulationPolicyClient) UpdateHeaderManipulationPolicy(ctx context.Context, obj *HeaderManipulationPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *headerManipulationPolicyClient) PatchHeaderManipulationPolicy(ctx context.Context, obj *HeaderManipulationPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *headerManipulationPolicyClient) DeleteAllOfHeaderManipulationPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &HeaderManipulationPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *headerManipulationPolicyClient) UpsertHeaderManipulationPolicy(ctx context.Context, obj *HeaderManipulationPolicy, transitionFuncs ...HeaderManipulationPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*HeaderManipulationPolicy), desired.(*HeaderManipulationPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *headerManipulationPolicyClient) UpdateHeaderManipulationPolicyStatus(ctx context.Context, obj *HeaderManipulationPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *headerManipulationPolicyClient) PatchHeaderManipulationPolicyStatus(ctx context.Context, obj *HeaderManipulationPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides HeaderManipulationPolicyClients for multiple clusters.
type MulticlusterHeaderManipulationPolicyClient interface {
	// Cluster returns a HeaderManipulationPolicyClient for the given cluster
	Cluster(cluster string) (HeaderManipulationPolicyClient, error)
}

type multiclusterHeaderManipulationPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterHeaderManipulationPolicyClient(client multicluster.Client) MulticlusterHeaderManipulationPolicyClient {
	return &multiclusterHeaderManipulationPolicyClient{client: client}
}

func (m *multiclusterHeaderManipulationPolicyClient) Cluster(cluster string) (HeaderManipulationPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewHeaderManipulationPolicyClient(client), nil
}

// Reader knows how to read and list TransformationPolicys.
type TransformationPolicyReader interface {
	// Get retrieves a TransformationPolicy for the given object key
	GetTransformationPolicy(ctx context.Context, key client.ObjectKey) (*TransformationPolicy, error)

	// List retrieves list of TransformationPolicys for a given namespace and list options.
	ListTransformationPolicy(ctx context.Context, opts ...client.ListOption) (*TransformationPolicyList, error)
}

// TransformationPolicyTransitionFunction instructs the TransformationPolicyWriter how to transition between an existing
// TransformationPolicy object and a desired on an Upsert
type TransformationPolicyTransitionFunction func(existing, desired *TransformationPolicy) error

// Writer knows how to create, delete, and update TransformationPolicys.
type TransformationPolicyWriter interface {
	// Create saves the TransformationPolicy object.
	CreateTransformationPolicy(ctx context.Context, obj *TransformationPolicy, opts ...client.CreateOption) error

	// Delete deletes the TransformationPolicy object.
	DeleteTransformationPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given TransformationPolicy object.
	UpdateTransformationPolicy(ctx context.Context, obj *TransformationPolicy, opts ...client.UpdateOption) error

	// Patch patches the given TransformationPolicy object.
	PatchTransformationPolicy(ctx context.Context, obj *TransformationPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all TransformationPolicy objects matching the given options.
	DeleteAllOfTransformationPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the TransformationPolicy object.
	UpsertTransformationPolicy(ctx context.Context, obj *TransformationPolicy, transitionFuncs ...TransformationPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a TransformationPolicy object.
type TransformationPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given TransformationPolicy object.
	UpdateTransformationPolicyStatus(ctx context.Context, obj *TransformationPolicy, opts ...client.UpdateOption) error

	// Patch patches the given TransformationPolicy object's subresource.
	PatchTransformationPolicyStatus(ctx context.Context, obj *TransformationPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on TransformationPolicys.
type TransformationPolicyClient interface {
	TransformationPolicyReader
	TransformationPolicyWriter
	TransformationPolicyStatusWriter
}

type transformationPolicyClient struct {
	client client.Client
}

func NewTransformationPolicyClient(client client.Client) *transformationPolicyClient {
	return &transformationPolicyClient{client: client}
}

func (c *transformationPolicyClient) GetTransformationPolicy(ctx context.Context, key client.ObjectKey) (*TransformationPolicy, error) {
	obj := &TransformationPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *transformationPolicyClient) ListTransformationPolicy(ctx context.Context, opts ...client.ListOption) (*TransformationPolicyList, error) {
	list := &TransformationPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *transformationPolicyClient) CreateTransformationPolicy(ctx context.Context, obj *TransformationPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *transformationPolicyClient) DeleteTransformationPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &TransformationPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *transformationPolicyClient) UpdateTransformationPolicy(ctx context.Context, obj *TransformationPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *transformationPolicyClient) PatchTransformationPolicy(ctx context.Context, obj *TransformationPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *transformationPolicyClient) DeleteAllOfTransformationPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &TransformationPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *transformationPolicyClient) UpsertTransformationPolicy(ctx context.Context, obj *TransformationPolicy, transitionFuncs ...TransformationPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*TransformationPolicy), desired.(*TransformationPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *transformationPolicyClient) UpdateTransformationPolicyStatus(ctx context.Context, obj *TransformationPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *transformationPolicyClient) PatchTransformationPolicyStatus(ctx context.Context, obj *TransformationPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides TransformationPolicyClients for multiple clusters.
type MulticlusterTransformationPolicyClient interface {
	// Cluster returns a TransformationPolicyClient for the given cluster
	Cluster(cluster string) (TransformationPolicyClient, error)
}

type multiclusterTransformationPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterTransformationPolicyClient(client multicluster.Client) MulticlusterTransformationPolicyClient {
	return &multiclusterTransformationPolicyClient{client: client}
}

func (m *multiclusterTransformationPolicyClient) Cluster(cluster string) (TransformationPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewTransformationPolicyClient(client), nil
}

// Reader knows how to read and list ProxyProtocolPolicys.
type ProxyProtocolPolicyReader interface {
	// Get retrieves a ProxyProtocolPolicy for the given object key
	GetProxyProtocolPolicy(ctx context.Context, key client.ObjectKey) (*ProxyProtocolPolicy, error)

	// List retrieves list of ProxyProtocolPolicys for a given namespace and list options.
	ListProxyProtocolPolicy(ctx context.Context, opts ...client.ListOption) (*ProxyProtocolPolicyList, error)
}

// ProxyProtocolPolicyTransitionFunction instructs the ProxyProtocolPolicyWriter how to transition between an existing
// ProxyProtocolPolicy object and a desired on an Upsert
type ProxyProtocolPolicyTransitionFunction func(existing, desired *ProxyProtocolPolicy) error

// Writer knows how to create, delete, and update ProxyProtocolPolicys.
type ProxyProtocolPolicyWriter interface {
	// Create saves the ProxyProtocolPolicy object.
	CreateProxyProtocolPolicy(ctx context.Context, obj *ProxyProtocolPolicy, opts ...client.CreateOption) error

	// Delete deletes the ProxyProtocolPolicy object.
	DeleteProxyProtocolPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given ProxyProtocolPolicy object.
	UpdateProxyProtocolPolicy(ctx context.Context, obj *ProxyProtocolPolicy, opts ...client.UpdateOption) error

	// Patch patches the given ProxyProtocolPolicy object.
	PatchProxyProtocolPolicy(ctx context.Context, obj *ProxyProtocolPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all ProxyProtocolPolicy objects matching the given options.
	DeleteAllOfProxyProtocolPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the ProxyProtocolPolicy object.
	UpsertProxyProtocolPolicy(ctx context.Context, obj *ProxyProtocolPolicy, transitionFuncs ...ProxyProtocolPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a ProxyProtocolPolicy object.
type ProxyProtocolPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given ProxyProtocolPolicy object.
	UpdateProxyProtocolPolicyStatus(ctx context.Context, obj *ProxyProtocolPolicy, opts ...client.UpdateOption) error

	// Patch patches the given ProxyProtocolPolicy object's subresource.
	PatchProxyProtocolPolicyStatus(ctx context.Context, obj *ProxyProtocolPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on ProxyProtocolPolicys.
type ProxyProtocolPolicyClient interface {
	ProxyProtocolPolicyReader
	ProxyProtocolPolicyWriter
	ProxyProtocolPolicyStatusWriter
}

type proxyProtocolPolicyClient struct {
	client client.Client
}

func NewProxyProtocolPolicyClient(client client.Client) *proxyProtocolPolicyClient {
	return &proxyProtocolPolicyClient{client: client}
}

func (c *proxyProtocolPolicyClient) GetProxyProtocolPolicy(ctx context.Context, key client.ObjectKey) (*ProxyProtocolPolicy, error) {
	obj := &ProxyProtocolPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *proxyProtocolPolicyClient) ListProxyProtocolPolicy(ctx context.Context, opts ...client.ListOption) (*ProxyProtocolPolicyList, error) {
	list := &ProxyProtocolPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *proxyProtocolPolicyClient) CreateProxyProtocolPolicy(ctx context.Context, obj *ProxyProtocolPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *proxyProtocolPolicyClient) DeleteProxyProtocolPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &ProxyProtocolPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *proxyProtocolPolicyClient) UpdateProxyProtocolPolicy(ctx context.Context, obj *ProxyProtocolPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *proxyProtocolPolicyClient) PatchProxyProtocolPolicy(ctx context.Context, obj *ProxyProtocolPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *proxyProtocolPolicyClient) DeleteAllOfProxyProtocolPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &ProxyProtocolPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *proxyProtocolPolicyClient) UpsertProxyProtocolPolicy(ctx context.Context, obj *ProxyProtocolPolicy, transitionFuncs ...ProxyProtocolPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*ProxyProtocolPolicy), desired.(*ProxyProtocolPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *proxyProtocolPolicyClient) UpdateProxyProtocolPolicyStatus(ctx context.Context, obj *ProxyProtocolPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *proxyProtocolPolicyClient) PatchProxyProtocolPolicyStatus(ctx context.Context, obj *ProxyProtocolPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides ProxyProtocolPolicyClients for multiple clusters.
type MulticlusterProxyProtocolPolicyClient interface {
	// Cluster returns a ProxyProtocolPolicyClient for the given cluster
	Cluster(cluster string) (ProxyProtocolPolicyClient, error)
}

type multiclusterProxyProtocolPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterProxyProtocolPolicyClient(client multicluster.Client) MulticlusterProxyProtocolPolicyClient {
	return &multiclusterProxyProtocolPolicyClient{client: client}
}

func (m *multiclusterProxyProtocolPolicyClient) Cluster(cluster string) (ProxyProtocolPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewProxyProtocolPolicyClient(client), nil
}
