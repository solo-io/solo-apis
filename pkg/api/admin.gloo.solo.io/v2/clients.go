// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./clients.go -destination mocks/clients.go

package v2

import (
	"context"

	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// MulticlusterClientset for the admin.gloo.solo.io/v2 APIs
type MulticlusterClientset interface {
	// Cluster returns a Clientset for the given cluster
	Cluster(cluster string) (Clientset, error)
}

type multiclusterClientset struct {
	client multicluster.Client
}

func NewMulticlusterClientset(client multicluster.Client) MulticlusterClientset {
	return &multiclusterClientset{client: client}
}

func (m *multiclusterClientset) Cluster(cluster string) (Clientset, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

// clienset for the admin.gloo.solo.io/v2 APIs
type Clientset interface {
	// clienset for the admin.gloo.solo.io/v2/v2 APIs
	Workspaces() WorkspaceClient
	// clienset for the admin.gloo.solo.io/v2/v2 APIs
	WorkspaceSettings() WorkspaceSettingsClient
	// clienset for the admin.gloo.solo.io/v2/v2 APIs
	KubernetesClusters() KubernetesClusterClient
	// clienset for the admin.gloo.solo.io/v2/v2 APIs
	RootTrustPolicies() RootTrustPolicyClient
	// clienset for the admin.gloo.solo.io/v2/v2 APIs
	ExtAuthServers() ExtAuthServerClient
	// clienset for the admin.gloo.solo.io/v2/v2 APIs
	RateLimitServerSettings() RateLimitServerSettingsClient
	// clienset for the admin.gloo.solo.io/v2/v2 APIs
	RateLimitServerConfigs() RateLimitServerConfigClient
	// clienset for the admin.gloo.solo.io/v2/v2 APIs
	Dashboards() DashboardClient
	// clienset for the admin.gloo.solo.io/v2/v2 APIs
	IstioLifecycleManagers() IstioLifecycleManagerClient
}

type clientSet struct {
	client client.Client
}

func NewClientsetFromConfig(cfg *rest.Config) (Clientset, error) {
	scheme := scheme.Scheme
	if err := SchemeBuilder.AddToScheme(scheme); err != nil {
		return nil, err
	}
	client, err := client.New(cfg, client.Options{
		Scheme: scheme,
	})
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

func NewClientset(client client.Client) Clientset {
	return &clientSet{client: client}
}

// clienset for the admin.gloo.solo.io/v2/v2 APIs
func (c *clientSet) Workspaces() WorkspaceClient {
	return NewWorkspaceClient(c.client)
}

// clienset for the admin.gloo.solo.io/v2/v2 APIs
func (c *clientSet) WorkspaceSettings() WorkspaceSettingsClient {
	return NewWorkspaceSettingsClient(c.client)
}

// clienset for the admin.gloo.solo.io/v2/v2 APIs
func (c *clientSet) KubernetesClusters() KubernetesClusterClient {
	return NewKubernetesClusterClient(c.client)
}

// clienset for the admin.gloo.solo.io/v2/v2 APIs
func (c *clientSet) RootTrustPolicies() RootTrustPolicyClient {
	return NewRootTrustPolicyClient(c.client)
}

// clienset for the admin.gloo.solo.io/v2/v2 APIs
func (c *clientSet) ExtAuthServers() ExtAuthServerClient {
	return NewExtAuthServerClient(c.client)
}

// clienset for the admin.gloo.solo.io/v2/v2 APIs
func (c *clientSet) RateLimitServerSettings() RateLimitServerSettingsClient {
	return NewRateLimitServerSettingsClient(c.client)
}

// clienset for the admin.gloo.solo.io/v2/v2 APIs
func (c *clientSet) RateLimitServerConfigs() RateLimitServerConfigClient {
	return NewRateLimitServerConfigClient(c.client)
}

// clienset for the admin.gloo.solo.io/v2/v2 APIs
func (c *clientSet) Dashboards() DashboardClient {
	return NewDashboardClient(c.client)
}

// clienset for the admin.gloo.solo.io/v2/v2 APIs
func (c *clientSet) IstioLifecycleManagers() IstioLifecycleManagerClient {
	return NewIstioLifecycleManagerClient(c.client)
}

// Reader knows how to read and list Workspaces.
type WorkspaceReader interface {
	// Get retrieves a Workspace for the given object key
	GetWorkspace(ctx context.Context, key client.ObjectKey) (*Workspace, error)

	// List retrieves list of Workspaces for a given namespace and list options.
	ListWorkspace(ctx context.Context, opts ...client.ListOption) (*WorkspaceList, error)
}

// WorkspaceTransitionFunction instructs the WorkspaceWriter how to transition between an existing
// Workspace object and a desired on an Upsert
type WorkspaceTransitionFunction func(existing, desired *Workspace) error

// Writer knows how to create, delete, and update Workspaces.
type WorkspaceWriter interface {
	// Create saves the Workspace object.
	CreateWorkspace(ctx context.Context, obj *Workspace, opts ...client.CreateOption) error

	// Delete deletes the Workspace object.
	DeleteWorkspace(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given Workspace object.
	UpdateWorkspace(ctx context.Context, obj *Workspace, opts ...client.UpdateOption) error

	// Patch patches the given Workspace object.
	PatchWorkspace(ctx context.Context, obj *Workspace, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all Workspace objects matching the given options.
	DeleteAllOfWorkspace(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the Workspace object.
	UpsertWorkspace(ctx context.Context, obj *Workspace, transitionFuncs ...WorkspaceTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a Workspace object.
type WorkspaceStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given Workspace object.
	UpdateWorkspaceStatus(ctx context.Context, obj *Workspace, opts ...client.UpdateOption) error

	// Patch patches the given Workspace object's subresource.
	PatchWorkspaceStatus(ctx context.Context, obj *Workspace, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on Workspaces.
type WorkspaceClient interface {
	WorkspaceReader
	WorkspaceWriter
	WorkspaceStatusWriter
}

type workspaceClient struct {
	client client.Client
}

func NewWorkspaceClient(client client.Client) *workspaceClient {
	return &workspaceClient{client: client}
}

func (c *workspaceClient) GetWorkspace(ctx context.Context, key client.ObjectKey) (*Workspace, error) {
	obj := &Workspace{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *workspaceClient) ListWorkspace(ctx context.Context, opts ...client.ListOption) (*WorkspaceList, error) {
	list := &WorkspaceList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *workspaceClient) CreateWorkspace(ctx context.Context, obj *Workspace, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *workspaceClient) DeleteWorkspace(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &Workspace{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *workspaceClient) UpdateWorkspace(ctx context.Context, obj *Workspace, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *workspaceClient) PatchWorkspace(ctx context.Context, obj *Workspace, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *workspaceClient) DeleteAllOfWorkspace(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &Workspace{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *workspaceClient) UpsertWorkspace(ctx context.Context, obj *Workspace, transitionFuncs ...WorkspaceTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*Workspace), desired.(*Workspace)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *workspaceClient) UpdateWorkspaceStatus(ctx context.Context, obj *Workspace, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *workspaceClient) PatchWorkspaceStatus(ctx context.Context, obj *Workspace, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides WorkspaceClients for multiple clusters.
type MulticlusterWorkspaceClient interface {
	// Cluster returns a WorkspaceClient for the given cluster
	Cluster(cluster string) (WorkspaceClient, error)
}

type multiclusterWorkspaceClient struct {
	client multicluster.Client
}

func NewMulticlusterWorkspaceClient(client multicluster.Client) MulticlusterWorkspaceClient {
	return &multiclusterWorkspaceClient{client: client}
}

func (m *multiclusterWorkspaceClient) Cluster(cluster string) (WorkspaceClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewWorkspaceClient(client), nil
}

// Reader knows how to read and list WorkspaceSettingss.
type WorkspaceSettingsReader interface {
	// Get retrieves a WorkspaceSettings for the given object key
	GetWorkspaceSettings(ctx context.Context, key client.ObjectKey) (*WorkspaceSettings, error)

	// List retrieves list of WorkspaceSettingss for a given namespace and list options.
	ListWorkspaceSettings(ctx context.Context, opts ...client.ListOption) (*WorkspaceSettingsList, error)
}

// WorkspaceSettingsTransitionFunction instructs the WorkspaceSettingsWriter how to transition between an existing
// WorkspaceSettings object and a desired on an Upsert
type WorkspaceSettingsTransitionFunction func(existing, desired *WorkspaceSettings) error

// Writer knows how to create, delete, and update WorkspaceSettingss.
type WorkspaceSettingsWriter interface {
	// Create saves the WorkspaceSettings object.
	CreateWorkspaceSettings(ctx context.Context, obj *WorkspaceSettings, opts ...client.CreateOption) error

	// Delete deletes the WorkspaceSettings object.
	DeleteWorkspaceSettings(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given WorkspaceSettings object.
	UpdateWorkspaceSettings(ctx context.Context, obj *WorkspaceSettings, opts ...client.UpdateOption) error

	// Patch patches the given WorkspaceSettings object.
	PatchWorkspaceSettings(ctx context.Context, obj *WorkspaceSettings, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all WorkspaceSettings objects matching the given options.
	DeleteAllOfWorkspaceSettings(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the WorkspaceSettings object.
	UpsertWorkspaceSettings(ctx context.Context, obj *WorkspaceSettings, transitionFuncs ...WorkspaceSettingsTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a WorkspaceSettings object.
type WorkspaceSettingsStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given WorkspaceSettings object.
	UpdateWorkspaceSettingsStatus(ctx context.Context, obj *WorkspaceSettings, opts ...client.UpdateOption) error

	// Patch patches the given WorkspaceSettings object's subresource.
	PatchWorkspaceSettingsStatus(ctx context.Context, obj *WorkspaceSettings, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on WorkspaceSettingss.
type WorkspaceSettingsClient interface {
	WorkspaceSettingsReader
	WorkspaceSettingsWriter
	WorkspaceSettingsStatusWriter
}

type workspaceSettingsClient struct {
	client client.Client
}

func NewWorkspaceSettingsClient(client client.Client) *workspaceSettingsClient {
	return &workspaceSettingsClient{client: client}
}

func (c *workspaceSettingsClient) GetWorkspaceSettings(ctx context.Context, key client.ObjectKey) (*WorkspaceSettings, error) {
	obj := &WorkspaceSettings{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *workspaceSettingsClient) ListWorkspaceSettings(ctx context.Context, opts ...client.ListOption) (*WorkspaceSettingsList, error) {
	list := &WorkspaceSettingsList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *workspaceSettingsClient) CreateWorkspaceSettings(ctx context.Context, obj *WorkspaceSettings, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *workspaceSettingsClient) DeleteWorkspaceSettings(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &WorkspaceSettings{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *workspaceSettingsClient) UpdateWorkspaceSettings(ctx context.Context, obj *WorkspaceSettings, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *workspaceSettingsClient) PatchWorkspaceSettings(ctx context.Context, obj *WorkspaceSettings, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *workspaceSettingsClient) DeleteAllOfWorkspaceSettings(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &WorkspaceSettings{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *workspaceSettingsClient) UpsertWorkspaceSettings(ctx context.Context, obj *WorkspaceSettings, transitionFuncs ...WorkspaceSettingsTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*WorkspaceSettings), desired.(*WorkspaceSettings)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *workspaceSettingsClient) UpdateWorkspaceSettingsStatus(ctx context.Context, obj *WorkspaceSettings, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *workspaceSettingsClient) PatchWorkspaceSettingsStatus(ctx context.Context, obj *WorkspaceSettings, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides WorkspaceSettingsClients for multiple clusters.
type MulticlusterWorkspaceSettingsClient interface {
	// Cluster returns a WorkspaceSettingsClient for the given cluster
	Cluster(cluster string) (WorkspaceSettingsClient, error)
}

type multiclusterWorkspaceSettingsClient struct {
	client multicluster.Client
}

func NewMulticlusterWorkspaceSettingsClient(client multicluster.Client) MulticlusterWorkspaceSettingsClient {
	return &multiclusterWorkspaceSettingsClient{client: client}
}

func (m *multiclusterWorkspaceSettingsClient) Cluster(cluster string) (WorkspaceSettingsClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewWorkspaceSettingsClient(client), nil
}

// Reader knows how to read and list KubernetesClusters.
type KubernetesClusterReader interface {
	// Get retrieves a KubernetesCluster for the given object key
	GetKubernetesCluster(ctx context.Context, key client.ObjectKey) (*KubernetesCluster, error)

	// List retrieves list of KubernetesClusters for a given namespace and list options.
	ListKubernetesCluster(ctx context.Context, opts ...client.ListOption) (*KubernetesClusterList, error)
}

// KubernetesClusterTransitionFunction instructs the KubernetesClusterWriter how to transition between an existing
// KubernetesCluster object and a desired on an Upsert
type KubernetesClusterTransitionFunction func(existing, desired *KubernetesCluster) error

// Writer knows how to create, delete, and update KubernetesClusters.
type KubernetesClusterWriter interface {
	// Create saves the KubernetesCluster object.
	CreateKubernetesCluster(ctx context.Context, obj *KubernetesCluster, opts ...client.CreateOption) error

	// Delete deletes the KubernetesCluster object.
	DeleteKubernetesCluster(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given KubernetesCluster object.
	UpdateKubernetesCluster(ctx context.Context, obj *KubernetesCluster, opts ...client.UpdateOption) error

	// Patch patches the given KubernetesCluster object.
	PatchKubernetesCluster(ctx context.Context, obj *KubernetesCluster, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all KubernetesCluster objects matching the given options.
	DeleteAllOfKubernetesCluster(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the KubernetesCluster object.
	UpsertKubernetesCluster(ctx context.Context, obj *KubernetesCluster, transitionFuncs ...KubernetesClusterTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a KubernetesCluster object.
type KubernetesClusterStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given KubernetesCluster object.
	UpdateKubernetesClusterStatus(ctx context.Context, obj *KubernetesCluster, opts ...client.UpdateOption) error

	// Patch patches the given KubernetesCluster object's subresource.
	PatchKubernetesClusterStatus(ctx context.Context, obj *KubernetesCluster, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on KubernetesClusters.
type KubernetesClusterClient interface {
	KubernetesClusterReader
	KubernetesClusterWriter
	KubernetesClusterStatusWriter
}

type kubernetesClusterClient struct {
	client client.Client
}

func NewKubernetesClusterClient(client client.Client) *kubernetesClusterClient {
	return &kubernetesClusterClient{client: client}
}

func (c *kubernetesClusterClient) GetKubernetesCluster(ctx context.Context, key client.ObjectKey) (*KubernetesCluster, error) {
	obj := &KubernetesCluster{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *kubernetesClusterClient) ListKubernetesCluster(ctx context.Context, opts ...client.ListOption) (*KubernetesClusterList, error) {
	list := &KubernetesClusterList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *kubernetesClusterClient) CreateKubernetesCluster(ctx context.Context, obj *KubernetesCluster, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *kubernetesClusterClient) DeleteKubernetesCluster(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &KubernetesCluster{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *kubernetesClusterClient) UpdateKubernetesCluster(ctx context.Context, obj *KubernetesCluster, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *kubernetesClusterClient) PatchKubernetesCluster(ctx context.Context, obj *KubernetesCluster, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *kubernetesClusterClient) DeleteAllOfKubernetesCluster(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &KubernetesCluster{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *kubernetesClusterClient) UpsertKubernetesCluster(ctx context.Context, obj *KubernetesCluster, transitionFuncs ...KubernetesClusterTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*KubernetesCluster), desired.(*KubernetesCluster)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *kubernetesClusterClient) UpdateKubernetesClusterStatus(ctx context.Context, obj *KubernetesCluster, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *kubernetesClusterClient) PatchKubernetesClusterStatus(ctx context.Context, obj *KubernetesCluster, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides KubernetesClusterClients for multiple clusters.
type MulticlusterKubernetesClusterClient interface {
	// Cluster returns a KubernetesClusterClient for the given cluster
	Cluster(cluster string) (KubernetesClusterClient, error)
}

type multiclusterKubernetesClusterClient struct {
	client multicluster.Client
}

func NewMulticlusterKubernetesClusterClient(client multicluster.Client) MulticlusterKubernetesClusterClient {
	return &multiclusterKubernetesClusterClient{client: client}
}

func (m *multiclusterKubernetesClusterClient) Cluster(cluster string) (KubernetesClusterClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewKubernetesClusterClient(client), nil
}

// Reader knows how to read and list RootTrustPolicys.
type RootTrustPolicyReader interface {
	// Get retrieves a RootTrustPolicy for the given object key
	GetRootTrustPolicy(ctx context.Context, key client.ObjectKey) (*RootTrustPolicy, error)

	// List retrieves list of RootTrustPolicys for a given namespace and list options.
	ListRootTrustPolicy(ctx context.Context, opts ...client.ListOption) (*RootTrustPolicyList, error)
}

// RootTrustPolicyTransitionFunction instructs the RootTrustPolicyWriter how to transition between an existing
// RootTrustPolicy object and a desired on an Upsert
type RootTrustPolicyTransitionFunction func(existing, desired *RootTrustPolicy) error

// Writer knows how to create, delete, and update RootTrustPolicys.
type RootTrustPolicyWriter interface {
	// Create saves the RootTrustPolicy object.
	CreateRootTrustPolicy(ctx context.Context, obj *RootTrustPolicy, opts ...client.CreateOption) error

	// Delete deletes the RootTrustPolicy object.
	DeleteRootTrustPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given RootTrustPolicy object.
	UpdateRootTrustPolicy(ctx context.Context, obj *RootTrustPolicy, opts ...client.UpdateOption) error

	// Patch patches the given RootTrustPolicy object.
	PatchRootTrustPolicy(ctx context.Context, obj *RootTrustPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all RootTrustPolicy objects matching the given options.
	DeleteAllOfRootTrustPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the RootTrustPolicy object.
	UpsertRootTrustPolicy(ctx context.Context, obj *RootTrustPolicy, transitionFuncs ...RootTrustPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a RootTrustPolicy object.
type RootTrustPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given RootTrustPolicy object.
	UpdateRootTrustPolicyStatus(ctx context.Context, obj *RootTrustPolicy, opts ...client.UpdateOption) error

	// Patch patches the given RootTrustPolicy object's subresource.
	PatchRootTrustPolicyStatus(ctx context.Context, obj *RootTrustPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on RootTrustPolicys.
type RootTrustPolicyClient interface {
	RootTrustPolicyReader
	RootTrustPolicyWriter
	RootTrustPolicyStatusWriter
}

type rootTrustPolicyClient struct {
	client client.Client
}

func NewRootTrustPolicyClient(client client.Client) *rootTrustPolicyClient {
	return &rootTrustPolicyClient{client: client}
}

func (c *rootTrustPolicyClient) GetRootTrustPolicy(ctx context.Context, key client.ObjectKey) (*RootTrustPolicy, error) {
	obj := &RootTrustPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *rootTrustPolicyClient) ListRootTrustPolicy(ctx context.Context, opts ...client.ListOption) (*RootTrustPolicyList, error) {
	list := &RootTrustPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *rootTrustPolicyClient) CreateRootTrustPolicy(ctx context.Context, obj *RootTrustPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *rootTrustPolicyClient) DeleteRootTrustPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &RootTrustPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *rootTrustPolicyClient) UpdateRootTrustPolicy(ctx context.Context, obj *RootTrustPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *rootTrustPolicyClient) PatchRootTrustPolicy(ctx context.Context, obj *RootTrustPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *rootTrustPolicyClient) DeleteAllOfRootTrustPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &RootTrustPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *rootTrustPolicyClient) UpsertRootTrustPolicy(ctx context.Context, obj *RootTrustPolicy, transitionFuncs ...RootTrustPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*RootTrustPolicy), desired.(*RootTrustPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *rootTrustPolicyClient) UpdateRootTrustPolicyStatus(ctx context.Context, obj *RootTrustPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *rootTrustPolicyClient) PatchRootTrustPolicyStatus(ctx context.Context, obj *RootTrustPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides RootTrustPolicyClients for multiple clusters.
type MulticlusterRootTrustPolicyClient interface {
	// Cluster returns a RootTrustPolicyClient for the given cluster
	Cluster(cluster string) (RootTrustPolicyClient, error)
}

type multiclusterRootTrustPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterRootTrustPolicyClient(client multicluster.Client) MulticlusterRootTrustPolicyClient {
	return &multiclusterRootTrustPolicyClient{client: client}
}

func (m *multiclusterRootTrustPolicyClient) Cluster(cluster string) (RootTrustPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewRootTrustPolicyClient(client), nil
}

// Reader knows how to read and list ExtAuthServers.
type ExtAuthServerReader interface {
	// Get retrieves a ExtAuthServer for the given object key
	GetExtAuthServer(ctx context.Context, key client.ObjectKey) (*ExtAuthServer, error)

	// List retrieves list of ExtAuthServers for a given namespace and list options.
	ListExtAuthServer(ctx context.Context, opts ...client.ListOption) (*ExtAuthServerList, error)
}

// ExtAuthServerTransitionFunction instructs the ExtAuthServerWriter how to transition between an existing
// ExtAuthServer object and a desired on an Upsert
type ExtAuthServerTransitionFunction func(existing, desired *ExtAuthServer) error

// Writer knows how to create, delete, and update ExtAuthServers.
type ExtAuthServerWriter interface {
	// Create saves the ExtAuthServer object.
	CreateExtAuthServer(ctx context.Context, obj *ExtAuthServer, opts ...client.CreateOption) error

	// Delete deletes the ExtAuthServer object.
	DeleteExtAuthServer(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given ExtAuthServer object.
	UpdateExtAuthServer(ctx context.Context, obj *ExtAuthServer, opts ...client.UpdateOption) error

	// Patch patches the given ExtAuthServer object.
	PatchExtAuthServer(ctx context.Context, obj *ExtAuthServer, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all ExtAuthServer objects matching the given options.
	DeleteAllOfExtAuthServer(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the ExtAuthServer object.
	UpsertExtAuthServer(ctx context.Context, obj *ExtAuthServer, transitionFuncs ...ExtAuthServerTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a ExtAuthServer object.
type ExtAuthServerStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given ExtAuthServer object.
	UpdateExtAuthServerStatus(ctx context.Context, obj *ExtAuthServer, opts ...client.UpdateOption) error

	// Patch patches the given ExtAuthServer object's subresource.
	PatchExtAuthServerStatus(ctx context.Context, obj *ExtAuthServer, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on ExtAuthServers.
type ExtAuthServerClient interface {
	ExtAuthServerReader
	ExtAuthServerWriter
	ExtAuthServerStatusWriter
}

type extAuthServerClient struct {
	client client.Client
}

func NewExtAuthServerClient(client client.Client) *extAuthServerClient {
	return &extAuthServerClient{client: client}
}

func (c *extAuthServerClient) GetExtAuthServer(ctx context.Context, key client.ObjectKey) (*ExtAuthServer, error) {
	obj := &ExtAuthServer{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *extAuthServerClient) ListExtAuthServer(ctx context.Context, opts ...client.ListOption) (*ExtAuthServerList, error) {
	list := &ExtAuthServerList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *extAuthServerClient) CreateExtAuthServer(ctx context.Context, obj *ExtAuthServer, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *extAuthServerClient) DeleteExtAuthServer(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &ExtAuthServer{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *extAuthServerClient) UpdateExtAuthServer(ctx context.Context, obj *ExtAuthServer, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *extAuthServerClient) PatchExtAuthServer(ctx context.Context, obj *ExtAuthServer, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *extAuthServerClient) DeleteAllOfExtAuthServer(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &ExtAuthServer{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *extAuthServerClient) UpsertExtAuthServer(ctx context.Context, obj *ExtAuthServer, transitionFuncs ...ExtAuthServerTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*ExtAuthServer), desired.(*ExtAuthServer)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *extAuthServerClient) UpdateExtAuthServerStatus(ctx context.Context, obj *ExtAuthServer, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *extAuthServerClient) PatchExtAuthServerStatus(ctx context.Context, obj *ExtAuthServer, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides ExtAuthServerClients for multiple clusters.
type MulticlusterExtAuthServerClient interface {
	// Cluster returns a ExtAuthServerClient for the given cluster
	Cluster(cluster string) (ExtAuthServerClient, error)
}

type multiclusterExtAuthServerClient struct {
	client multicluster.Client
}

func NewMulticlusterExtAuthServerClient(client multicluster.Client) MulticlusterExtAuthServerClient {
	return &multiclusterExtAuthServerClient{client: client}
}

func (m *multiclusterExtAuthServerClient) Cluster(cluster string) (ExtAuthServerClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewExtAuthServerClient(client), nil
}

// Reader knows how to read and list RateLimitServerSettingss.
type RateLimitServerSettingsReader interface {
	// Get retrieves a RateLimitServerSettings for the given object key
	GetRateLimitServerSettings(ctx context.Context, key client.ObjectKey) (*RateLimitServerSettings, error)

	// List retrieves list of RateLimitServerSettingss for a given namespace and list options.
	ListRateLimitServerSettings(ctx context.Context, opts ...client.ListOption) (*RateLimitServerSettingsList, error)
}

// RateLimitServerSettingsTransitionFunction instructs the RateLimitServerSettingsWriter how to transition between an existing
// RateLimitServerSettings object and a desired on an Upsert
type RateLimitServerSettingsTransitionFunction func(existing, desired *RateLimitServerSettings) error

// Writer knows how to create, delete, and update RateLimitServerSettingss.
type RateLimitServerSettingsWriter interface {
	// Create saves the RateLimitServerSettings object.
	CreateRateLimitServerSettings(ctx context.Context, obj *RateLimitServerSettings, opts ...client.CreateOption) error

	// Delete deletes the RateLimitServerSettings object.
	DeleteRateLimitServerSettings(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given RateLimitServerSettings object.
	UpdateRateLimitServerSettings(ctx context.Context, obj *RateLimitServerSettings, opts ...client.UpdateOption) error

	// Patch patches the given RateLimitServerSettings object.
	PatchRateLimitServerSettings(ctx context.Context, obj *RateLimitServerSettings, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all RateLimitServerSettings objects matching the given options.
	DeleteAllOfRateLimitServerSettings(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the RateLimitServerSettings object.
	UpsertRateLimitServerSettings(ctx context.Context, obj *RateLimitServerSettings, transitionFuncs ...RateLimitServerSettingsTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a RateLimitServerSettings object.
type RateLimitServerSettingsStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given RateLimitServerSettings object.
	UpdateRateLimitServerSettingsStatus(ctx context.Context, obj *RateLimitServerSettings, opts ...client.UpdateOption) error

	// Patch patches the given RateLimitServerSettings object's subresource.
	PatchRateLimitServerSettingsStatus(ctx context.Context, obj *RateLimitServerSettings, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on RateLimitServerSettingss.
type RateLimitServerSettingsClient interface {
	RateLimitServerSettingsReader
	RateLimitServerSettingsWriter
	RateLimitServerSettingsStatusWriter
}

type rateLimitServerSettingsClient struct {
	client client.Client
}

func NewRateLimitServerSettingsClient(client client.Client) *rateLimitServerSettingsClient {
	return &rateLimitServerSettingsClient{client: client}
}

func (c *rateLimitServerSettingsClient) GetRateLimitServerSettings(ctx context.Context, key client.ObjectKey) (*RateLimitServerSettings, error) {
	obj := &RateLimitServerSettings{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *rateLimitServerSettingsClient) ListRateLimitServerSettings(ctx context.Context, opts ...client.ListOption) (*RateLimitServerSettingsList, error) {
	list := &RateLimitServerSettingsList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *rateLimitServerSettingsClient) CreateRateLimitServerSettings(ctx context.Context, obj *RateLimitServerSettings, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *rateLimitServerSettingsClient) DeleteRateLimitServerSettings(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &RateLimitServerSettings{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *rateLimitServerSettingsClient) UpdateRateLimitServerSettings(ctx context.Context, obj *RateLimitServerSettings, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *rateLimitServerSettingsClient) PatchRateLimitServerSettings(ctx context.Context, obj *RateLimitServerSettings, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *rateLimitServerSettingsClient) DeleteAllOfRateLimitServerSettings(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &RateLimitServerSettings{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *rateLimitServerSettingsClient) UpsertRateLimitServerSettings(ctx context.Context, obj *RateLimitServerSettings, transitionFuncs ...RateLimitServerSettingsTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*RateLimitServerSettings), desired.(*RateLimitServerSettings)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *rateLimitServerSettingsClient) UpdateRateLimitServerSettingsStatus(ctx context.Context, obj *RateLimitServerSettings, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *rateLimitServerSettingsClient) PatchRateLimitServerSettingsStatus(ctx context.Context, obj *RateLimitServerSettings, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides RateLimitServerSettingsClients for multiple clusters.
type MulticlusterRateLimitServerSettingsClient interface {
	// Cluster returns a RateLimitServerSettingsClient for the given cluster
	Cluster(cluster string) (RateLimitServerSettingsClient, error)
}

type multiclusterRateLimitServerSettingsClient struct {
	client multicluster.Client
}

func NewMulticlusterRateLimitServerSettingsClient(client multicluster.Client) MulticlusterRateLimitServerSettingsClient {
	return &multiclusterRateLimitServerSettingsClient{client: client}
}

func (m *multiclusterRateLimitServerSettingsClient) Cluster(cluster string) (RateLimitServerSettingsClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewRateLimitServerSettingsClient(client), nil
}

// Reader knows how to read and list RateLimitServerConfigs.
type RateLimitServerConfigReader interface {
	// Get retrieves a RateLimitServerConfig for the given object key
	GetRateLimitServerConfig(ctx context.Context, key client.ObjectKey) (*RateLimitServerConfig, error)

	// List retrieves list of RateLimitServerConfigs for a given namespace and list options.
	ListRateLimitServerConfig(ctx context.Context, opts ...client.ListOption) (*RateLimitServerConfigList, error)
}

// RateLimitServerConfigTransitionFunction instructs the RateLimitServerConfigWriter how to transition between an existing
// RateLimitServerConfig object and a desired on an Upsert
type RateLimitServerConfigTransitionFunction func(existing, desired *RateLimitServerConfig) error

// Writer knows how to create, delete, and update RateLimitServerConfigs.
type RateLimitServerConfigWriter interface {
	// Create saves the RateLimitServerConfig object.
	CreateRateLimitServerConfig(ctx context.Context, obj *RateLimitServerConfig, opts ...client.CreateOption) error

	// Delete deletes the RateLimitServerConfig object.
	DeleteRateLimitServerConfig(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given RateLimitServerConfig object.
	UpdateRateLimitServerConfig(ctx context.Context, obj *RateLimitServerConfig, opts ...client.UpdateOption) error

	// Patch patches the given RateLimitServerConfig object.
	PatchRateLimitServerConfig(ctx context.Context, obj *RateLimitServerConfig, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all RateLimitServerConfig objects matching the given options.
	DeleteAllOfRateLimitServerConfig(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the RateLimitServerConfig object.
	UpsertRateLimitServerConfig(ctx context.Context, obj *RateLimitServerConfig, transitionFuncs ...RateLimitServerConfigTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a RateLimitServerConfig object.
type RateLimitServerConfigStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given RateLimitServerConfig object.
	UpdateRateLimitServerConfigStatus(ctx context.Context, obj *RateLimitServerConfig, opts ...client.UpdateOption) error

	// Patch patches the given RateLimitServerConfig object's subresource.
	PatchRateLimitServerConfigStatus(ctx context.Context, obj *RateLimitServerConfig, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on RateLimitServerConfigs.
type RateLimitServerConfigClient interface {
	RateLimitServerConfigReader
	RateLimitServerConfigWriter
	RateLimitServerConfigStatusWriter
}

type rateLimitServerConfigClient struct {
	client client.Client
}

func NewRateLimitServerConfigClient(client client.Client) *rateLimitServerConfigClient {
	return &rateLimitServerConfigClient{client: client}
}

func (c *rateLimitServerConfigClient) GetRateLimitServerConfig(ctx context.Context, key client.ObjectKey) (*RateLimitServerConfig, error) {
	obj := &RateLimitServerConfig{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *rateLimitServerConfigClient) ListRateLimitServerConfig(ctx context.Context, opts ...client.ListOption) (*RateLimitServerConfigList, error) {
	list := &RateLimitServerConfigList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *rateLimitServerConfigClient) CreateRateLimitServerConfig(ctx context.Context, obj *RateLimitServerConfig, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *rateLimitServerConfigClient) DeleteRateLimitServerConfig(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &RateLimitServerConfig{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *rateLimitServerConfigClient) UpdateRateLimitServerConfig(ctx context.Context, obj *RateLimitServerConfig, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *rateLimitServerConfigClient) PatchRateLimitServerConfig(ctx context.Context, obj *RateLimitServerConfig, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *rateLimitServerConfigClient) DeleteAllOfRateLimitServerConfig(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &RateLimitServerConfig{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *rateLimitServerConfigClient) UpsertRateLimitServerConfig(ctx context.Context, obj *RateLimitServerConfig, transitionFuncs ...RateLimitServerConfigTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*RateLimitServerConfig), desired.(*RateLimitServerConfig)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *rateLimitServerConfigClient) UpdateRateLimitServerConfigStatus(ctx context.Context, obj *RateLimitServerConfig, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *rateLimitServerConfigClient) PatchRateLimitServerConfigStatus(ctx context.Context, obj *RateLimitServerConfig, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides RateLimitServerConfigClients for multiple clusters.
type MulticlusterRateLimitServerConfigClient interface {
	// Cluster returns a RateLimitServerConfigClient for the given cluster
	Cluster(cluster string) (RateLimitServerConfigClient, error)
}

type multiclusterRateLimitServerConfigClient struct {
	client multicluster.Client
}

func NewMulticlusterRateLimitServerConfigClient(client multicluster.Client) MulticlusterRateLimitServerConfigClient {
	return &multiclusterRateLimitServerConfigClient{client: client}
}

func (m *multiclusterRateLimitServerConfigClient) Cluster(cluster string) (RateLimitServerConfigClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewRateLimitServerConfigClient(client), nil
}

// Reader knows how to read and list Dashboards.
type DashboardReader interface {
	// Get retrieves a Dashboard for the given object key
	GetDashboard(ctx context.Context, key client.ObjectKey) (*Dashboard, error)

	// List retrieves list of Dashboards for a given namespace and list options.
	ListDashboard(ctx context.Context, opts ...client.ListOption) (*DashboardList, error)
}

// DashboardTransitionFunction instructs the DashboardWriter how to transition between an existing
// Dashboard object and a desired on an Upsert
type DashboardTransitionFunction func(existing, desired *Dashboard) error

// Writer knows how to create, delete, and update Dashboards.
type DashboardWriter interface {
	// Create saves the Dashboard object.
	CreateDashboard(ctx context.Context, obj *Dashboard, opts ...client.CreateOption) error

	// Delete deletes the Dashboard object.
	DeleteDashboard(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given Dashboard object.
	UpdateDashboard(ctx context.Context, obj *Dashboard, opts ...client.UpdateOption) error

	// Patch patches the given Dashboard object.
	PatchDashboard(ctx context.Context, obj *Dashboard, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all Dashboard objects matching the given options.
	DeleteAllOfDashboard(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the Dashboard object.
	UpsertDashboard(ctx context.Context, obj *Dashboard, transitionFuncs ...DashboardTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a Dashboard object.
type DashboardStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given Dashboard object.
	UpdateDashboardStatus(ctx context.Context, obj *Dashboard, opts ...client.UpdateOption) error

	// Patch patches the given Dashboard object's subresource.
	PatchDashboardStatus(ctx context.Context, obj *Dashboard, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on Dashboards.
type DashboardClient interface {
	DashboardReader
	DashboardWriter
	DashboardStatusWriter
}

type dashboardClient struct {
	client client.Client
}

func NewDashboardClient(client client.Client) *dashboardClient {
	return &dashboardClient{client: client}
}

func (c *dashboardClient) GetDashboard(ctx context.Context, key client.ObjectKey) (*Dashboard, error) {
	obj := &Dashboard{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *dashboardClient) ListDashboard(ctx context.Context, opts ...client.ListOption) (*DashboardList, error) {
	list := &DashboardList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *dashboardClient) CreateDashboard(ctx context.Context, obj *Dashboard, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *dashboardClient) DeleteDashboard(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &Dashboard{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *dashboardClient) UpdateDashboard(ctx context.Context, obj *Dashboard, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *dashboardClient) PatchDashboard(ctx context.Context, obj *Dashboard, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *dashboardClient) DeleteAllOfDashboard(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &Dashboard{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *dashboardClient) UpsertDashboard(ctx context.Context, obj *Dashboard, transitionFuncs ...DashboardTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*Dashboard), desired.(*Dashboard)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *dashboardClient) UpdateDashboardStatus(ctx context.Context, obj *Dashboard, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *dashboardClient) PatchDashboardStatus(ctx context.Context, obj *Dashboard, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides DashboardClients for multiple clusters.
type MulticlusterDashboardClient interface {
	// Cluster returns a DashboardClient for the given cluster
	Cluster(cluster string) (DashboardClient, error)
}

type multiclusterDashboardClient struct {
	client multicluster.Client
}

func NewMulticlusterDashboardClient(client multicluster.Client) MulticlusterDashboardClient {
	return &multiclusterDashboardClient{client: client}
}

func (m *multiclusterDashboardClient) Cluster(cluster string) (DashboardClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewDashboardClient(client), nil
}

// Reader knows how to read and list IstioLifecycleManagers.
type IstioLifecycleManagerReader interface {
	// Get retrieves a IstioLifecycleManager for the given object key
	GetIstioLifecycleManager(ctx context.Context, key client.ObjectKey) (*IstioLifecycleManager, error)

	// List retrieves list of IstioLifecycleManagers for a given namespace and list options.
	ListIstioLifecycleManager(ctx context.Context, opts ...client.ListOption) (*IstioLifecycleManagerList, error)
}

// IstioLifecycleManagerTransitionFunction instructs the IstioLifecycleManagerWriter how to transition between an existing
// IstioLifecycleManager object and a desired on an Upsert
type IstioLifecycleManagerTransitionFunction func(existing, desired *IstioLifecycleManager) error

// Writer knows how to create, delete, and update IstioLifecycleManagers.
type IstioLifecycleManagerWriter interface {
	// Create saves the IstioLifecycleManager object.
	CreateIstioLifecycleManager(ctx context.Context, obj *IstioLifecycleManager, opts ...client.CreateOption) error

	// Delete deletes the IstioLifecycleManager object.
	DeleteIstioLifecycleManager(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given IstioLifecycleManager object.
	UpdateIstioLifecycleManager(ctx context.Context, obj *IstioLifecycleManager, opts ...client.UpdateOption) error

	// Patch patches the given IstioLifecycleManager object.
	PatchIstioLifecycleManager(ctx context.Context, obj *IstioLifecycleManager, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all IstioLifecycleManager objects matching the given options.
	DeleteAllOfIstioLifecycleManager(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the IstioLifecycleManager object.
	UpsertIstioLifecycleManager(ctx context.Context, obj *IstioLifecycleManager, transitionFuncs ...IstioLifecycleManagerTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a IstioLifecycleManager object.
type IstioLifecycleManagerStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given IstioLifecycleManager object.
	UpdateIstioLifecycleManagerStatus(ctx context.Context, obj *IstioLifecycleManager, opts ...client.UpdateOption) error

	// Patch patches the given IstioLifecycleManager object's subresource.
	PatchIstioLifecycleManagerStatus(ctx context.Context, obj *IstioLifecycleManager, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on IstioLifecycleManagers.
type IstioLifecycleManagerClient interface {
	IstioLifecycleManagerReader
	IstioLifecycleManagerWriter
	IstioLifecycleManagerStatusWriter
}

type istioLifecycleManagerClient struct {
	client client.Client
}

func NewIstioLifecycleManagerClient(client client.Client) *istioLifecycleManagerClient {
	return &istioLifecycleManagerClient{client: client}
}

func (c *istioLifecycleManagerClient) GetIstioLifecycleManager(ctx context.Context, key client.ObjectKey) (*IstioLifecycleManager, error) {
	obj := &IstioLifecycleManager{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *istioLifecycleManagerClient) ListIstioLifecycleManager(ctx context.Context, opts ...client.ListOption) (*IstioLifecycleManagerList, error) {
	list := &IstioLifecycleManagerList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *istioLifecycleManagerClient) CreateIstioLifecycleManager(ctx context.Context, obj *IstioLifecycleManager, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *istioLifecycleManagerClient) DeleteIstioLifecycleManager(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &IstioLifecycleManager{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *istioLifecycleManagerClient) UpdateIstioLifecycleManager(ctx context.Context, obj *IstioLifecycleManager, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *istioLifecycleManagerClient) PatchIstioLifecycleManager(ctx context.Context, obj *IstioLifecycleManager, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *istioLifecycleManagerClient) DeleteAllOfIstioLifecycleManager(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &IstioLifecycleManager{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *istioLifecycleManagerClient) UpsertIstioLifecycleManager(ctx context.Context, obj *IstioLifecycleManager, transitionFuncs ...IstioLifecycleManagerTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*IstioLifecycleManager), desired.(*IstioLifecycleManager)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *istioLifecycleManagerClient) UpdateIstioLifecycleManagerStatus(ctx context.Context, obj *IstioLifecycleManager, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *istioLifecycleManagerClient) PatchIstioLifecycleManagerStatus(ctx context.Context, obj *IstioLifecycleManager, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides IstioLifecycleManagerClients for multiple clusters.
type MulticlusterIstioLifecycleManagerClient interface {
	// Cluster returns a IstioLifecycleManagerClient for the given cluster
	Cluster(cluster string) (IstioLifecycleManagerClient, error)
}

type multiclusterIstioLifecycleManagerClient struct {
	client multicluster.Client
}

func NewMulticlusterIstioLifecycleManagerClient(client multicluster.Client) MulticlusterIstioLifecycleManagerClient {
	return &multiclusterIstioLifecycleManagerClient{client: client}
}

func (m *multiclusterIstioLifecycleManagerClient) Cluster(cluster string) (IstioLifecycleManagerClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewIstioLifecycleManagerClient(client), nil
}
