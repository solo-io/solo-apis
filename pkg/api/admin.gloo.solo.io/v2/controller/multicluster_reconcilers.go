// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./multicluster_reconcilers.go -destination mocks/multicluster_reconcilers.go

// Definitions for the multicluster Kubernetes Controllers
package controller

import (
	"context"

	admin_gloo_solo_io_v2 "github.com/solo-io/solo-apis/pkg/api/admin.gloo.solo.io/v2"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/multicluster"
	mc_reconcile "github.com/solo-io/skv2/pkg/multicluster/reconcile"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the Workspace Resource across clusters.
// implemented by the user
type MulticlusterWorkspaceReconciler interface {
	ReconcileWorkspace(clusterName string, obj *admin_gloo_solo_io_v2.Workspace) (reconcile.Result, error)
}

// Reconcile deletion events for the Workspace Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterWorkspaceDeletionReconciler interface {
	ReconcileWorkspaceDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterWorkspaceReconcilerFuncs struct {
	OnReconcileWorkspace         func(clusterName string, obj *admin_gloo_solo_io_v2.Workspace) (reconcile.Result, error)
	OnReconcileWorkspaceDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterWorkspaceReconcilerFuncs) ReconcileWorkspace(clusterName string, obj *admin_gloo_solo_io_v2.Workspace) (reconcile.Result, error) {
	if f.OnReconcileWorkspace == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileWorkspace(clusterName, obj)
}

func (f *MulticlusterWorkspaceReconcilerFuncs) ReconcileWorkspaceDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileWorkspaceDeletion == nil {
		return nil
	}
	return f.OnReconcileWorkspaceDeletion(clusterName, req)
}

type MulticlusterWorkspaceReconcileLoop interface {
	// AddMulticlusterWorkspaceReconciler adds a MulticlusterWorkspaceReconciler to the MulticlusterWorkspaceReconcileLoop.
	AddMulticlusterWorkspaceReconciler(ctx context.Context, rec MulticlusterWorkspaceReconciler, predicates ...predicate.Predicate)
}

type multiclusterWorkspaceReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterWorkspaceReconcileLoop) AddMulticlusterWorkspaceReconciler(ctx context.Context, rec MulticlusterWorkspaceReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericWorkspaceMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterWorkspaceReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterWorkspaceReconcileLoop {
	return &multiclusterWorkspaceReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &admin_gloo_solo_io_v2.Workspace{}, options)}
}

type genericWorkspaceMulticlusterReconciler struct {
	reconciler MulticlusterWorkspaceReconciler
}

func (g genericWorkspaceMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterWorkspaceDeletionReconciler); ok {
		return deletionReconciler.ReconcileWorkspaceDeletion(cluster, req)
	}
	return nil
}

func (g genericWorkspaceMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_gloo_solo_io_v2.Workspace)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: Workspace handler received event for %T", object)
	}
	return g.reconciler.ReconcileWorkspace(cluster, obj)
}

// Reconcile Upsert events for the WorkspaceSettings Resource across clusters.
// implemented by the user
type MulticlusterWorkspaceSettingsReconciler interface {
	ReconcileWorkspaceSettings(clusterName string, obj *admin_gloo_solo_io_v2.WorkspaceSettings) (reconcile.Result, error)
}

// Reconcile deletion events for the WorkspaceSettings Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterWorkspaceSettingsDeletionReconciler interface {
	ReconcileWorkspaceSettingsDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterWorkspaceSettingsReconcilerFuncs struct {
	OnReconcileWorkspaceSettings         func(clusterName string, obj *admin_gloo_solo_io_v2.WorkspaceSettings) (reconcile.Result, error)
	OnReconcileWorkspaceSettingsDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterWorkspaceSettingsReconcilerFuncs) ReconcileWorkspaceSettings(clusterName string, obj *admin_gloo_solo_io_v2.WorkspaceSettings) (reconcile.Result, error) {
	if f.OnReconcileWorkspaceSettings == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileWorkspaceSettings(clusterName, obj)
}

func (f *MulticlusterWorkspaceSettingsReconcilerFuncs) ReconcileWorkspaceSettingsDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileWorkspaceSettingsDeletion == nil {
		return nil
	}
	return f.OnReconcileWorkspaceSettingsDeletion(clusterName, req)
}

type MulticlusterWorkspaceSettingsReconcileLoop interface {
	// AddMulticlusterWorkspaceSettingsReconciler adds a MulticlusterWorkspaceSettingsReconciler to the MulticlusterWorkspaceSettingsReconcileLoop.
	AddMulticlusterWorkspaceSettingsReconciler(ctx context.Context, rec MulticlusterWorkspaceSettingsReconciler, predicates ...predicate.Predicate)
}

type multiclusterWorkspaceSettingsReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterWorkspaceSettingsReconcileLoop) AddMulticlusterWorkspaceSettingsReconciler(ctx context.Context, rec MulticlusterWorkspaceSettingsReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericWorkspaceSettingsMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterWorkspaceSettingsReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterWorkspaceSettingsReconcileLoop {
	return &multiclusterWorkspaceSettingsReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &admin_gloo_solo_io_v2.WorkspaceSettings{}, options)}
}

type genericWorkspaceSettingsMulticlusterReconciler struct {
	reconciler MulticlusterWorkspaceSettingsReconciler
}

func (g genericWorkspaceSettingsMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterWorkspaceSettingsDeletionReconciler); ok {
		return deletionReconciler.ReconcileWorkspaceSettingsDeletion(cluster, req)
	}
	return nil
}

func (g genericWorkspaceSettingsMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_gloo_solo_io_v2.WorkspaceSettings)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: WorkspaceSettings handler received event for %T", object)
	}
	return g.reconciler.ReconcileWorkspaceSettings(cluster, obj)
}

// Reconcile Upsert events for the KubernetesCluster Resource across clusters.
// implemented by the user
type MulticlusterKubernetesClusterReconciler interface {
	ReconcileKubernetesCluster(clusterName string, obj *admin_gloo_solo_io_v2.KubernetesCluster) (reconcile.Result, error)
}

// Reconcile deletion events for the KubernetesCluster Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterKubernetesClusterDeletionReconciler interface {
	ReconcileKubernetesClusterDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterKubernetesClusterReconcilerFuncs struct {
	OnReconcileKubernetesCluster         func(clusterName string, obj *admin_gloo_solo_io_v2.KubernetesCluster) (reconcile.Result, error)
	OnReconcileKubernetesClusterDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterKubernetesClusterReconcilerFuncs) ReconcileKubernetesCluster(clusterName string, obj *admin_gloo_solo_io_v2.KubernetesCluster) (reconcile.Result, error) {
	if f.OnReconcileKubernetesCluster == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileKubernetesCluster(clusterName, obj)
}

func (f *MulticlusterKubernetesClusterReconcilerFuncs) ReconcileKubernetesClusterDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileKubernetesClusterDeletion == nil {
		return nil
	}
	return f.OnReconcileKubernetesClusterDeletion(clusterName, req)
}

type MulticlusterKubernetesClusterReconcileLoop interface {
	// AddMulticlusterKubernetesClusterReconciler adds a MulticlusterKubernetesClusterReconciler to the MulticlusterKubernetesClusterReconcileLoop.
	AddMulticlusterKubernetesClusterReconciler(ctx context.Context, rec MulticlusterKubernetesClusterReconciler, predicates ...predicate.Predicate)
}

type multiclusterKubernetesClusterReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterKubernetesClusterReconcileLoop) AddMulticlusterKubernetesClusterReconciler(ctx context.Context, rec MulticlusterKubernetesClusterReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericKubernetesClusterMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterKubernetesClusterReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterKubernetesClusterReconcileLoop {
	return &multiclusterKubernetesClusterReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &admin_gloo_solo_io_v2.KubernetesCluster{}, options)}
}

type genericKubernetesClusterMulticlusterReconciler struct {
	reconciler MulticlusterKubernetesClusterReconciler
}

func (g genericKubernetesClusterMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterKubernetesClusterDeletionReconciler); ok {
		return deletionReconciler.ReconcileKubernetesClusterDeletion(cluster, req)
	}
	return nil
}

func (g genericKubernetesClusterMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_gloo_solo_io_v2.KubernetesCluster)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: KubernetesCluster handler received event for %T", object)
	}
	return g.reconciler.ReconcileKubernetesCluster(cluster, obj)
}

// Reconcile Upsert events for the RootTrustPolicy Resource across clusters.
// implemented by the user
type MulticlusterRootTrustPolicyReconciler interface {
	ReconcileRootTrustPolicy(clusterName string, obj *admin_gloo_solo_io_v2.RootTrustPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the RootTrustPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterRootTrustPolicyDeletionReconciler interface {
	ReconcileRootTrustPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterRootTrustPolicyReconcilerFuncs struct {
	OnReconcileRootTrustPolicy         func(clusterName string, obj *admin_gloo_solo_io_v2.RootTrustPolicy) (reconcile.Result, error)
	OnReconcileRootTrustPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterRootTrustPolicyReconcilerFuncs) ReconcileRootTrustPolicy(clusterName string, obj *admin_gloo_solo_io_v2.RootTrustPolicy) (reconcile.Result, error) {
	if f.OnReconcileRootTrustPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileRootTrustPolicy(clusterName, obj)
}

func (f *MulticlusterRootTrustPolicyReconcilerFuncs) ReconcileRootTrustPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileRootTrustPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileRootTrustPolicyDeletion(clusterName, req)
}

type MulticlusterRootTrustPolicyReconcileLoop interface {
	// AddMulticlusterRootTrustPolicyReconciler adds a MulticlusterRootTrustPolicyReconciler to the MulticlusterRootTrustPolicyReconcileLoop.
	AddMulticlusterRootTrustPolicyReconciler(ctx context.Context, rec MulticlusterRootTrustPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterRootTrustPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterRootTrustPolicyReconcileLoop) AddMulticlusterRootTrustPolicyReconciler(ctx context.Context, rec MulticlusterRootTrustPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericRootTrustPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterRootTrustPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterRootTrustPolicyReconcileLoop {
	return &multiclusterRootTrustPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &admin_gloo_solo_io_v2.RootTrustPolicy{}, options)}
}

type genericRootTrustPolicyMulticlusterReconciler struct {
	reconciler MulticlusterRootTrustPolicyReconciler
}

func (g genericRootTrustPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterRootTrustPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileRootTrustPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericRootTrustPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_gloo_solo_io_v2.RootTrustPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: RootTrustPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileRootTrustPolicy(cluster, obj)
}

// Reconcile Upsert events for the ExtAuthServer Resource across clusters.
// implemented by the user
type MulticlusterExtAuthServerReconciler interface {
	ReconcileExtAuthServer(clusterName string, obj *admin_gloo_solo_io_v2.ExtAuthServer) (reconcile.Result, error)
}

// Reconcile deletion events for the ExtAuthServer Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterExtAuthServerDeletionReconciler interface {
	ReconcileExtAuthServerDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterExtAuthServerReconcilerFuncs struct {
	OnReconcileExtAuthServer         func(clusterName string, obj *admin_gloo_solo_io_v2.ExtAuthServer) (reconcile.Result, error)
	OnReconcileExtAuthServerDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterExtAuthServerReconcilerFuncs) ReconcileExtAuthServer(clusterName string, obj *admin_gloo_solo_io_v2.ExtAuthServer) (reconcile.Result, error) {
	if f.OnReconcileExtAuthServer == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileExtAuthServer(clusterName, obj)
}

func (f *MulticlusterExtAuthServerReconcilerFuncs) ReconcileExtAuthServerDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileExtAuthServerDeletion == nil {
		return nil
	}
	return f.OnReconcileExtAuthServerDeletion(clusterName, req)
}

type MulticlusterExtAuthServerReconcileLoop interface {
	// AddMulticlusterExtAuthServerReconciler adds a MulticlusterExtAuthServerReconciler to the MulticlusterExtAuthServerReconcileLoop.
	AddMulticlusterExtAuthServerReconciler(ctx context.Context, rec MulticlusterExtAuthServerReconciler, predicates ...predicate.Predicate)
}

type multiclusterExtAuthServerReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterExtAuthServerReconcileLoop) AddMulticlusterExtAuthServerReconciler(ctx context.Context, rec MulticlusterExtAuthServerReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericExtAuthServerMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterExtAuthServerReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterExtAuthServerReconcileLoop {
	return &multiclusterExtAuthServerReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &admin_gloo_solo_io_v2.ExtAuthServer{}, options)}
}

type genericExtAuthServerMulticlusterReconciler struct {
	reconciler MulticlusterExtAuthServerReconciler
}

func (g genericExtAuthServerMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterExtAuthServerDeletionReconciler); ok {
		return deletionReconciler.ReconcileExtAuthServerDeletion(cluster, req)
	}
	return nil
}

func (g genericExtAuthServerMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_gloo_solo_io_v2.ExtAuthServer)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ExtAuthServer handler received event for %T", object)
	}
	return g.reconciler.ReconcileExtAuthServer(cluster, obj)
}

// Reconcile Upsert events for the RateLimitServerSettings Resource across clusters.
// implemented by the user
type MulticlusterRateLimitServerSettingsReconciler interface {
	ReconcileRateLimitServerSettings(clusterName string, obj *admin_gloo_solo_io_v2.RateLimitServerSettings) (reconcile.Result, error)
}

// Reconcile deletion events for the RateLimitServerSettings Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterRateLimitServerSettingsDeletionReconciler interface {
	ReconcileRateLimitServerSettingsDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterRateLimitServerSettingsReconcilerFuncs struct {
	OnReconcileRateLimitServerSettings         func(clusterName string, obj *admin_gloo_solo_io_v2.RateLimitServerSettings) (reconcile.Result, error)
	OnReconcileRateLimitServerSettingsDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterRateLimitServerSettingsReconcilerFuncs) ReconcileRateLimitServerSettings(clusterName string, obj *admin_gloo_solo_io_v2.RateLimitServerSettings) (reconcile.Result, error) {
	if f.OnReconcileRateLimitServerSettings == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileRateLimitServerSettings(clusterName, obj)
}

func (f *MulticlusterRateLimitServerSettingsReconcilerFuncs) ReconcileRateLimitServerSettingsDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileRateLimitServerSettingsDeletion == nil {
		return nil
	}
	return f.OnReconcileRateLimitServerSettingsDeletion(clusterName, req)
}

type MulticlusterRateLimitServerSettingsReconcileLoop interface {
	// AddMulticlusterRateLimitServerSettingsReconciler adds a MulticlusterRateLimitServerSettingsReconciler to the MulticlusterRateLimitServerSettingsReconcileLoop.
	AddMulticlusterRateLimitServerSettingsReconciler(ctx context.Context, rec MulticlusterRateLimitServerSettingsReconciler, predicates ...predicate.Predicate)
}

type multiclusterRateLimitServerSettingsReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterRateLimitServerSettingsReconcileLoop) AddMulticlusterRateLimitServerSettingsReconciler(ctx context.Context, rec MulticlusterRateLimitServerSettingsReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericRateLimitServerSettingsMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterRateLimitServerSettingsReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterRateLimitServerSettingsReconcileLoop {
	return &multiclusterRateLimitServerSettingsReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &admin_gloo_solo_io_v2.RateLimitServerSettings{}, options)}
}

type genericRateLimitServerSettingsMulticlusterReconciler struct {
	reconciler MulticlusterRateLimitServerSettingsReconciler
}

func (g genericRateLimitServerSettingsMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterRateLimitServerSettingsDeletionReconciler); ok {
		return deletionReconciler.ReconcileRateLimitServerSettingsDeletion(cluster, req)
	}
	return nil
}

func (g genericRateLimitServerSettingsMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_gloo_solo_io_v2.RateLimitServerSettings)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: RateLimitServerSettings handler received event for %T", object)
	}
	return g.reconciler.ReconcileRateLimitServerSettings(cluster, obj)
}

// Reconcile Upsert events for the RateLimitServerConfig Resource across clusters.
// implemented by the user
type MulticlusterRateLimitServerConfigReconciler interface {
	ReconcileRateLimitServerConfig(clusterName string, obj *admin_gloo_solo_io_v2.RateLimitServerConfig) (reconcile.Result, error)
}

// Reconcile deletion events for the RateLimitServerConfig Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterRateLimitServerConfigDeletionReconciler interface {
	ReconcileRateLimitServerConfigDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterRateLimitServerConfigReconcilerFuncs struct {
	OnReconcileRateLimitServerConfig         func(clusterName string, obj *admin_gloo_solo_io_v2.RateLimitServerConfig) (reconcile.Result, error)
	OnReconcileRateLimitServerConfigDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterRateLimitServerConfigReconcilerFuncs) ReconcileRateLimitServerConfig(clusterName string, obj *admin_gloo_solo_io_v2.RateLimitServerConfig) (reconcile.Result, error) {
	if f.OnReconcileRateLimitServerConfig == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileRateLimitServerConfig(clusterName, obj)
}

func (f *MulticlusterRateLimitServerConfigReconcilerFuncs) ReconcileRateLimitServerConfigDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileRateLimitServerConfigDeletion == nil {
		return nil
	}
	return f.OnReconcileRateLimitServerConfigDeletion(clusterName, req)
}

type MulticlusterRateLimitServerConfigReconcileLoop interface {
	// AddMulticlusterRateLimitServerConfigReconciler adds a MulticlusterRateLimitServerConfigReconciler to the MulticlusterRateLimitServerConfigReconcileLoop.
	AddMulticlusterRateLimitServerConfigReconciler(ctx context.Context, rec MulticlusterRateLimitServerConfigReconciler, predicates ...predicate.Predicate)
}

type multiclusterRateLimitServerConfigReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterRateLimitServerConfigReconcileLoop) AddMulticlusterRateLimitServerConfigReconciler(ctx context.Context, rec MulticlusterRateLimitServerConfigReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericRateLimitServerConfigMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterRateLimitServerConfigReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterRateLimitServerConfigReconcileLoop {
	return &multiclusterRateLimitServerConfigReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &admin_gloo_solo_io_v2.RateLimitServerConfig{}, options)}
}

type genericRateLimitServerConfigMulticlusterReconciler struct {
	reconciler MulticlusterRateLimitServerConfigReconciler
}

func (g genericRateLimitServerConfigMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterRateLimitServerConfigDeletionReconciler); ok {
		return deletionReconciler.ReconcileRateLimitServerConfigDeletion(cluster, req)
	}
	return nil
}

func (g genericRateLimitServerConfigMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_gloo_solo_io_v2.RateLimitServerConfig)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: RateLimitServerConfig handler received event for %T", object)
	}
	return g.reconciler.ReconcileRateLimitServerConfig(cluster, obj)
}

// Reconcile Upsert events for the Dashboard Resource across clusters.
// implemented by the user
type MulticlusterDashboardReconciler interface {
	ReconcileDashboard(clusterName string, obj *admin_gloo_solo_io_v2.Dashboard) (reconcile.Result, error)
}

// Reconcile deletion events for the Dashboard Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterDashboardDeletionReconciler interface {
	ReconcileDashboardDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterDashboardReconcilerFuncs struct {
	OnReconcileDashboard         func(clusterName string, obj *admin_gloo_solo_io_v2.Dashboard) (reconcile.Result, error)
	OnReconcileDashboardDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterDashboardReconcilerFuncs) ReconcileDashboard(clusterName string, obj *admin_gloo_solo_io_v2.Dashboard) (reconcile.Result, error) {
	if f.OnReconcileDashboard == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileDashboard(clusterName, obj)
}

func (f *MulticlusterDashboardReconcilerFuncs) ReconcileDashboardDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileDashboardDeletion == nil {
		return nil
	}
	return f.OnReconcileDashboardDeletion(clusterName, req)
}

type MulticlusterDashboardReconcileLoop interface {
	// AddMulticlusterDashboardReconciler adds a MulticlusterDashboardReconciler to the MulticlusterDashboardReconcileLoop.
	AddMulticlusterDashboardReconciler(ctx context.Context, rec MulticlusterDashboardReconciler, predicates ...predicate.Predicate)
}

type multiclusterDashboardReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterDashboardReconcileLoop) AddMulticlusterDashboardReconciler(ctx context.Context, rec MulticlusterDashboardReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericDashboardMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterDashboardReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterDashboardReconcileLoop {
	return &multiclusterDashboardReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &admin_gloo_solo_io_v2.Dashboard{}, options)}
}

type genericDashboardMulticlusterReconciler struct {
	reconciler MulticlusterDashboardReconciler
}

func (g genericDashboardMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterDashboardDeletionReconciler); ok {
		return deletionReconciler.ReconcileDashboardDeletion(cluster, req)
	}
	return nil
}

func (g genericDashboardMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_gloo_solo_io_v2.Dashboard)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: Dashboard handler received event for %T", object)
	}
	return g.reconciler.ReconcileDashboard(cluster, obj)
}
