// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/solo-io/solo-apis/api/gloo/gloo/v1/proxy.proto

package v1

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "github.com/solo-io/protoc-gen-ext/extproto"
	matchers "github.com/solo-io/solo-apis/pkg/api/gloo.solo.io/v1/core/matchers"
	core "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RedirectAction_RedirectResponseCode int32

const (
	// Moved Permanently HTTP Status Code - 301.
	RedirectAction_MOVED_PERMANENTLY RedirectAction_RedirectResponseCode = 0
	// Found HTTP Status Code - 302.
	RedirectAction_FOUND RedirectAction_RedirectResponseCode = 1
	// See Other HTTP Status Code - 303.
	RedirectAction_SEE_OTHER RedirectAction_RedirectResponseCode = 2
	// Temporary Redirect HTTP Status Code - 307.
	RedirectAction_TEMPORARY_REDIRECT RedirectAction_RedirectResponseCode = 3
	// Permanent Redirect HTTP Status Code - 308.
	RedirectAction_PERMANENT_REDIRECT RedirectAction_RedirectResponseCode = 4
)

var RedirectAction_RedirectResponseCode_name = map[int32]string{
	0: "MOVED_PERMANENTLY",
	1: "FOUND",
	2: "SEE_OTHER",
	3: "TEMPORARY_REDIRECT",
	4: "PERMANENT_REDIRECT",
}

var RedirectAction_RedirectResponseCode_value = map[string]int32{
	"MOVED_PERMANENTLY":  0,
	"FOUND":              1,
	"SEE_OTHER":          2,
	"TEMPORARY_REDIRECT": 3,
	"PERMANENT_REDIRECT": 4,
}

func (x RedirectAction_RedirectResponseCode) String() string {
	return proto.EnumName(RedirectAction_RedirectResponseCode_name, int32(x))
}

func (RedirectAction_RedirectResponseCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{14, 0}
}

//
//A Proxy is a container for the entire set of configuration that will to be applied to one or more Proxy instances.
//Proxies can be understood as a set of listeners, represents a different bind address/port where the proxy will listen
//for connections. Each listener has its own set of configuration.
//
//If any of the sub-resources within a listener is declared invalid (e.g. due to invalid user configuration), the
//proxy will be marked invalid by Gloo.
//
//Proxy instances that register with Gloo are assigned the proxy configuration corresponding with
//a proxy-specific identifier.
// In the case of Envoy, proxy instances are identified by their Node ID. Node IDs must match a existing Proxy
// Node ID can be specified in Envoy with the `--service-node` flag, or in the Envoy instance's bootstrap config.
type Proxy struct {
	// Define here each listener the proxy should create.
	// Listeners define the a set of behaviors for a single bind address/port where the proxy will listen
	// If no listeners are specified, the instances configured with the proxy resource will not accept connections.
	Listeners []*Listener `protobuf:"bytes,2,rep,name=listeners,proto3" json:"listeners,omitempty"`
	// Status indicates the validation status of this resource.
	// Status is read-only by clients, and set by gloo during validation
	Status core.Status `protobuf:"bytes,6,opt,name=status,proto3" json:"status" testdiff:"ignore"`
	// Metadata contains the object metadata for this resource
	Metadata             core.Metadata `protobuf:"bytes,7,opt,name=metadata,proto3" json:"metadata"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Proxy) Reset()         { *m = Proxy{} }
func (m *Proxy) String() string { return proto.CompactTextString(m) }
func (*Proxy) ProtoMessage()    {}
func (*Proxy) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{0}
}
func (m *Proxy) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Proxy.Unmarshal(m, b)
}
func (m *Proxy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Proxy.Marshal(b, m, deterministic)
}
func (m *Proxy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proxy.Merge(m, src)
}
func (m *Proxy) XXX_Size() int {
	return xxx_messageInfo_Proxy.Size(m)
}
func (m *Proxy) XXX_DiscardUnknown() {
	xxx_messageInfo_Proxy.DiscardUnknown(m)
}

var xxx_messageInfo_Proxy proto.InternalMessageInfo

func (m *Proxy) GetListeners() []*Listener {
	if m != nil {
		return m.Listeners
	}
	return nil
}

func (m *Proxy) GetStatus() core.Status {
	if m != nil {
		return m.Status
	}
	return core.Status{}
}

func (m *Proxy) GetMetadata() core.Metadata {
	if m != nil {
		return m.Metadata
	}
	return core.Metadata{}
}

// Listeners define the address:port where the proxy will listen for incoming connections
// A Listener accepts connections (currently only HTTP is supported) and apply user-defined behavior for those connections,
// e.g. performing SSL termination, HTTP retries, and rate limiting.
type Listener struct {
	// the name of the listener. names must be unique for each listener within a proxy
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// the bind address for the listener.
	// both ipv4 and ipv6 formats are supported
	BindAddress string `protobuf:"bytes,2,opt,name=bind_address,json=bindAddress,proto3" json:"bind_address,omitempty"`
	// the port to bind on
	// ports numbers must be unique for listeners within a proxy
	BindPort uint32 `protobuf:"varint,3,opt,name=bind_port,json=bindPort,proto3" json:"bind_port,omitempty"`
	// Listeners can listen for HTTP, TCP (unsupported), and UDP (unsupported) connections
	//
	// Types that are valid to be assigned to ListenerType:
	//	*Listener_HttpListener
	//	*Listener_TcpListener
	ListenerType isListener_ListenerType `protobuf_oneof:"ListenerType"`
	// SSL Config is optional for the listener. If provided, the listener will serve TLS for connections on this port.
	// Multiple SslConfigs are supported for the purpose of SNI. Be aware that the SNI domain provided in the SSL Config
	SslConfigurations []*SslConfig `protobuf:"bytes,6,rep,name=ssl_configurations,json=sslConfigurations,proto3" json:"ssl_configurations,omitempty"`
	// Enable ProxyProtocol support for this listener
	UseProxyProto *types.BoolValue `protobuf:"bytes,7,opt,name=use_proxy_proto,json=useProxyProto,proto3" json:"use_proxy_proto,omitempty"`
	// top level options
	Options *ListenerOptions `protobuf:"bytes,8,opt,name=options,proto3" json:"options,omitempty"`
	// Metadata for the individual listener
	// This data is opaque to Gloo, used
	// by controllers to track ownership of listeners within a proxy
	// as they are typically generated by a controller (such as the gateway)
	Metadata             *types.Struct `protobuf:"bytes,9,opt,name=metadata,proto3" json:"metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Listener) Reset()         { *m = Listener{} }
func (m *Listener) String() string { return proto.CompactTextString(m) }
func (*Listener) ProtoMessage()    {}
func (*Listener) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{1}
}
func (m *Listener) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Listener.Unmarshal(m, b)
}
func (m *Listener) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Listener.Marshal(b, m, deterministic)
}
func (m *Listener) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Listener.Merge(m, src)
}
func (m *Listener) XXX_Size() int {
	return xxx_messageInfo_Listener.Size(m)
}
func (m *Listener) XXX_DiscardUnknown() {
	xxx_messageInfo_Listener.DiscardUnknown(m)
}

var xxx_messageInfo_Listener proto.InternalMessageInfo

type isListener_ListenerType interface {
	isListener_ListenerType()
	Equal(interface{}) bool
}

type Listener_HttpListener struct {
	HttpListener *HttpListener `protobuf:"bytes,4,opt,name=http_listener,json=httpListener,proto3,oneof" json:"http_listener,omitempty"`
}
type Listener_TcpListener struct {
	TcpListener *TcpListener `protobuf:"bytes,5,opt,name=tcp_listener,json=tcpListener,proto3,oneof" json:"tcp_listener,omitempty"`
}

func (*Listener_HttpListener) isListener_ListenerType() {}
func (*Listener_TcpListener) isListener_ListenerType()  {}

func (m *Listener) GetListenerType() isListener_ListenerType {
	if m != nil {
		return m.ListenerType
	}
	return nil
}

func (m *Listener) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Listener) GetBindAddress() string {
	if m != nil {
		return m.BindAddress
	}
	return ""
}

func (m *Listener) GetBindPort() uint32 {
	if m != nil {
		return m.BindPort
	}
	return 0
}

func (m *Listener) GetHttpListener() *HttpListener {
	if x, ok := m.GetListenerType().(*Listener_HttpListener); ok {
		return x.HttpListener
	}
	return nil
}

func (m *Listener) GetTcpListener() *TcpListener {
	if x, ok := m.GetListenerType().(*Listener_TcpListener); ok {
		return x.TcpListener
	}
	return nil
}

func (m *Listener) GetSslConfigurations() []*SslConfig {
	if m != nil {
		return m.SslConfigurations
	}
	return nil
}

func (m *Listener) GetUseProxyProto() *types.BoolValue {
	if m != nil {
		return m.UseProxyProto
	}
	return nil
}

func (m *Listener) GetOptions() *ListenerOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *Listener) GetMetadata() *types.Struct {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Listener) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Listener_HttpListener)(nil),
		(*Listener_TcpListener)(nil),
	}
}

type TcpListener struct {
	// List of filter chains to match on for this listener
	TcpHosts []*TcpHost `protobuf:"bytes,1,rep,name=tcp_hosts,json=tcpHosts,proto3" json:"tcp_hosts,omitempty"`
	// Options contains top-level configuration to be applied to a listener.
	// Listener config is applied to traffic for the given listener.
	// Some configuration here can be overridden in
	// Virtual Host Options configuration or Route Options configuration
	Options *TcpListenerOptions `protobuf:"bytes,8,opt,name=options,proto3" json:"options,omitempty"`
	// prefix for addressing envoy stats for the tcp proxy
	StatPrefix           string   `protobuf:"bytes,3,opt,name=stat_prefix,json=statPrefix,proto3" json:"stat_prefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TcpListener) Reset()         { *m = TcpListener{} }
func (m *TcpListener) String() string { return proto.CompactTextString(m) }
func (*TcpListener) ProtoMessage()    {}
func (*TcpListener) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{2}
}
func (m *TcpListener) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TcpListener.Unmarshal(m, b)
}
func (m *TcpListener) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TcpListener.Marshal(b, m, deterministic)
}
func (m *TcpListener) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpListener.Merge(m, src)
}
func (m *TcpListener) XXX_Size() int {
	return xxx_messageInfo_TcpListener.Size(m)
}
func (m *TcpListener) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpListener.DiscardUnknown(m)
}

var xxx_messageInfo_TcpListener proto.InternalMessageInfo

func (m *TcpListener) GetTcpHosts() []*TcpHost {
	if m != nil {
		return m.TcpHosts
	}
	return nil
}

func (m *TcpListener) GetOptions() *TcpListenerOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *TcpListener) GetStatPrefix() string {
	if m != nil {
		return m.StatPrefix
	}
	return ""
}

type TcpHost struct {
	// the logical name of the tcp host. names must be unique for each tcp host within a listener
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// If provided, the Gateway will serve TLS/SSL traffic for this set of routes
	SslConfig            *SslConfig         `protobuf:"bytes,3,opt,name=ssl_config,json=sslConfig,proto3" json:"ssl_config,omitempty"`
	Destination          *TcpHost_TcpAction `protobuf:"bytes,4,opt,name=destination,proto3" json:"destination,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TcpHost) Reset()         { *m = TcpHost{} }
func (m *TcpHost) String() string { return proto.CompactTextString(m) }
func (*TcpHost) ProtoMessage()    {}
func (*TcpHost) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{3}
}
func (m *TcpHost) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TcpHost.Unmarshal(m, b)
}
func (m *TcpHost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TcpHost.Marshal(b, m, deterministic)
}
func (m *TcpHost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpHost.Merge(m, src)
}
func (m *TcpHost) XXX_Size() int {
	return xxx_messageInfo_TcpHost.Size(m)
}
func (m *TcpHost) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpHost.DiscardUnknown(m)
}

var xxx_messageInfo_TcpHost proto.InternalMessageInfo

func (m *TcpHost) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TcpHost) GetSslConfig() *SslConfig {
	if m != nil {
		return m.SslConfig
	}
	return nil
}

func (m *TcpHost) GetDestination() *TcpHost_TcpAction {
	if m != nil {
		return m.Destination
	}
	return nil
}

// Name of the destinations the gateway can route to.
// Note: the destination spec and subsets are not supported in this context and will be ignored.
type TcpHost_TcpAction struct {
	// Types that are valid to be assigned to Destination:
	//	*TcpHost_TcpAction_Single
	//	*TcpHost_TcpAction_Multi
	//	*TcpHost_TcpAction_UpstreamGroup
	//	*TcpHost_TcpAction_ForwardSniClusterName
	Destination          isTcpHost_TcpAction_Destination `protobuf_oneof:"destination"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *TcpHost_TcpAction) Reset()         { *m = TcpHost_TcpAction{} }
func (m *TcpHost_TcpAction) String() string { return proto.CompactTextString(m) }
func (*TcpHost_TcpAction) ProtoMessage()    {}
func (*TcpHost_TcpAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{3, 0}
}
func (m *TcpHost_TcpAction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TcpHost_TcpAction.Unmarshal(m, b)
}
func (m *TcpHost_TcpAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TcpHost_TcpAction.Marshal(b, m, deterministic)
}
func (m *TcpHost_TcpAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpHost_TcpAction.Merge(m, src)
}
func (m *TcpHost_TcpAction) XXX_Size() int {
	return xxx_messageInfo_TcpHost_TcpAction.Size(m)
}
func (m *TcpHost_TcpAction) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpHost_TcpAction.DiscardUnknown(m)
}

var xxx_messageInfo_TcpHost_TcpAction proto.InternalMessageInfo

type isTcpHost_TcpAction_Destination interface {
	isTcpHost_TcpAction_Destination()
	Equal(interface{}) bool
}

type TcpHost_TcpAction_Single struct {
	Single *Destination `protobuf:"bytes,1,opt,name=single,proto3,oneof" json:"single,omitempty"`
}
type TcpHost_TcpAction_Multi struct {
	Multi *MultiDestination `protobuf:"bytes,2,opt,name=multi,proto3,oneof" json:"multi,omitempty"`
}
type TcpHost_TcpAction_UpstreamGroup struct {
	UpstreamGroup *core.ResourceRef `protobuf:"bytes,3,opt,name=upstream_group,json=upstreamGroup,proto3,oneof" json:"upstream_group,omitempty"`
}
type TcpHost_TcpAction_ForwardSniClusterName struct {
	ForwardSniClusterName *types.Empty `protobuf:"bytes,4,opt,name=forward_sni_cluster_name,json=forwardSniClusterName,proto3,oneof" json:"forward_sni_cluster_name,omitempty"`
}

func (*TcpHost_TcpAction_Single) isTcpHost_TcpAction_Destination()                {}
func (*TcpHost_TcpAction_Multi) isTcpHost_TcpAction_Destination()                 {}
func (*TcpHost_TcpAction_UpstreamGroup) isTcpHost_TcpAction_Destination()         {}
func (*TcpHost_TcpAction_ForwardSniClusterName) isTcpHost_TcpAction_Destination() {}

func (m *TcpHost_TcpAction) GetDestination() isTcpHost_TcpAction_Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *TcpHost_TcpAction) GetSingle() *Destination {
	if x, ok := m.GetDestination().(*TcpHost_TcpAction_Single); ok {
		return x.Single
	}
	return nil
}

func (m *TcpHost_TcpAction) GetMulti() *MultiDestination {
	if x, ok := m.GetDestination().(*TcpHost_TcpAction_Multi); ok {
		return x.Multi
	}
	return nil
}

func (m *TcpHost_TcpAction) GetUpstreamGroup() *core.ResourceRef {
	if x, ok := m.GetDestination().(*TcpHost_TcpAction_UpstreamGroup); ok {
		return x.UpstreamGroup
	}
	return nil
}

func (m *TcpHost_TcpAction) GetForwardSniClusterName() *types.Empty {
	if x, ok := m.GetDestination().(*TcpHost_TcpAction_ForwardSniClusterName); ok {
		return x.ForwardSniClusterName
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TcpHost_TcpAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TcpHost_TcpAction_Single)(nil),
		(*TcpHost_TcpAction_Multi)(nil),
		(*TcpHost_TcpAction_UpstreamGroup)(nil),
		(*TcpHost_TcpAction_ForwardSniClusterName)(nil),
	}
}

// Use this listener to configure proxy behavior for any HTTP-level features including defining routes (via virtual services).
// HttpListeners also contain optional configuration that applies globally across all virtual hosts on the listener.
// Some traffic policies can be configured to work both on the listener and virtual host level (e.g., the rate limit feature)
type HttpListener struct {
	// the set of virtual hosts that will be accessible by clients connecting to this listener.
	// at least one virtual host must be specified for this listener to be active (else connections will be refused)
	// the set of domains for each virtual host must be unique, or the config will be considered invalid
	VirtualHosts []*VirtualHost `protobuf:"bytes,1,rep,name=virtual_hosts,json=virtualHosts,proto3" json:"virtual_hosts,omitempty"`
	// HttpListenerOptions contains optional top-level configuration to be applied to a listener.
	// Listener config is applied to traffic for the given listener.
	// Some configuration here can be overridden in VirtualHostOptions configuration, RouteOptions configuration,
	// or WeightedDestinationOptions configuration.
	Options *HttpListenerOptions `protobuf:"bytes,2,opt,name=options,proto3" json:"options,omitempty"`
	// prefix for addressing envoy stats for the http connection manager
	StatPrefix           string   `protobuf:"bytes,3,opt,name=stat_prefix,json=statPrefix,proto3" json:"stat_prefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HttpListener) Reset()         { *m = HttpListener{} }
func (m *HttpListener) String() string { return proto.CompactTextString(m) }
func (*HttpListener) ProtoMessage()    {}
func (*HttpListener) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{4}
}
func (m *HttpListener) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HttpListener.Unmarshal(m, b)
}
func (m *HttpListener) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HttpListener.Marshal(b, m, deterministic)
}
func (m *HttpListener) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpListener.Merge(m, src)
}
func (m *HttpListener) XXX_Size() int {
	return xxx_messageInfo_HttpListener.Size(m)
}
func (m *HttpListener) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpListener.DiscardUnknown(m)
}

var xxx_messageInfo_HttpListener proto.InternalMessageInfo

func (m *HttpListener) GetVirtualHosts() []*VirtualHost {
	if m != nil {
		return m.VirtualHosts
	}
	return nil
}

func (m *HttpListener) GetOptions() *HttpListenerOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *HttpListener) GetStatPrefix() string {
	if m != nil {
		return m.StatPrefix
	}
	return ""
}

//
// Virtual Hosts group an ordered list of routes under one or more domains.
// Each Virtual Host has a logical name, which must be unique for the listener.
// An HTTP request is first matched to a virtual host based on its host header, then to a route within the virtual host.
// If a request is not matched to any virtual host or a route therein, the target proxy will reply with a 404.
type VirtualHost struct {
	// the logical name of the virtual host. names must be unique for each virtual host within a listener
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The list of domains (i.e.: matching the `Host` header of a request) that belong to this virtual host.
	// Note that the wildcard will not match the empty string. e.g. “*-bar.foo.com” will match “baz-bar.foo.com”
	// but not “-bar.foo.com”. Additionally, a special entry “*” is allowed which will match any host/authority header.
	// Only a single virtual host in the entire route configuration can match on “*”. A domain must be unique across all
	// virtual hosts or the config will be invalidated by Gloo
	// Domains on virtual hosts obey the same rules as [Envoy Virtual Hosts](https://github.com/envoyproxy/envoy/blob/master/api/envoy/api/v2/route/route.proto)
	Domains []string `protobuf:"bytes,2,rep,name=domains,proto3" json:"domains,omitempty"`
	// The list of HTTP routes define routing actions to be taken for incoming HTTP requests whose host header matches
	// this virtual host. If the request matches more than one route in the list, the first route matched will be selected.
	// If the list of routes is empty, the virtual host will be ignored by Gloo.
	Routes []*Route `protobuf:"bytes,3,rep,name=routes,proto3" json:"routes,omitempty"`
	// Virtual host options contain additional configuration to be applied to all traffic served by the Virtual Host.
	// Some configuration here can be overridden by Route Options.
	Options *VirtualHostOptions `protobuf:"bytes,4,opt,name=options,proto3" json:"options,omitempty"`
	// Metadata for the individual virtual host
	// This data is opaque to Gloo, used
	// by controllers to track ownership of virtual hosts within a proxy
	// as they are typically generated by a controller (such as the gateway)
	Metadata             *types.Struct `protobuf:"bytes,6,opt,name=metadata,proto3" json:"metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *VirtualHost) Reset()         { *m = VirtualHost{} }
func (m *VirtualHost) String() string { return proto.CompactTextString(m) }
func (*VirtualHost) ProtoMessage()    {}
func (*VirtualHost) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{5}
}
func (m *VirtualHost) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualHost.Unmarshal(m, b)
}
func (m *VirtualHost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualHost.Marshal(b, m, deterministic)
}
func (m *VirtualHost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualHost.Merge(m, src)
}
func (m *VirtualHost) XXX_Size() int {
	return xxx_messageInfo_VirtualHost.Size(m)
}
func (m *VirtualHost) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualHost.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualHost proto.InternalMessageInfo

func (m *VirtualHost) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VirtualHost) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *VirtualHost) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *VirtualHost) GetOptions() *VirtualHostOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *VirtualHost) GetMetadata() *types.Struct {
	if m != nil {
		return m.Metadata
	}
	return nil
}

//*
// Routes declare the entry points on virtual hosts and the action to take for matched requests.
type Route struct {
	// Matchers contain parameters for matching requests (i.e., based on HTTP path, headers, etc.)
	// If empty, the route will match all requests (i.e, a single "/" path prefix matcher)
	Matchers []*matchers.Matcher `protobuf:"bytes,1,rep,name=matchers,proto3" json:"matchers,omitempty"`
	// The Route Action Defines what action the proxy should take when a request matches the route.
	//
	// Types that are valid to be assigned to Action:
	//	*Route_RouteAction
	//	*Route_RedirectAction
	//	*Route_DirectResponseAction
	Action isRoute_Action `protobuf_oneof:"action"`
	// Route Options extend the behavior of routes.
	// Route options include configuration such as retries, rate limiting, and request/response transformation.
	Options *RouteOptions `protobuf:"bytes,5,opt,name=options,proto3" json:"options,omitempty"`
	// Metadata for the individual route
	// This data is opaque to Gloo, used
	// by controllers to track ownership of routes within a proxy
	// as they are typically generated by a controller (such as the gateway)
	Metadata *types.Struct `protobuf:"bytes,6,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// The name provides a convenience for users to be able to refer to a route by name.
	// It includes names of vs, route, and route table ancestors of the route.
	Name                 string   `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Route) Reset()         { *m = Route{} }
func (m *Route) String() string { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()    {}
func (*Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{6}
}
func (m *Route) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Route.Unmarshal(m, b)
}
func (m *Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Route.Marshal(b, m, deterministic)
}
func (m *Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route.Merge(m, src)
}
func (m *Route) XXX_Size() int {
	return xxx_messageInfo_Route.Size(m)
}
func (m *Route) XXX_DiscardUnknown() {
	xxx_messageInfo_Route.DiscardUnknown(m)
}

var xxx_messageInfo_Route proto.InternalMessageInfo

type isRoute_Action interface {
	isRoute_Action()
	Equal(interface{}) bool
}

type Route_RouteAction struct {
	RouteAction *RouteAction `protobuf:"bytes,2,opt,name=route_action,json=routeAction,proto3,oneof" json:"route_action,omitempty"`
}
type Route_RedirectAction struct {
	RedirectAction *RedirectAction `protobuf:"bytes,3,opt,name=redirect_action,json=redirectAction,proto3,oneof" json:"redirect_action,omitempty"`
}
type Route_DirectResponseAction struct {
	DirectResponseAction *DirectResponseAction `protobuf:"bytes,4,opt,name=direct_response_action,json=directResponseAction,proto3,oneof" json:"direct_response_action,omitempty"`
}

func (*Route_RouteAction) isRoute_Action()          {}
func (*Route_RedirectAction) isRoute_Action()       {}
func (*Route_DirectResponseAction) isRoute_Action() {}

func (m *Route) GetAction() isRoute_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *Route) GetMatchers() []*matchers.Matcher {
	if m != nil {
		return m.Matchers
	}
	return nil
}

func (m *Route) GetRouteAction() *RouteAction {
	if x, ok := m.GetAction().(*Route_RouteAction); ok {
		return x.RouteAction
	}
	return nil
}

func (m *Route) GetRedirectAction() *RedirectAction {
	if x, ok := m.GetAction().(*Route_RedirectAction); ok {
		return x.RedirectAction
	}
	return nil
}

func (m *Route) GetDirectResponseAction() *DirectResponseAction {
	if x, ok := m.GetAction().(*Route_DirectResponseAction); ok {
		return x.DirectResponseAction
	}
	return nil
}

func (m *Route) GetOptions() *RouteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *Route) GetMetadata() *types.Struct {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Route) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Route) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Route_RouteAction)(nil),
		(*Route_RedirectAction)(nil),
		(*Route_DirectResponseAction)(nil),
	}
}

// RouteActions are used to route matched requests to upstreams.
type RouteAction struct {
	// Defines the destination upstream for routing
	// Some destinations require additional configuration for the route (e.g. AWS upstreams require a function name
	// to be specified).
	//
	// Types that are valid to be assigned to Destination:
	//	*RouteAction_Single
	//	*RouteAction_Multi
	//	*RouteAction_UpstreamGroup
	Destination          isRouteAction_Destination `protobuf_oneof:"destination"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *RouteAction) Reset()         { *m = RouteAction{} }
func (m *RouteAction) String() string { return proto.CompactTextString(m) }
func (*RouteAction) ProtoMessage()    {}
func (*RouteAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{7}
}
func (m *RouteAction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RouteAction.Unmarshal(m, b)
}
func (m *RouteAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RouteAction.Marshal(b, m, deterministic)
}
func (m *RouteAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteAction.Merge(m, src)
}
func (m *RouteAction) XXX_Size() int {
	return xxx_messageInfo_RouteAction.Size(m)
}
func (m *RouteAction) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteAction.DiscardUnknown(m)
}

var xxx_messageInfo_RouteAction proto.InternalMessageInfo

type isRouteAction_Destination interface {
	isRouteAction_Destination()
	Equal(interface{}) bool
}

type RouteAction_Single struct {
	Single *Destination `protobuf:"bytes,1,opt,name=single,proto3,oneof" json:"single,omitempty"`
}
type RouteAction_Multi struct {
	Multi *MultiDestination `protobuf:"bytes,2,opt,name=multi,proto3,oneof" json:"multi,omitempty"`
}
type RouteAction_UpstreamGroup struct {
	UpstreamGroup *core.ResourceRef `protobuf:"bytes,3,opt,name=upstream_group,json=upstreamGroup,proto3,oneof" json:"upstream_group,omitempty"`
}

func (*RouteAction_Single) isRouteAction_Destination()        {}
func (*RouteAction_Multi) isRouteAction_Destination()         {}
func (*RouteAction_UpstreamGroup) isRouteAction_Destination() {}

func (m *RouteAction) GetDestination() isRouteAction_Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *RouteAction) GetSingle() *Destination {
	if x, ok := m.GetDestination().(*RouteAction_Single); ok {
		return x.Single
	}
	return nil
}

func (m *RouteAction) GetMulti() *MultiDestination {
	if x, ok := m.GetDestination().(*RouteAction_Multi); ok {
		return x.Multi
	}
	return nil
}

func (m *RouteAction) GetUpstreamGroup() *core.ResourceRef {
	if x, ok := m.GetDestination().(*RouteAction_UpstreamGroup); ok {
		return x.UpstreamGroup
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RouteAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RouteAction_Single)(nil),
		(*RouteAction_Multi)(nil),
		(*RouteAction_UpstreamGroup)(nil),
	}
}

// Destinations define routable destinations for proxied requests.
type Destination struct {
	//  The type of the destination
	//
	// Types that are valid to be assigned to DestinationType:
	//	*Destination_Upstream
	//	*Destination_Kube
	//	*Destination_Consul
	DestinationType isDestination_DestinationType `protobuf_oneof:"destination_type"`
	// Some upstreams utilize options which require or permit additional configuration on routes targeting them.
	// gRPC upstreams, for example, allow specifying REST-style parameters for JSON-to-gRPC transcoding in the
	// destination config. If the destination config is required for the upstream and not provided by the user,
	// Gloo will invalidate the destination and its parent resources.
	DestinationSpec *DestinationSpec `protobuf:"bytes,2,opt,name=destination_spec,json=destinationSpec,proto3" json:"destination_spec,omitempty"`
	// If specified, traffic will only be routed to a subset of the upstream. If upstream doesn't
	// contain the specified subset, we will fallback to normal upstream routing.
	Subset               *Subset  `protobuf:"bytes,3,opt,name=subset,proto3" json:"subset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Destination) Reset()         { *m = Destination{} }
func (m *Destination) String() string { return proto.CompactTextString(m) }
func (*Destination) ProtoMessage()    {}
func (*Destination) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{8}
}
func (m *Destination) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Destination.Unmarshal(m, b)
}
func (m *Destination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Destination.Marshal(b, m, deterministic)
}
func (m *Destination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Destination.Merge(m, src)
}
func (m *Destination) XXX_Size() int {
	return xxx_messageInfo_Destination.Size(m)
}
func (m *Destination) XXX_DiscardUnknown() {
	xxx_messageInfo_Destination.DiscardUnknown(m)
}

var xxx_messageInfo_Destination proto.InternalMessageInfo

type isDestination_DestinationType interface {
	isDestination_DestinationType()
	Equal(interface{}) bool
}

type Destination_Upstream struct {
	Upstream *core.ResourceRef `protobuf:"bytes,10,opt,name=upstream,proto3,oneof" json:"upstream,omitempty"`
}
type Destination_Kube struct {
	Kube *KubernetesServiceDestination `protobuf:"bytes,11,opt,name=kube,proto3,oneof" json:"kube,omitempty"`
}
type Destination_Consul struct {
	Consul *ConsulServiceDestination `protobuf:"bytes,12,opt,name=consul,proto3,oneof" json:"consul,omitempty"`
}

func (*Destination_Upstream) isDestination_DestinationType() {}
func (*Destination_Kube) isDestination_DestinationType()     {}
func (*Destination_Consul) isDestination_DestinationType()   {}

func (m *Destination) GetDestinationType() isDestination_DestinationType {
	if m != nil {
		return m.DestinationType
	}
	return nil
}

func (m *Destination) GetUpstream() *core.ResourceRef {
	if x, ok := m.GetDestinationType().(*Destination_Upstream); ok {
		return x.Upstream
	}
	return nil
}

func (m *Destination) GetKube() *KubernetesServiceDestination {
	if x, ok := m.GetDestinationType().(*Destination_Kube); ok {
		return x.Kube
	}
	return nil
}

func (m *Destination) GetConsul() *ConsulServiceDestination {
	if x, ok := m.GetDestinationType().(*Destination_Consul); ok {
		return x.Consul
	}
	return nil
}

func (m *Destination) GetDestinationSpec() *DestinationSpec {
	if m != nil {
		return m.DestinationSpec
	}
	return nil
}

func (m *Destination) GetSubset() *Subset {
	if m != nil {
		return m.Subset
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Destination) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Destination_Upstream)(nil),
		(*Destination_Kube)(nil),
		(*Destination_Consul)(nil),
	}
}

// Identifies a port on a kubernetes service to route traffic to.
type KubernetesServiceDestination struct {
	// The target service
	Ref core.ResourceRef `protobuf:"bytes,1,opt,name=ref,proto3" json:"ref"`
	// The port attribute of the service
	Port                 uint32   `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubernetesServiceDestination) Reset()         { *m = KubernetesServiceDestination{} }
func (m *KubernetesServiceDestination) String() string { return proto.CompactTextString(m) }
func (*KubernetesServiceDestination) ProtoMessage()    {}
func (*KubernetesServiceDestination) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{9}
}
func (m *KubernetesServiceDestination) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KubernetesServiceDestination.Unmarshal(m, b)
}
func (m *KubernetesServiceDestination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KubernetesServiceDestination.Marshal(b, m, deterministic)
}
func (m *KubernetesServiceDestination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesServiceDestination.Merge(m, src)
}
func (m *KubernetesServiceDestination) XXX_Size() int {
	return xxx_messageInfo_KubernetesServiceDestination.Size(m)
}
func (m *KubernetesServiceDestination) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesServiceDestination.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesServiceDestination proto.InternalMessageInfo

func (m *KubernetesServiceDestination) GetRef() core.ResourceRef {
	if m != nil {
		return m.Ref
	}
	return core.ResourceRef{}
}

func (m *KubernetesServiceDestination) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// Identifies a [Consul](https://www.consul.io/) [service](https://www.consul.io/docs/agent/services.html) to route traffic to.
// Multiple Consul services with the same name can present distinct sets of tags, listen of different ports, and live in
// multiple data centers (see an example [here](https://www.consul.io/docs/agent/services.html#multiple-service-definitions)).
// You can target the desired subset of services via the fields in this configuration. Gloo will detect the correspondent
// IP addresses and ports and load balance traffic between them.
type ConsulServiceDestination struct {
	// The name of the target service. This field is required.
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// If provided, load balance traffic only between services matching all the given tags.
	Tags []string `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
	// If provided, load balance traffic only between services running in the given
	// [data centers](https://www.consul.io/docs/internals/architecture.html).
	DataCenters          []string `protobuf:"bytes,3,rep,name=data_centers,json=dataCenters,proto3" json:"data_centers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConsulServiceDestination) Reset()         { *m = ConsulServiceDestination{} }
func (m *ConsulServiceDestination) String() string { return proto.CompactTextString(m) }
func (*ConsulServiceDestination) ProtoMessage()    {}
func (*ConsulServiceDestination) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{10}
}
func (m *ConsulServiceDestination) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConsulServiceDestination.Unmarshal(m, b)
}
func (m *ConsulServiceDestination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConsulServiceDestination.Marshal(b, m, deterministic)
}
func (m *ConsulServiceDestination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsulServiceDestination.Merge(m, src)
}
func (m *ConsulServiceDestination) XXX_Size() int {
	return xxx_messageInfo_ConsulServiceDestination.Size(m)
}
func (m *ConsulServiceDestination) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsulServiceDestination.DiscardUnknown(m)
}

var xxx_messageInfo_ConsulServiceDestination proto.InternalMessageInfo

func (m *ConsulServiceDestination) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *ConsulServiceDestination) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *ConsulServiceDestination) GetDataCenters() []string {
	if m != nil {
		return m.DataCenters
	}
	return nil
}

type UpstreamGroup struct {
	// The destinations that are part of this upstream group.
	Destinations []*WeightedDestination `protobuf:"bytes,1,rep,name=destinations,proto3" json:"destinations,omitempty"`
	// Status indicates the validation status of this resource.
	// Status is read-only by clients, and set by gloo during validation
	Status core.Status `protobuf:"bytes,6,opt,name=status,proto3" json:"status" testdiff:"ignore"`
	// Metadata contains the object metadata for this resource
	Metadata             core.Metadata `protobuf:"bytes,7,opt,name=metadata,proto3" json:"metadata"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpstreamGroup) Reset()         { *m = UpstreamGroup{} }
func (m *UpstreamGroup) String() string { return proto.CompactTextString(m) }
func (*UpstreamGroup) ProtoMessage()    {}
func (*UpstreamGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{11}
}
func (m *UpstreamGroup) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpstreamGroup.Unmarshal(m, b)
}
func (m *UpstreamGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpstreamGroup.Marshal(b, m, deterministic)
}
func (m *UpstreamGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpstreamGroup.Merge(m, src)
}
func (m *UpstreamGroup) XXX_Size() int {
	return xxx_messageInfo_UpstreamGroup.Size(m)
}
func (m *UpstreamGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_UpstreamGroup.DiscardUnknown(m)
}

var xxx_messageInfo_UpstreamGroup proto.InternalMessageInfo

func (m *UpstreamGroup) GetDestinations() []*WeightedDestination {
	if m != nil {
		return m.Destinations
	}
	return nil
}

func (m *UpstreamGroup) GetStatus() core.Status {
	if m != nil {
		return m.Status
	}
	return core.Status{}
}

func (m *UpstreamGroup) GetMetadata() core.Metadata {
	if m != nil {
		return m.Metadata
	}
	return core.Metadata{}
}

// MultiDestination is a container for a set of weighted destinations. Gloo will load balance traffic for a single
// route across multiple destinations according to their specified weights.
type MultiDestination struct {
	// This list must contain at least one destination or the listener housing this route will be invalid,
	// causing Gloo to error the parent proxy resource.
	Destinations         []*WeightedDestination `protobuf:"bytes,1,rep,name=destinations,proto3" json:"destinations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *MultiDestination) Reset()         { *m = MultiDestination{} }
func (m *MultiDestination) String() string { return proto.CompactTextString(m) }
func (*MultiDestination) ProtoMessage()    {}
func (*MultiDestination) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{12}
}
func (m *MultiDestination) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MultiDestination.Unmarshal(m, b)
}
func (m *MultiDestination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MultiDestination.Marshal(b, m, deterministic)
}
func (m *MultiDestination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiDestination.Merge(m, src)
}
func (m *MultiDestination) XXX_Size() int {
	return xxx_messageInfo_MultiDestination.Size(m)
}
func (m *MultiDestination) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiDestination.DiscardUnknown(m)
}

var xxx_messageInfo_MultiDestination proto.InternalMessageInfo

func (m *MultiDestination) GetDestinations() []*WeightedDestination {
	if m != nil {
		return m.Destinations
	}
	return nil
}

// WeightedDestination attaches a weight to a single destination.
type WeightedDestination struct {
	Destination *Destination `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	// Weight must be greater than zero
	// Routing to each destination will be balanced by the ratio of the destination's weight to the total weight on a route
	Weight uint32 `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
	// Apply configuration to traffic that is sent to this weighted destination
	Options              *WeightedDestinationOptions `protobuf:"bytes,3,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *WeightedDestination) Reset()         { *m = WeightedDestination{} }
func (m *WeightedDestination) String() string { return proto.CompactTextString(m) }
func (*WeightedDestination) ProtoMessage()    {}
func (*WeightedDestination) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{13}
}
func (m *WeightedDestination) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WeightedDestination.Unmarshal(m, b)
}
func (m *WeightedDestination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WeightedDestination.Marshal(b, m, deterministic)
}
func (m *WeightedDestination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeightedDestination.Merge(m, src)
}
func (m *WeightedDestination) XXX_Size() int {
	return xxx_messageInfo_WeightedDestination.Size(m)
}
func (m *WeightedDestination) XXX_DiscardUnknown() {
	xxx_messageInfo_WeightedDestination.DiscardUnknown(m)
}

var xxx_messageInfo_WeightedDestination proto.InternalMessageInfo

func (m *WeightedDestination) GetDestination() *Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *WeightedDestination) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *WeightedDestination) GetOptions() *WeightedDestinationOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// Notice: RedirectAction is copied directly from https://github.com/envoyproxy/envoy/blob/master/api/envoy/api/v2/route/route.proto
type RedirectAction struct {
	// The host portion of the URL will be swapped with this value.
	HostRedirect string `protobuf:"bytes,1,opt,name=host_redirect,json=hostRedirect,proto3" json:"host_redirect,omitempty"`
	// Types that are valid to be assigned to PathRewriteSpecifier:
	//	*RedirectAction_PathRedirect
	//	*RedirectAction_PrefixRewrite
	PathRewriteSpecifier isRedirectAction_PathRewriteSpecifier `protobuf_oneof:"path_rewrite_specifier"`
	// The HTTP status code to use in the redirect response. The default response
	// code is MOVED_PERMANENTLY (301).
	ResponseCode RedirectAction_RedirectResponseCode `protobuf:"varint,3,opt,name=response_code,json=responseCode,proto3,enum=gloo.solo.io.RedirectAction_RedirectResponseCode" json:"response_code,omitempty"`
	// The scheme portion of the URL will be swapped with "https".
	HttpsRedirect bool `protobuf:"varint,4,opt,name=https_redirect,json=httpsRedirect,proto3" json:"https_redirect,omitempty"`
	// Indicates that during redirection, the query portion of the URL will
	// be removed. Default value is false.
	StripQuery           bool     `protobuf:"varint,6,opt,name=strip_query,json=stripQuery,proto3" json:"strip_query,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RedirectAction) Reset()         { *m = RedirectAction{} }
func (m *RedirectAction) String() string { return proto.CompactTextString(m) }
func (*RedirectAction) ProtoMessage()    {}
func (*RedirectAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{14}
}
func (m *RedirectAction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RedirectAction.Unmarshal(m, b)
}
func (m *RedirectAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RedirectAction.Marshal(b, m, deterministic)
}
func (m *RedirectAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedirectAction.Merge(m, src)
}
func (m *RedirectAction) XXX_Size() int {
	return xxx_messageInfo_RedirectAction.Size(m)
}
func (m *RedirectAction) XXX_DiscardUnknown() {
	xxx_messageInfo_RedirectAction.DiscardUnknown(m)
}

var xxx_messageInfo_RedirectAction proto.InternalMessageInfo

type isRedirectAction_PathRewriteSpecifier interface {
	isRedirectAction_PathRewriteSpecifier()
	Equal(interface{}) bool
}

type RedirectAction_PathRedirect struct {
	PathRedirect string `protobuf:"bytes,2,opt,name=path_redirect,json=pathRedirect,proto3,oneof" json:"path_redirect,omitempty"`
}
type RedirectAction_PrefixRewrite struct {
	PrefixRewrite string `protobuf:"bytes,5,opt,name=prefix_rewrite,json=prefixRewrite,proto3,oneof" json:"prefix_rewrite,omitempty"`
}

func (*RedirectAction_PathRedirect) isRedirectAction_PathRewriteSpecifier()  {}
func (*RedirectAction_PrefixRewrite) isRedirectAction_PathRewriteSpecifier() {}

func (m *RedirectAction) GetPathRewriteSpecifier() isRedirectAction_PathRewriteSpecifier {
	if m != nil {
		return m.PathRewriteSpecifier
	}
	return nil
}

func (m *RedirectAction) GetHostRedirect() string {
	if m != nil {
		return m.HostRedirect
	}
	return ""
}

func (m *RedirectAction) GetPathRedirect() string {
	if x, ok := m.GetPathRewriteSpecifier().(*RedirectAction_PathRedirect); ok {
		return x.PathRedirect
	}
	return ""
}

func (m *RedirectAction) GetPrefixRewrite() string {
	if x, ok := m.GetPathRewriteSpecifier().(*RedirectAction_PrefixRewrite); ok {
		return x.PrefixRewrite
	}
	return ""
}

func (m *RedirectAction) GetResponseCode() RedirectAction_RedirectResponseCode {
	if m != nil {
		return m.ResponseCode
	}
	return RedirectAction_MOVED_PERMANENTLY
}

func (m *RedirectAction) GetHttpsRedirect() bool {
	if m != nil {
		return m.HttpsRedirect
	}
	return false
}

func (m *RedirectAction) GetStripQuery() bool {
	if m != nil {
		return m.StripQuery
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RedirectAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RedirectAction_PathRedirect)(nil),
		(*RedirectAction_PrefixRewrite)(nil),
	}
}

// DirectResponseAction is copied directly from https://github.com/envoyproxy/envoy/blob/master/api/envoy/api/v2/route/route.proto
type DirectResponseAction struct {
	// Specifies the HTTP response status to be returned.
	Status uint32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Specifies the content of the response body. If this setting is omitted,
	// no body is included in the generated response.
	//
	//   Note: Headers can be specified using the Header Modification feature in the enclosing
	//   Route, Virtual Host, or Listener options.
	Body                 string   `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DirectResponseAction) Reset()         { *m = DirectResponseAction{} }
func (m *DirectResponseAction) String() string { return proto.CompactTextString(m) }
func (*DirectResponseAction) ProtoMessage()    {}
func (*DirectResponseAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_83a32307df723af5, []int{15}
}
func (m *DirectResponseAction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DirectResponseAction.Unmarshal(m, b)
}
func (m *DirectResponseAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DirectResponseAction.Marshal(b, m, deterministic)
}
func (m *DirectResponseAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectResponseAction.Merge(m, src)
}
func (m *DirectResponseAction) XXX_Size() int {
	return xxx_messageInfo_DirectResponseAction.Size(m)
}
func (m *DirectResponseAction) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectResponseAction.DiscardUnknown(m)
}

var xxx_messageInfo_DirectResponseAction proto.InternalMessageInfo

func (m *DirectResponseAction) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *DirectResponseAction) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func init() {
	proto.RegisterEnum("gloo.solo.io.RedirectAction_RedirectResponseCode", RedirectAction_RedirectResponseCode_name, RedirectAction_RedirectResponseCode_value)
	proto.RegisterType((*Proxy)(nil), "gloo.solo.io.Proxy")
	proto.RegisterType((*Listener)(nil), "gloo.solo.io.Listener")
	proto.RegisterType((*TcpListener)(nil), "gloo.solo.io.TcpListener")
	proto.RegisterType((*TcpHost)(nil), "gloo.solo.io.TcpHost")
	proto.RegisterType((*TcpHost_TcpAction)(nil), "gloo.solo.io.TcpHost.TcpAction")
	proto.RegisterType((*HttpListener)(nil), "gloo.solo.io.HttpListener")
	proto.RegisterType((*VirtualHost)(nil), "gloo.solo.io.VirtualHost")
	proto.RegisterType((*Route)(nil), "gloo.solo.io.Route")
	proto.RegisterType((*RouteAction)(nil), "gloo.solo.io.RouteAction")
	proto.RegisterType((*Destination)(nil), "gloo.solo.io.Destination")
	proto.RegisterType((*KubernetesServiceDestination)(nil), "gloo.solo.io.KubernetesServiceDestination")
	proto.RegisterType((*ConsulServiceDestination)(nil), "gloo.solo.io.ConsulServiceDestination")
	proto.RegisterType((*UpstreamGroup)(nil), "gloo.solo.io.UpstreamGroup")
	proto.RegisterType((*MultiDestination)(nil), "gloo.solo.io.MultiDestination")
	proto.RegisterType((*WeightedDestination)(nil), "gloo.solo.io.WeightedDestination")
	proto.RegisterType((*RedirectAction)(nil), "gloo.solo.io.RedirectAction")
	proto.RegisterType((*DirectResponseAction)(nil), "gloo.solo.io.DirectResponseAction")
}

func init() {
	proto.RegisterFile("github.com/solo-io/solo-apis/api/gloo/gloo/v1/proxy.proto", fileDescriptor_83a32307df723af5)
}

var fileDescriptor_83a32307df723af5 = []byte{
	// 1644 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0x4b, 0x6f, 0x1b, 0xc9,
	0x11, 0xd6, 0x88, 0x14, 0x45, 0x16, 0x49, 0x3d, 0x7a, 0x25, 0xed, 0x48, 0x6b, 0x3d, 0x76, 0x36,
	0x9b, 0x15, 0xf2, 0x20, 0x21, 0xad, 0xb1, 0x8e, 0x6d, 0xc0, 0xb1, 0x28, 0xd1, 0x66, 0x62, 0xeb,
	0xe1, 0x96, 0xac, 0xc0, 0xbe, 0x0c, 0x86, 0xc3, 0x26, 0x35, 0x30, 0xc9, 0x9e, 0x74, 0xf7, 0xe8,
	0x71, 0xf5, 0x0f, 0xf1, 0x39, 0x87, 0x20, 0x67, 0x1f, 0x02, 0xe4, 0x9a, 0x4b, 0xae, 0xb9, 0x04,
	0x70, 0x80, 0xfc, 0x03, 0x05, 0xc8, 0x2d, 0x87, 0xa0, 0x7b, 0x7a, 0x86, 0x33, 0x14, 0x45, 0xc3,
	0x80, 0x0f, 0xd9, 0x8b, 0xd8, 0x5d, 0xaf, 0xae, 0xae, 0xfa, 0xaa, 0xaa, 0x47, 0x70, 0xbf, 0xe3,
	0x89, 0xb3, 0xa0, 0x59, 0x71, 0x69, 0xaf, 0xca, 0x69, 0x97, 0xfe, 0xd2, 0xa3, 0xe1, 0xaf, 0xe3,
	0x7b, 0xbc, 0xea, 0xf8, 0x5e, 0xb5, 0xd3, 0xa5, 0x34, 0xfc, 0x73, 0xbe, 0x55, 0xf5, 0x19, 0xbd,
	0xbc, 0xaa, 0xf8, 0x8c, 0x0a, 0x8a, 0x4a, 0x92, 0x58, 0x91, 0xc2, 0x15, 0x8f, 0xae, 0xac, 0x75,
	0x28, 0xed, 0x74, 0x49, 0x55, 0xf1, 0x9a, 0x41, 0xbb, 0x7a, 0xc1, 0x1c, 0xdf, 0x27, 0x8c, 0x87,
	0xd2, 0x2b, 0x5f, 0x0d, 0xf3, 0x49, 0xcf, 0x17, 0xda, 0xd4, 0xca, 0x9d, 0x61, 0x26, 0x17, 0x2c,
	0x70, 0x85, 0xe6, 0x2e, 0x74, 0x68, 0x87, 0xaa, 0x65, 0x55, 0xae, 0x34, 0x15, 0x91, 0x4b, 0x11,
	0x12, 0xc9, 0x65, 0x24, 0xb9, 0xa6, 0x5c, 0x7f, 0xe3, 0x09, 0xe5, 0xf9, 0xf9, 0x56, 0xb5, 0x47,
	0x84, 0xd3, 0x72, 0x84, 0x13, 0x9d, 0x33, 0xcc, 0xe7, 0xc2, 0x11, 0x41, 0xe4, 0xe2, 0xf2, 0x30,
	0x97, 0x91, 0xf6, 0x6d, 0x86, 0xa3, 0xbd, 0xe6, 0xff, 0x64, 0x4c, 0xcc, 0x38, 0xef, 0x6a, 0xa9,
	0xef, 0xc6, 0x49, 0x05, 0x4d, 0x4e, 0x22, 0x73, 0x9b, 0x63, 0x04, 0xa9, 0x2f, 0x3c, 0xda, 0x8f,
	0x7c, 0xbe, 0x37, 0x46, 0xd2, 0xa5, 0x8c, 0x54, 0x7b, 0x8e, 0x70, 0xcf, 0x08, 0xe3, 0xf1, 0x22,
	0x54, 0xb4, 0xfe, 0x61, 0xc0, 0xd4, 0x91, 0xcc, 0x26, 0xba, 0x0b, 0x85, 0xae, 0xc7, 0x05, 0xe9,
	0x13, 0xc6, 0xcd, 0xc9, 0x8d, 0xcc, 0x66, 0x71, 0x7b, 0xa9, 0x92, 0xcc, 0x6d, 0xe5, 0xb9, 0x66,
	0xe3, 0x81, 0x20, 0x7a, 0x06, 0xb9, 0x30, 0x78, 0x66, 0x6e, 0xc3, 0xd8, 0x2c, 0x6e, 0x2f, 0x54,
	0xe4, 0x71, 0xb1, 0xca, 0xb1, 0xe2, 0xd5, 0x56, 0xdf, 0xff, 0x27, 0x6b, 0xfc, 0xf5, 0xc3, 0xfa,
	0xc4, 0xbf, 0x3f, 0xac, 0xcf, 0x0b, 0xc2, 0x45, 0xcb, 0x6b, 0xb7, 0x1f, 0x58, 0x5e, 0xa7, 0x4f,
	0x19, 0xb1, 0xb0, 0x36, 0x81, 0x7e, 0x05, 0xf9, 0x28, 0x53, 0xe6, 0xb4, 0x32, 0xb7, 0x94, 0x36,
	0xb7, 0xaf, 0xb9, 0xb5, 0xac, 0x34, 0x86, 0x63, 0xe9, 0x07, 0x8b, 0x6f, 0xaf, 0xb3, 0x59, 0x98,
	0xf4, 0x2f, 0xdf, 0x5e, 0x67, 0x0b, 0x68, 0x5a, 0xe2, 0xd3, 0x23, 0xdc, 0xba, 0xce, 0x40, 0x3e,
	0xf2, 0x1a, 0x21, 0xc8, 0xf6, 0x9d, 0x1e, 0x31, 0x8d, 0x0d, 0x63, 0xb3, 0x80, 0xd5, 0x1a, 0x7d,
	0x0d, 0xa5, 0xa6, 0xd7, 0x6f, 0xd9, 0x4e, 0xab, 0xc5, 0x08, 0x97, 0xf7, 0x96, 0xbc, 0xa2, 0xa4,
	0xed, 0x84, 0x24, 0xf4, 0x15, 0x14, 0x94, 0x88, 0x4f, 0x99, 0x30, 0x33, 0x1b, 0xc6, 0x66, 0x19,
	0xe7, 0x25, 0xe1, 0x88, 0x32, 0x81, 0x76, 0xa0, 0x7c, 0x26, 0x84, 0x6f, 0x47, 0x01, 0x31, 0xb3,
	0xca, 0xed, 0x95, 0x74, 0xe0, 0x1a, 0x42, 0xf8, 0x91, 0x1b, 0x8d, 0x09, 0x5c, 0x3a, 0x4b, 0xec,
	0xd1, 0x23, 0x28, 0x09, 0x37, 0x61, 0x61, 0x4a, 0x59, 0x58, 0x4e, 0x5b, 0x38, 0x71, 0x93, 0x06,
	0x8a, 0x62, 0xb0, 0x45, 0x4f, 0x00, 0x71, 0xde, 0xb5, 0x5d, 0xda, 0x6f, 0x7b, 0x9d, 0x80, 0x39,
	0x0a, 0x16, 0x66, 0x4e, 0x25, 0xf0, 0xcb, 0xb4, 0x95, 0x63, 0xde, 0xdd, 0x55, 0x62, 0x78, 0x9e,
	0x47, 0xcb, 0x48, 0x03, 0xd5, 0x60, 0x36, 0xe0, 0xc4, 0x56, 0xa5, 0x6d, 0x2b, 0x70, 0xe8, 0x1c,
	0xac, 0x54, 0xc2, 0xb2, 0xac, 0x44, 0x65, 0x59, 0xa9, 0x51, 0xda, 0x3d, 0x75, 0xba, 0x01, 0xc1,
	0xe5, 0x80, 0x13, 0x05, 0x9f, 0x23, 0xd5, 0x0b, 0xee, 0xc1, 0xb4, 0xc6, 0xa5, 0x99, 0x57, 0xba,
	0xab, 0xa3, 0x11, 0x74, 0x18, 0x0a, 0xe1, 0x48, 0x1a, 0xdd, 0x4f, 0x64, 0xbe, 0xa0, 0x34, 0xbf,
	0xbc, 0x71, 0xea, 0xb1, 0x6a, 0x06, 0xb5, 0xac, 0xc4, 0xd2, 0x20, 0xf5, 0xb5, 0x19, 0x28, 0x45,
	0x66, 0x4f, 0xae, 0x7c, 0x62, 0xbd, 0x33, 0xa0, 0x98, 0x08, 0x17, 0xda, 0x86, 0x82, 0x8c, 0xef,
	0x19, 0xe5, 0x82, 0x9b, 0x86, 0x0a, 0xcb, 0xe2, 0x8d, 0xe0, 0x36, 0x28, 0x17, 0x38, 0x2f, 0xc2,
	0x05, 0x47, 0x0f, 0x86, 0xef, 0xb1, 0x71, 0x6b, 0x3a, 0x6e, 0x5c, 0x65, 0x1d, 0x8a, 0x12, 0xce,
	0xb6, 0xcf, 0x48, 0xdb, 0xbb, 0x54, 0x88, 0x29, 0x60, 0x90, 0xa4, 0x23, 0x45, 0xb1, 0xfe, 0x92,
	0x81, 0x69, 0x7d, 0xe4, 0x48, 0x4c, 0xfe, 0x00, 0x30, 0x48, 0xa8, 0xd2, 0x1f, 0x93, 0xc8, 0x42,
	0x9c, 0x48, 0xb4, 0x03, 0xc5, 0x16, 0xe1, 0xc2, 0xeb, 0xab, 0x84, 0x6a, 0x24, 0xae, 0x8f, 0xbc,
	0xaa, 0xfc, 0xdd, 0x71, 0xa5, 0x18, 0x4e, 0xea, 0xac, 0xbc, 0x9b, 0x84, 0x42, 0xcc, 0x42, 0xdf,
	0x43, 0x8e, 0x7b, 0xfd, 0x4e, 0x37, 0x74, 0xef, 0x06, 0x26, 0xf7, 0x06, 0x8a, 0x8d, 0x09, 0xac,
	0x45, 0xd1, 0x0f, 0x30, 0xd5, 0x0b, 0xba, 0xc2, 0x53, 0xa5, 0x54, 0xdc, 0x5e, 0x4b, 0xeb, 0xec,
	0x4b, 0x56, 0x5a, 0x31, 0x14, 0x47, 0x35, 0x98, 0x09, 0x7c, 0x2e, 0x18, 0x71, 0x7a, 0x76, 0x87,
	0xd1, 0xc0, 0xd7, 0x37, 0x5f, 0x4e, 0x77, 0x00, 0x4c, 0x38, 0x0d, 0x98, 0x4b, 0x30, 0x69, 0x37,
	0x26, 0x70, 0x39, 0x52, 0x79, 0x2a, 0x35, 0xd0, 0x0b, 0x30, 0xdb, 0x94, 0x5d, 0x38, 0xac, 0x65,
	0xf3, 0xbe, 0x67, 0xbb, 0xdd, 0x80, 0x0b, 0xc2, 0x6c, 0x15, 0xe1, 0xac, 0xee, 0x27, 0xc3, 0xa8,
	0xaa, 0xcb, 0xf9, 0xd3, 0x98, 0xc0, 0x8b, 0x5a, 0xf3, 0xb8, 0xef, 0xed, 0x86, 0x7a, 0x07, 0x4e,
	0x8f, 0xd4, 0xca, 0xa9, 0xa0, 0xfe, 0x36, 0x9b, 0x9f, 0x9c, 0xcb, 0x58, 0x7f, 0x34, 0xa0, 0xd4,
	0x48, 0xd7, 0x70, 0xf9, 0xdc, 0x63, 0x22, 0x70, 0xba, 0x29, 0x9c, 0x0d, 0x05, 0xec, 0x34, 0x14,
	0x51, 0x58, 0x2b, 0x9d, 0x0f, 0x36, 0x1c, 0x3d, 0x1c, 0xe0, 0x2d, 0x0c, 0xdb, 0xd7, 0xb7, 0x37,
	0x90, 0x4f, 0x07, 0xdc, 0x3f, 0x0d, 0x28, 0x26, 0xce, 0x1e, 0x09, 0x3a, 0x13, 0xa6, 0x5b, 0xb4,
	0xe7, 0x78, 0xfd, 0xb0, 0xf7, 0x17, 0x70, 0xb4, 0x45, 0x3f, 0x87, 0x1c, 0xa3, 0x81, 0x20, 0xdc,
	0xcc, 0xa8, 0x4b, 0x7d, 0x91, 0x76, 0x0d, 0x4b, 0x1e, 0xd6, 0x22, 0xc9, 0xc2, 0xc9, 0x8e, 0x2a,
	0x9c, 0x84, 0x1b, 0x63, 0x7b, 0x40, 0xee, 0x93, 0x7a, 0x80, 0xf5, 0xe7, 0x0c, 0x4c, 0x29, 0x47,
	0xd0, 0xaf, 0x21, 0x1f, 0x4d, 0x38, 0x9d, 0x84, 0x6f, 0x2a, 0xf1, 0xc8, 0x53, 0x48, 0x4a, 0xe3,
	0x31, 0x64, 0xe1, 0x58, 0x49, 0xb6, 0x63, 0x75, 0x17, 0xdb, 0x51, 0x45, 0xa0, 0xf3, 0xb1, 0x3c,
	0xe2, 0xd2, 0x61, 0x95, 0xc8, 0x76, 0xcc, 0x06, 0x5b, 0xf4, 0x14, 0x66, 0x19, 0x69, 0x79, 0x8c,
	0xb8, 0x22, 0x32, 0x11, 0x02, 0xf9, 0xce, 0x90, 0x09, 0x2d, 0x14, 0x5b, 0x99, 0x61, 0x29, 0x0a,
	0x7a, 0x0d, 0x4b, 0xda, 0x0c, 0x23, 0xdc, 0xa7, 0x7d, 0x1e, 0xbb, 0x14, 0x46, 0xd6, 0x1a, 0xaa,
	0x46, 0x25, 0x8b, 0xb5, 0x68, 0x6c, 0x75, 0xa1, 0x35, 0x82, 0x8e, 0xee, 0x0e, 0xd2, 0x34, 0x35,
	0x6a, 0x60, 0xa9, 0xfb, 0x7d, 0xc6, 0x04, 0xc5, 0x90, 0x9b, 0x1e, 0x40, 0xae, 0x96, 0x87, 0x5c,
	0x78, 0x21, 0xeb, 0x6f, 0x06, 0x14, 0x13, 0x21, 0xfd, 0xd1, 0x35, 0x9e, 0xa1, 0x2e, 0x61, 0xfd,
	0x7d, 0x12, 0x8a, 0x89, 0xb3, 0xd0, 0x3d, 0xc8, 0x47, 0xf2, 0x26, 0x7c, 0xdc, 0x78, 0x2c, 0x8c,
	0x1e, 0x43, 0xf6, 0x4d, 0xd0, 0x24, 0x66, 0x51, 0x29, 0xfd, 0x2c, 0x7d, 0xa5, 0x67, 0x41, 0x93,
	0xb0, 0x3e, 0x11, 0x84, 0x1f, 0x13, 0x76, 0xee, 0xb9, 0x24, 0x7d, 0x3d, 0xa5, 0x89, 0x1e, 0x43,
	0xce, 0xa5, 0x7d, 0x1e, 0x74, 0xcd, 0x92, 0xb2, 0xf1, 0xd3, 0xb4, 0x8d, 0x5d, 0xc5, 0x1b, 0xa9,
	0xaf, 0xf5, 0x50, 0x03, 0xe6, 0x12, 0x77, 0xb3, 0xb9, 0x4f, 0x5c, 0x1d, 0xe2, 0xd5, 0x5b, 0xd3,
	0x72, 0xec, 0x13, 0x17, 0xcf, 0xb6, 0xd2, 0x04, 0xf4, 0x0b, 0xc8, 0x85, 0xcf, 0x5b, 0x1d, 0xe1,
	0x85, 0xa1, 0xa1, 0xa6, 0x78, 0x58, 0xcb, 0xd4, 0x50, 0xfa, 0x5c, 0x21, 0x67, 0x3b, 0x81, 0x3b,
	0xe3, 0x6e, 0x8d, 0xb6, 0x20, 0xc3, 0x48, 0x3b, 0x46, 0xcd, 0x6d, 0x31, 0xd6, 0xcf, 0x47, 0x29,
	0x2b, 0x91, 0xa9, 0x5e, 0x76, 0x93, 0xea, 0x65, 0xa7, 0xd6, 0x96, 0x00, 0xf3, 0xb6, 0xc0, 0xc8,
	0x17, 0x23, 0x0f, 0xa9, 0x76, 0xa2, 0x89, 0x16, 0x35, 0x4d, 0xce, 0x0c, 0x69, 0x52, 0x38, 0x9d,
	0xa8, 0x91, 0xaa, 0xb5, 0x54, 0x93, 0x85, 0x60, 0xbb, 0xa4, 0x2f, 0x64, 0x6f, 0xca, 0x28, 0x5e,
	0x51, 0xd2, 0x76, 0x43, 0x92, 0xf5, 0x5f, 0x03, 0xca, 0x2f, 0x53, 0xf3, 0xac, 0x0e, 0xa5, 0x44,
	0x08, 0xa2, 0x86, 0x36, 0x34, 0x1b, 0x7e, 0x47, 0xbc, 0xce, 0x99, 0x20, 0xad, 0x84, 0x93, 0x38,
	0xa5, 0xf6, 0xff, 0xf2, 0x46, 0x5f, 0x0d, 0xdf, 0xe8, 0x41, 0xe7, 0xed, 0x75, 0x76, 0x1e, 0xcd,
	0xa6, 0x8b, 0x8e, 0x5b, 0xaf, 0x60, 0x6e, 0xb8, 0x48, 0x3f, 0x53, 0x00, 0xac, 0x3f, 0x19, 0xf0,
	0xc5, 0x08, 0x29, 0xf4, 0x30, 0xfd, 0x62, 0xfa, 0x58, 0xb3, 0x49, 0xbd, 0x95, 0xd0, 0x12, 0xe4,
	0x2e, 0x94, 0x4d, 0x0d, 0x1d, 0xbd, 0x43, 0xb5, 0x41, 0x6f, 0x0d, 0x61, 0xbe, 0xf9, 0x51, 0x77,
	0x87, 0x3b, 0xad, 0xf5, 0x3e, 0x03, 0x33, 0xe9, 0x01, 0x81, 0xbe, 0x81, 0xb2, 0x7c, 0x5a, 0xd8,
	0xd1, 0x94, 0xd0, 0xc0, 0x2b, 0x49, 0x62, 0x24, 0x8a, 0xbe, 0x85, 0xb2, 0xef, 0x88, 0xb3, 0x81,
	0x90, 0xfa, 0x9e, 0x91, 0x9f, 0x1c, 0x92, 0x1c, 0x8b, 0x7d, 0x07, 0x33, 0xe1, 0x63, 0xc1, 0x66,
	0xe4, 0x82, 0x79, 0x82, 0xa8, 0x29, 0x20, 0xe5, 0xca, 0x21, 0x1d, 0x87, 0x64, 0x74, 0x0a, 0xe5,
	0x78, 0xf8, 0xb8, 0xb4, 0x45, 0xd4, 0x8d, 0x66, 0xb6, 0xb7, 0xc6, 0x8d, 0xb2, 0x78, 0x1b, 0xcd,
	0x9c, 0x5d, 0xda, 0x22, 0xb8, 0xc4, 0x12, 0x3b, 0xf4, 0x2d, 0xcc, 0xc8, 0x6f, 0x20, 0x3e, 0x70,
	0x54, 0xce, 0xb4, 0x3c, 0x56, 0x1f, 0x53, 0x3c, 0xf6, 0x53, 0xbd, 0x6c, 0x98, 0xe7, 0xdb, 0xbf,
	0x0f, 0x08, 0xbb, 0x52, 0xe8, 0xcd, 0xcb, 0x97, 0x0d, 0xf3, 0xfc, 0x17, 0x92, 0x62, 0x5d, 0xc0,
	0xc2, 0xa8, 0xd3, 0xd0, 0x22, 0xcc, 0xef, 0x1f, 0x9e, 0xd6, 0xf7, 0xec, 0xa3, 0x3a, 0xde, 0xdf,
	0x39, 0xa8, 0x1f, 0x9c, 0x3c, 0x7f, 0x35, 0x37, 0x81, 0x0a, 0x30, 0xf5, 0xe4, 0xf0, 0xe5, 0xc1,
	0xde, 0x9c, 0x81, 0xca, 0x50, 0x38, 0xae, 0xd7, 0xed, 0xc3, 0x93, 0x46, 0x1d, 0xcf, 0x4d, 0xa2,
	0x25, 0x40, 0x27, 0xf5, 0xfd, 0xa3, 0x43, 0xbc, 0x83, 0x5f, 0xd9, 0xb8, 0xbe, 0xf7, 0x1b, 0x5c,
	0xdf, 0x3d, 0x99, 0xcb, 0x48, 0x7a, 0x6c, 0x62, 0x40, 0xcf, 0xd6, 0x4c, 0x58, 0xd2, 0x81, 0x56,
	0x81, 0x52, 0x5d, 0xd1, 0x6b, 0x7b, 0x84, 0x59, 0x35, 0x58, 0x18, 0x35, 0x8a, 0x25, 0x5c, 0x74,
	0x11, 0x1a, 0x21, 0x5c, 0x74, 0x3d, 0x21, 0xc8, 0x36, 0x69, 0xeb, 0x4a, 0x7f, 0x79, 0xaa, 0x75,
	0xed, 0x91, 0x2c, 0xc5, 0x3f, 0xfc, 0x6b, 0xcd, 0x78, 0x7d, 0x77, 0xec, 0xff, 0x65, 0xfc, 0x37,
	0x9d, 0xf8, 0x73, 0x3f, 0xca, 0x46, 0xf5, 0x7c, 0xab, 0x99, 0x53, 0xe3, 0xf8, 0xfb, 0xff, 0x05,
	0x00, 0x00, 0xff, 0xff, 0x80, 0xb9, 0xd4, 0x0f, 0xd6, 0x11, 0x00, 0x00,
}

func (this *Proxy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Proxy)
	if !ok {
		that2, ok := that.(Proxy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Listeners) != len(that1.Listeners) {
		return false
	}
	for i := range this.Listeners {
		if !this.Listeners[i].Equal(that1.Listeners[i]) {
			return false
		}
	}
	if !this.Status.Equal(&that1.Status) {
		return false
	}
	if !this.Metadata.Equal(&that1.Metadata) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Listener) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Listener)
	if !ok {
		that2, ok := that.(Listener)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.BindAddress != that1.BindAddress {
		return false
	}
	if this.BindPort != that1.BindPort {
		return false
	}
	if that1.ListenerType == nil {
		if this.ListenerType != nil {
			return false
		}
	} else if this.ListenerType == nil {
		return false
	} else if !this.ListenerType.Equal(that1.ListenerType) {
		return false
	}
	if len(this.SslConfigurations) != len(that1.SslConfigurations) {
		return false
	}
	for i := range this.SslConfigurations {
		if !this.SslConfigurations[i].Equal(that1.SslConfigurations[i]) {
			return false
		}
	}
	if !this.UseProxyProto.Equal(that1.UseProxyProto) {
		return false
	}
	if !this.Options.Equal(that1.Options) {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Listener_HttpListener) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Listener_HttpListener)
	if !ok {
		that2, ok := that.(Listener_HttpListener)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HttpListener.Equal(that1.HttpListener) {
		return false
	}
	return true
}
func (this *Listener_TcpListener) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Listener_TcpListener)
	if !ok {
		that2, ok := that.(Listener_TcpListener)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TcpListener.Equal(that1.TcpListener) {
		return false
	}
	return true
}
func (this *TcpListener) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TcpListener)
	if !ok {
		that2, ok := that.(TcpListener)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.TcpHosts) != len(that1.TcpHosts) {
		return false
	}
	for i := range this.TcpHosts {
		if !this.TcpHosts[i].Equal(that1.TcpHosts[i]) {
			return false
		}
	}
	if !this.Options.Equal(that1.Options) {
		return false
	}
	if this.StatPrefix != that1.StatPrefix {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TcpHost) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TcpHost)
	if !ok {
		that2, ok := that.(TcpHost)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.SslConfig.Equal(that1.SslConfig) {
		return false
	}
	if !this.Destination.Equal(that1.Destination) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TcpHost_TcpAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TcpHost_TcpAction)
	if !ok {
		that2, ok := that.(TcpHost_TcpAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Destination == nil {
		if this.Destination != nil {
			return false
		}
	} else if this.Destination == nil {
		return false
	} else if !this.Destination.Equal(that1.Destination) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TcpHost_TcpAction_Single) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TcpHost_TcpAction_Single)
	if !ok {
		that2, ok := that.(TcpHost_TcpAction_Single)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Single.Equal(that1.Single) {
		return false
	}
	return true
}
func (this *TcpHost_TcpAction_Multi) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TcpHost_TcpAction_Multi)
	if !ok {
		that2, ok := that.(TcpHost_TcpAction_Multi)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Multi.Equal(that1.Multi) {
		return false
	}
	return true
}
func (this *TcpHost_TcpAction_UpstreamGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TcpHost_TcpAction_UpstreamGroup)
	if !ok {
		that2, ok := that.(TcpHost_TcpAction_UpstreamGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UpstreamGroup.Equal(that1.UpstreamGroup) {
		return false
	}
	return true
}
func (this *TcpHost_TcpAction_ForwardSniClusterName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TcpHost_TcpAction_ForwardSniClusterName)
	if !ok {
		that2, ok := that.(TcpHost_TcpAction_ForwardSniClusterName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ForwardSniClusterName.Equal(that1.ForwardSniClusterName) {
		return false
	}
	return true
}
func (this *HttpListener) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HttpListener)
	if !ok {
		that2, ok := that.(HttpListener)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VirtualHosts) != len(that1.VirtualHosts) {
		return false
	}
	for i := range this.VirtualHosts {
		if !this.VirtualHosts[i].Equal(that1.VirtualHosts[i]) {
			return false
		}
	}
	if !this.Options.Equal(that1.Options) {
		return false
	}
	if this.StatPrefix != that1.StatPrefix {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VirtualHost) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualHost)
	if !ok {
		that2, ok := that.(VirtualHost)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	if !this.Options.Equal(that1.Options) {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Route) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Route)
	if !ok {
		that2, ok := that.(Route)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Matchers) != len(that1.Matchers) {
		return false
	}
	for i := range this.Matchers {
		if !this.Matchers[i].Equal(that1.Matchers[i]) {
			return false
		}
	}
	if that1.Action == nil {
		if this.Action != nil {
			return false
		}
	} else if this.Action == nil {
		return false
	} else if !this.Action.Equal(that1.Action) {
		return false
	}
	if !this.Options.Equal(that1.Options) {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Route_RouteAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Route_RouteAction)
	if !ok {
		that2, ok := that.(Route_RouteAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RouteAction.Equal(that1.RouteAction) {
		return false
	}
	return true
}
func (this *Route_RedirectAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Route_RedirectAction)
	if !ok {
		that2, ok := that.(Route_RedirectAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RedirectAction.Equal(that1.RedirectAction) {
		return false
	}
	return true
}
func (this *Route_DirectResponseAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Route_DirectResponseAction)
	if !ok {
		that2, ok := that.(Route_DirectResponseAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DirectResponseAction.Equal(that1.DirectResponseAction) {
		return false
	}
	return true
}
func (this *RouteAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteAction)
	if !ok {
		that2, ok := that.(RouteAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Destination == nil {
		if this.Destination != nil {
			return false
		}
	} else if this.Destination == nil {
		return false
	} else if !this.Destination.Equal(that1.Destination) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RouteAction_Single) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteAction_Single)
	if !ok {
		that2, ok := that.(RouteAction_Single)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Single.Equal(that1.Single) {
		return false
	}
	return true
}
func (this *RouteAction_Multi) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteAction_Multi)
	if !ok {
		that2, ok := that.(RouteAction_Multi)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Multi.Equal(that1.Multi) {
		return false
	}
	return true
}
func (this *RouteAction_UpstreamGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteAction_UpstreamGroup)
	if !ok {
		that2, ok := that.(RouteAction_UpstreamGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UpstreamGroup.Equal(that1.UpstreamGroup) {
		return false
	}
	return true
}
func (this *Destination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Destination)
	if !ok {
		that2, ok := that.(Destination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DestinationType == nil {
		if this.DestinationType != nil {
			return false
		}
	} else if this.DestinationType == nil {
		return false
	} else if !this.DestinationType.Equal(that1.DestinationType) {
		return false
	}
	if !this.DestinationSpec.Equal(that1.DestinationSpec) {
		return false
	}
	if !this.Subset.Equal(that1.Subset) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Destination_Upstream) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Destination_Upstream)
	if !ok {
		that2, ok := that.(Destination_Upstream)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Upstream.Equal(that1.Upstream) {
		return false
	}
	return true
}
func (this *Destination_Kube) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Destination_Kube)
	if !ok {
		that2, ok := that.(Destination_Kube)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Kube.Equal(that1.Kube) {
		return false
	}
	return true
}
func (this *Destination_Consul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Destination_Consul)
	if !ok {
		that2, ok := that.(Destination_Consul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Consul.Equal(that1.Consul) {
		return false
	}
	return true
}
func (this *KubernetesServiceDestination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KubernetesServiceDestination)
	if !ok {
		that2, ok := that.(KubernetesServiceDestination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ref.Equal(&that1.Ref) {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ConsulServiceDestination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulServiceDestination)
	if !ok {
		that2, ok := that.(ConsulServiceDestination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if len(this.DataCenters) != len(that1.DataCenters) {
		return false
	}
	for i := range this.DataCenters {
		if this.DataCenters[i] != that1.DataCenters[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *UpstreamGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpstreamGroup)
	if !ok {
		that2, ok := that.(UpstreamGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Destinations) != len(that1.Destinations) {
		return false
	}
	for i := range this.Destinations {
		if !this.Destinations[i].Equal(that1.Destinations[i]) {
			return false
		}
	}
	if !this.Status.Equal(&that1.Status) {
		return false
	}
	if !this.Metadata.Equal(&that1.Metadata) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *MultiDestination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MultiDestination)
	if !ok {
		that2, ok := that.(MultiDestination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Destinations) != len(that1.Destinations) {
		return false
	}
	for i := range this.Destinations {
		if !this.Destinations[i].Equal(that1.Destinations[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *WeightedDestination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WeightedDestination)
	if !ok {
		that2, ok := that.(WeightedDestination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Destination.Equal(that1.Destination) {
		return false
	}
	if this.Weight != that1.Weight {
		return false
	}
	if !this.Options.Equal(that1.Options) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RedirectAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RedirectAction)
	if !ok {
		that2, ok := that.(RedirectAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HostRedirect != that1.HostRedirect {
		return false
	}
	if that1.PathRewriteSpecifier == nil {
		if this.PathRewriteSpecifier != nil {
			return false
		}
	} else if this.PathRewriteSpecifier == nil {
		return false
	} else if !this.PathRewriteSpecifier.Equal(that1.PathRewriteSpecifier) {
		return false
	}
	if this.ResponseCode != that1.ResponseCode {
		return false
	}
	if this.HttpsRedirect != that1.HttpsRedirect {
		return false
	}
	if this.StripQuery != that1.StripQuery {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RedirectAction_PathRedirect) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RedirectAction_PathRedirect)
	if !ok {
		that2, ok := that.(RedirectAction_PathRedirect)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathRedirect != that1.PathRedirect {
		return false
	}
	return true
}
func (this *RedirectAction_PrefixRewrite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RedirectAction_PrefixRewrite)
	if !ok {
		that2, ok := that.(RedirectAction_PrefixRewrite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PrefixRewrite != that1.PrefixRewrite {
		return false
	}
	return true
}
func (this *DirectResponseAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectResponseAction)
	if !ok {
		that2, ok := that.(DirectResponseAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Body != that1.Body {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
