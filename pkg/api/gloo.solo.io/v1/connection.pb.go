// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/solo-io/solo-apis/api/gloo/gloo/v1/connection.proto

package v1

import (
	bytes "bytes"
	fmt "fmt"
	math "math"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "github.com/solo-io/protoc-gen-ext/extproto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Fine tune the settings for connections to an upstream
type ConnectionConfig struct {
	// Maximum requests for a single upstream connection (unspecified or zero = no limit)
	MaxRequestsPerConnection uint32 `protobuf:"varint,1,opt,name=max_requests_per_connection,json=maxRequestsPerConnection,proto3" json:"max_requests_per_connection,omitempty"`
	// The timeout for new network connections to hosts in the cluster
	ConnectTimeout *time.Duration `protobuf:"bytes,2,opt,name=connect_timeout,json=connectTimeout,proto3,stdduration" json:"connect_timeout,omitempty"`
	// Configure OS-level tcp keepalive checks
	TcpKeepalive *ConnectionConfig_TcpKeepAlive `protobuf:"bytes,3,opt,name=tcp_keepalive,json=tcpKeepalive,proto3" json:"tcp_keepalive,omitempty"`
	// Soft limit on size of the clusterâ€™s connections read and write buffers. If unspecified, an implementation defined default is applied (1MiB).
	// For more info, see the [envoy docs](https://www.envoyproxy.io/docs/envoy/v1.14.1/api-v2/api/v2/cluster.proto#cluster)
	PerConnectionBufferLimitBytes *types.UInt32Value `protobuf:"bytes,4,opt,name=per_connection_buffer_limit_bytes,json=perConnectionBufferLimitBytes,proto3" json:"per_connection_buffer_limit_bytes,omitempty"`
	XXX_NoUnkeyedLiteral          struct{}           `json:"-"`
	XXX_unrecognized              []byte             `json:"-"`
	XXX_sizecache                 int32              `json:"-"`
}

func (m *ConnectionConfig) Reset()         { *m = ConnectionConfig{} }
func (m *ConnectionConfig) String() string { return proto.CompactTextString(m) }
func (*ConnectionConfig) ProtoMessage()    {}
func (*ConnectionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_04e8477467d444f5, []int{0}
}
func (m *ConnectionConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConnectionConfig.Unmarshal(m, b)
}
func (m *ConnectionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConnectionConfig.Marshal(b, m, deterministic)
}
func (m *ConnectionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionConfig.Merge(m, src)
}
func (m *ConnectionConfig) XXX_Size() int {
	return xxx_messageInfo_ConnectionConfig.Size(m)
}
func (m *ConnectionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionConfig proto.InternalMessageInfo

func (m *ConnectionConfig) GetMaxRequestsPerConnection() uint32 {
	if m != nil {
		return m.MaxRequestsPerConnection
	}
	return 0
}

func (m *ConnectionConfig) GetConnectTimeout() *time.Duration {
	if m != nil {
		return m.ConnectTimeout
	}
	return nil
}

func (m *ConnectionConfig) GetTcpKeepalive() *ConnectionConfig_TcpKeepAlive {
	if m != nil {
		return m.TcpKeepalive
	}
	return nil
}

func (m *ConnectionConfig) GetPerConnectionBufferLimitBytes() *types.UInt32Value {
	if m != nil {
		return m.PerConnectionBufferLimitBytes
	}
	return nil
}

// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
// see more info here: https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/core/address.proto#envoy-api-msg-core-tcpkeepalive
type ConnectionConfig_TcpKeepAlive struct {
	// Maximum number of keepalive probes to send without response before deciding the connection is dead.
	KeepaliveProbes uint32 `protobuf:"varint,1,opt,name=keepalive_probes,json=keepaliveProbes,proto3" json:"keepalive_probes,omitempty"`
	// The number of seconds a connection needs to be idle before keep-alive probes start being sent. This is rounded up to the second.
	KeepaliveTime *time.Duration `protobuf:"bytes,2,opt,name=keepalive_time,json=keepaliveTime,proto3,stdduration" json:"keepalive_time,omitempty"`
	// The number of seconds between keep-alive probes. This is rounded up to the second.
	KeepaliveInterval    *time.Duration `protobuf:"bytes,3,opt,name=keepalive_interval,json=keepaliveInterval,proto3,stdduration" json:"keepalive_interval,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ConnectionConfig_TcpKeepAlive) Reset()         { *m = ConnectionConfig_TcpKeepAlive{} }
func (m *ConnectionConfig_TcpKeepAlive) String() string { return proto.CompactTextString(m) }
func (*ConnectionConfig_TcpKeepAlive) ProtoMessage()    {}
func (*ConnectionConfig_TcpKeepAlive) Descriptor() ([]byte, []int) {
	return fileDescriptor_04e8477467d444f5, []int{0, 0}
}
func (m *ConnectionConfig_TcpKeepAlive) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConnectionConfig_TcpKeepAlive.Unmarshal(m, b)
}
func (m *ConnectionConfig_TcpKeepAlive) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConnectionConfig_TcpKeepAlive.Marshal(b, m, deterministic)
}
func (m *ConnectionConfig_TcpKeepAlive) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionConfig_TcpKeepAlive.Merge(m, src)
}
func (m *ConnectionConfig_TcpKeepAlive) XXX_Size() int {
	return xxx_messageInfo_ConnectionConfig_TcpKeepAlive.Size(m)
}
func (m *ConnectionConfig_TcpKeepAlive) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionConfig_TcpKeepAlive.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionConfig_TcpKeepAlive proto.InternalMessageInfo

func (m *ConnectionConfig_TcpKeepAlive) GetKeepaliveProbes() uint32 {
	if m != nil {
		return m.KeepaliveProbes
	}
	return 0
}

func (m *ConnectionConfig_TcpKeepAlive) GetKeepaliveTime() *time.Duration {
	if m != nil {
		return m.KeepaliveTime
	}
	return nil
}

func (m *ConnectionConfig_TcpKeepAlive) GetKeepaliveInterval() *time.Duration {
	if m != nil {
		return m.KeepaliveInterval
	}
	return nil
}

func init() {
	proto.RegisterType((*ConnectionConfig)(nil), "gloo.solo.io.ConnectionConfig")
	proto.RegisterType((*ConnectionConfig_TcpKeepAlive)(nil), "gloo.solo.io.ConnectionConfig.TcpKeepAlive")
}

func init() {
	proto.RegisterFile("github.com/solo-io/solo-apis/api/gloo/gloo/v1/connection.proto", fileDescriptor_04e8477467d444f5)
}

var fileDescriptor_04e8477467d444f5 = []byte{
	// 436 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0x4f, 0x6e, 0xd4, 0x30,
	0x14, 0xc6, 0x15, 0x18, 0xb1, 0x30, 0x33, 0x6d, 0xb1, 0x58, 0x84, 0x01, 0x4a, 0x61, 0x55, 0x84,
	0x70, 0xd4, 0x96, 0x2d, 0x95, 0x98, 0x22, 0x44, 0x05, 0x42, 0xa3, 0xa8, 0xb0, 0x60, 0x63, 0x39,
	0xe1, 0x25, 0x58, 0x4d, 0xf2, 0x8c, 0xe3, 0x0c, 0xe1, 0x26, 0x1c, 0x01, 0x6e, 0xc0, 0x35, 0x38,
	0x01, 0x12, 0x77, 0x60, 0x8f, 0xfc, 0xa7, 0xc9, 0x40, 0x25, 0xe8, 0x26, 0x89, 0xfd, 0xde, 0xf7,
	0xf3, 0xf7, 0xbe, 0x98, 0x1c, 0x96, 0xd2, 0xbc, 0xef, 0x32, 0x96, 0x63, 0x9d, 0xb4, 0x58, 0xe1,
	0x43, 0x89, 0xfe, 0x2d, 0x94, 0x6c, 0x13, 0xa1, 0x64, 0x52, 0x56, 0x88, 0xfe, 0xb1, 0xda, 0x4b,
	0x72, 0x6c, 0x1a, 0xc8, 0x8d, 0xc4, 0x86, 0x29, 0x8d, 0x06, 0xe9, 0xd4, 0x56, 0x98, 0x55, 0x30,
	0x89, 0xf3, 0xeb, 0x25, 0x96, 0xe8, 0x0a, 0x89, 0xfd, 0xf2, 0x3d, 0xf3, 0xed, 0x12, 0xb1, 0xac,
	0x20, 0x71, 0xab, 0xac, 0x2b, 0x92, 0x77, 0x9d, 0x16, 0x23, 0xe3, 0x7c, 0xfd, 0xa3, 0x16, 0x4a,
	0x81, 0x6e, 0x43, 0x9d, 0x42, 0x6f, 0x3c, 0x14, 0x7a, 0xe3, 0xf7, 0xee, 0x7d, 0x9d, 0x90, 0xad,
	0xa3, 0xc1, 0xcc, 0x11, 0x36, 0x85, 0x2c, 0xe9, 0x63, 0x72, 0xb3, 0x16, 0x3d, 0xd7, 0xf0, 0xa1,
	0x83, 0xd6, 0xb4, 0x5c, 0x81, 0xe6, 0xa3, 0xe3, 0x38, 0xda, 0x89, 0x76, 0x67, 0x69, 0x5c, 0x8b,
	0x3e, 0x0d, 0x1d, 0x4b, 0xd0, 0x23, 0x84, 0x3e, 0x27, 0x9b, 0xa1, 0x9b, 0x1b, 0x59, 0x03, 0x76,
	0x26, 0xbe, 0xb4, 0x13, 0xed, 0x5e, 0xdd, 0xbf, 0xc1, 0xbc, 0x43, 0x76, 0xe6, 0x90, 0x3d, 0x0d,
	0x13, 0x2c, 0x26, 0x9f, 0x7f, 0xdc, 0x89, 0xd2, 0x8d, 0xa0, 0x3b, 0xf1, 0x32, 0xba, 0x24, 0x33,
	0x93, 0x2b, 0x7e, 0x0a, 0xa0, 0x44, 0x25, 0x57, 0x10, 0x5f, 0x76, 0x9c, 0x07, 0x6c, 0x3d, 0x2d,
	0xf6, 0xb7, 0x7f, 0x76, 0x92, 0xab, 0x17, 0x00, 0xea, 0x89, 0x95, 0xa4, 0x53, 0xe3, 0x57, 0x0e,
	0x40, 0x0b, 0x72, 0xf7, 0xcf, 0x69, 0x78, 0xd6, 0x15, 0x05, 0x68, 0x5e, 0xc9, 0x5a, 0x1a, 0x9e,
	0x7d, 0x32, 0xd0, 0xc6, 0x13, 0x77, 0xca, 0xad, 0x73, 0x6e, 0x5f, 0x1f, 0x37, 0xe6, 0x60, 0xff,
	0x8d, 0xa8, 0x3a, 0x48, 0x6f, 0xab, 0xf5, 0x99, 0x17, 0x0e, 0xf2, 0xd2, 0x32, 0x16, 0x16, 0x31,
	0xff, 0x1e, 0x91, 0xe9, 0xba, 0x0d, 0x7a, 0x9f, 0x6c, 0x0d, 0x63, 0x70, 0xa5, 0x31, 0x83, 0x36,
	0x04, 0xb9, 0x39, 0xec, 0x2f, 0xdd, 0x36, 0x7d, 0x46, 0x36, 0xc6, 0x56, 0x9b, 0xe0, 0x45, 0xe3,
	0x9b, 0x0d, 0x32, 0x1b, 0x20, 0x7d, 0x45, 0xe8, 0xc8, 0x91, 0x8d, 0x01, 0xbd, 0x12, 0x55, 0x88,
	0xf0, 0xbf, 0xac, 0x6b, 0x83, 0xf4, 0x38, 0x28, 0x17, 0x87, 0xdf, 0x7e, 0x4d, 0xa2, 0x2f, 0x3f,
	0xb7, 0xa3, 0xb7, 0x8f, 0xfe, 0x79, 0xdb, 0xd5, 0x69, 0x39, 0xdc, 0xf8, 0xb3, 0x9f, 0x94, 0xac,
	0xf6, 0xb2, 0x2b, 0xee, 0xac, 0x83, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x04, 0x42, 0x63, 0xa1,
	0x2c, 0x03, 0x00, 0x00,
}

func (this *ConnectionConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConnectionConfig)
	if !ok {
		that2, ok := that.(ConnectionConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxRequestsPerConnection != that1.MaxRequestsPerConnection {
		return false
	}
	if this.ConnectTimeout != nil && that1.ConnectTimeout != nil {
		if *this.ConnectTimeout != *that1.ConnectTimeout {
			return false
		}
	} else if this.ConnectTimeout != nil {
		return false
	} else if that1.ConnectTimeout != nil {
		return false
	}
	if !this.TcpKeepalive.Equal(that1.TcpKeepalive) {
		return false
	}
	if !this.PerConnectionBufferLimitBytes.Equal(that1.PerConnectionBufferLimitBytes) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ConnectionConfig_TcpKeepAlive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConnectionConfig_TcpKeepAlive)
	if !ok {
		that2, ok := that.(ConnectionConfig_TcpKeepAlive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.KeepaliveProbes != that1.KeepaliveProbes {
		return false
	}
	if this.KeepaliveTime != nil && that1.KeepaliveTime != nil {
		if *this.KeepaliveTime != *that1.KeepaliveTime {
			return false
		}
	} else if this.KeepaliveTime != nil {
		return false
	} else if that1.KeepaliveTime != nil {
		return false
	}
	if this.KeepaliveInterval != nil && that1.KeepaliveInterval != nil {
		if *this.KeepaliveInterval != *that1.KeepaliveInterval {
			return false
		}
	} else if this.KeepaliveInterval != nil {
		return false
	} else if that1.KeepaliveInterval != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
