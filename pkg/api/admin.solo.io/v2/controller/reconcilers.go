// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./reconcilers.go -destination mocks/reconcilers.go

// Definitions for the Kubernetes Controllers
package controller

import (
	"context"

	admin_solo_io_v2 "github.com/solo-io/solo-apis/pkg/api/admin.solo.io/v2"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the Workspace Resource.
// implemented by the user
type WorkspaceReconciler interface {
	ReconcileWorkspace(obj *admin_solo_io_v2.Workspace) (reconcile.Result, error)
}

// Reconcile deletion events for the Workspace Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type WorkspaceDeletionReconciler interface {
	ReconcileWorkspaceDeletion(req reconcile.Request) error
}

type WorkspaceReconcilerFuncs struct {
	OnReconcileWorkspace         func(obj *admin_solo_io_v2.Workspace) (reconcile.Result, error)
	OnReconcileWorkspaceDeletion func(req reconcile.Request) error
}

func (f *WorkspaceReconcilerFuncs) ReconcileWorkspace(obj *admin_solo_io_v2.Workspace) (reconcile.Result, error) {
	if f.OnReconcileWorkspace == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileWorkspace(obj)
}

func (f *WorkspaceReconcilerFuncs) ReconcileWorkspaceDeletion(req reconcile.Request) error {
	if f.OnReconcileWorkspaceDeletion == nil {
		return nil
	}
	return f.OnReconcileWorkspaceDeletion(req)
}

// Reconcile and finalize the Workspace Resource
// implemented by the user
type WorkspaceFinalizer interface {
	WorkspaceReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	WorkspaceFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeWorkspace(obj *admin_solo_io_v2.Workspace) error
}

type WorkspaceReconcileLoop interface {
	RunWorkspaceReconciler(ctx context.Context, rec WorkspaceReconciler, predicates ...predicate.Predicate) error
}

type workspaceReconcileLoop struct {
	loop reconcile.Loop
}

func NewWorkspaceReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) WorkspaceReconcileLoop {
	return &workspaceReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &admin_solo_io_v2.Workspace{}, options),
	}
}

func (c *workspaceReconcileLoop) RunWorkspaceReconciler(ctx context.Context, reconciler WorkspaceReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericWorkspaceReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(WorkspaceFinalizer); ok {
		reconcilerWrapper = genericWorkspaceFinalizer{
			genericWorkspaceReconciler: genericReconciler,
			finalizingReconciler:       finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericWorkspaceHandler implements a generic reconcile.Reconciler
type genericWorkspaceReconciler struct {
	reconciler WorkspaceReconciler
}

func (r genericWorkspaceReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_solo_io_v2.Workspace)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: Workspace handler received event for %T", object)
	}
	return r.reconciler.ReconcileWorkspace(obj)
}

func (r genericWorkspaceReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(WorkspaceDeletionReconciler); ok {
		return deletionReconciler.ReconcileWorkspaceDeletion(request)
	}
	return nil
}

// genericWorkspaceFinalizer implements a generic reconcile.FinalizingReconciler
type genericWorkspaceFinalizer struct {
	genericWorkspaceReconciler
	finalizingReconciler WorkspaceFinalizer
}

func (r genericWorkspaceFinalizer) FinalizerName() string {
	return r.finalizingReconciler.WorkspaceFinalizerName()
}

func (r genericWorkspaceFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*admin_solo_io_v2.Workspace)
	if !ok {
		return errors.Errorf("internal error: Workspace handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeWorkspace(obj)
}

// Reconcile Upsert events for the WorkspaceSettings Resource.
// implemented by the user
type WorkspaceSettingsReconciler interface {
	ReconcileWorkspaceSettings(obj *admin_solo_io_v2.WorkspaceSettings) (reconcile.Result, error)
}

// Reconcile deletion events for the WorkspaceSettings Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type WorkspaceSettingsDeletionReconciler interface {
	ReconcileWorkspaceSettingsDeletion(req reconcile.Request) error
}

type WorkspaceSettingsReconcilerFuncs struct {
	OnReconcileWorkspaceSettings         func(obj *admin_solo_io_v2.WorkspaceSettings) (reconcile.Result, error)
	OnReconcileWorkspaceSettingsDeletion func(req reconcile.Request) error
}

func (f *WorkspaceSettingsReconcilerFuncs) ReconcileWorkspaceSettings(obj *admin_solo_io_v2.WorkspaceSettings) (reconcile.Result, error) {
	if f.OnReconcileWorkspaceSettings == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileWorkspaceSettings(obj)
}

func (f *WorkspaceSettingsReconcilerFuncs) ReconcileWorkspaceSettingsDeletion(req reconcile.Request) error {
	if f.OnReconcileWorkspaceSettingsDeletion == nil {
		return nil
	}
	return f.OnReconcileWorkspaceSettingsDeletion(req)
}

// Reconcile and finalize the WorkspaceSettings Resource
// implemented by the user
type WorkspaceSettingsFinalizer interface {
	WorkspaceSettingsReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	WorkspaceSettingsFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeWorkspaceSettings(obj *admin_solo_io_v2.WorkspaceSettings) error
}

type WorkspaceSettingsReconcileLoop interface {
	RunWorkspaceSettingsReconciler(ctx context.Context, rec WorkspaceSettingsReconciler, predicates ...predicate.Predicate) error
}

type workspaceSettingsReconcileLoop struct {
	loop reconcile.Loop
}

func NewWorkspaceSettingsReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) WorkspaceSettingsReconcileLoop {
	return &workspaceSettingsReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &admin_solo_io_v2.WorkspaceSettings{}, options),
	}
}

func (c *workspaceSettingsReconcileLoop) RunWorkspaceSettingsReconciler(ctx context.Context, reconciler WorkspaceSettingsReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericWorkspaceSettingsReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(WorkspaceSettingsFinalizer); ok {
		reconcilerWrapper = genericWorkspaceSettingsFinalizer{
			genericWorkspaceSettingsReconciler: genericReconciler,
			finalizingReconciler:               finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericWorkspaceSettingsHandler implements a generic reconcile.Reconciler
type genericWorkspaceSettingsReconciler struct {
	reconciler WorkspaceSettingsReconciler
}

func (r genericWorkspaceSettingsReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_solo_io_v2.WorkspaceSettings)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: WorkspaceSettings handler received event for %T", object)
	}
	return r.reconciler.ReconcileWorkspaceSettings(obj)
}

func (r genericWorkspaceSettingsReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(WorkspaceSettingsDeletionReconciler); ok {
		return deletionReconciler.ReconcileWorkspaceSettingsDeletion(request)
	}
	return nil
}

// genericWorkspaceSettingsFinalizer implements a generic reconcile.FinalizingReconciler
type genericWorkspaceSettingsFinalizer struct {
	genericWorkspaceSettingsReconciler
	finalizingReconciler WorkspaceSettingsFinalizer
}

func (r genericWorkspaceSettingsFinalizer) FinalizerName() string {
	return r.finalizingReconciler.WorkspaceSettingsFinalizerName()
}

func (r genericWorkspaceSettingsFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*admin_solo_io_v2.WorkspaceSettings)
	if !ok {
		return errors.Errorf("internal error: WorkspaceSettings handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeWorkspaceSettings(obj)
}

// Reconcile Upsert events for the KubernetesCluster Resource.
// implemented by the user
type KubernetesClusterReconciler interface {
	ReconcileKubernetesCluster(obj *admin_solo_io_v2.KubernetesCluster) (reconcile.Result, error)
}

// Reconcile deletion events for the KubernetesCluster Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type KubernetesClusterDeletionReconciler interface {
	ReconcileKubernetesClusterDeletion(req reconcile.Request) error
}

type KubernetesClusterReconcilerFuncs struct {
	OnReconcileKubernetesCluster         func(obj *admin_solo_io_v2.KubernetesCluster) (reconcile.Result, error)
	OnReconcileKubernetesClusterDeletion func(req reconcile.Request) error
}

func (f *KubernetesClusterReconcilerFuncs) ReconcileKubernetesCluster(obj *admin_solo_io_v2.KubernetesCluster) (reconcile.Result, error) {
	if f.OnReconcileKubernetesCluster == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileKubernetesCluster(obj)
}

func (f *KubernetesClusterReconcilerFuncs) ReconcileKubernetesClusterDeletion(req reconcile.Request) error {
	if f.OnReconcileKubernetesClusterDeletion == nil {
		return nil
	}
	return f.OnReconcileKubernetesClusterDeletion(req)
}

// Reconcile and finalize the KubernetesCluster Resource
// implemented by the user
type KubernetesClusterFinalizer interface {
	KubernetesClusterReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	KubernetesClusterFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeKubernetesCluster(obj *admin_solo_io_v2.KubernetesCluster) error
}

type KubernetesClusterReconcileLoop interface {
	RunKubernetesClusterReconciler(ctx context.Context, rec KubernetesClusterReconciler, predicates ...predicate.Predicate) error
}

type kubernetesClusterReconcileLoop struct {
	loop reconcile.Loop
}

func NewKubernetesClusterReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) KubernetesClusterReconcileLoop {
	return &kubernetesClusterReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &admin_solo_io_v2.KubernetesCluster{}, options),
	}
}

func (c *kubernetesClusterReconcileLoop) RunKubernetesClusterReconciler(ctx context.Context, reconciler KubernetesClusterReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericKubernetesClusterReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(KubernetesClusterFinalizer); ok {
		reconcilerWrapper = genericKubernetesClusterFinalizer{
			genericKubernetesClusterReconciler: genericReconciler,
			finalizingReconciler:               finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericKubernetesClusterHandler implements a generic reconcile.Reconciler
type genericKubernetesClusterReconciler struct {
	reconciler KubernetesClusterReconciler
}

func (r genericKubernetesClusterReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_solo_io_v2.KubernetesCluster)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: KubernetesCluster handler received event for %T", object)
	}
	return r.reconciler.ReconcileKubernetesCluster(obj)
}

func (r genericKubernetesClusterReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(KubernetesClusterDeletionReconciler); ok {
		return deletionReconciler.ReconcileKubernetesClusterDeletion(request)
	}
	return nil
}

// genericKubernetesClusterFinalizer implements a generic reconcile.FinalizingReconciler
type genericKubernetesClusterFinalizer struct {
	genericKubernetesClusterReconciler
	finalizingReconciler KubernetesClusterFinalizer
}

func (r genericKubernetesClusterFinalizer) FinalizerName() string {
	return r.finalizingReconciler.KubernetesClusterFinalizerName()
}

func (r genericKubernetesClusterFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*admin_solo_io_v2.KubernetesCluster)
	if !ok {
		return errors.Errorf("internal error: KubernetesCluster handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeKubernetesCluster(obj)
}

// Reconcile Upsert events for the RootTrustPolicy Resource.
// implemented by the user
type RootTrustPolicyReconciler interface {
	ReconcileRootTrustPolicy(obj *admin_solo_io_v2.RootTrustPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the RootTrustPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type RootTrustPolicyDeletionReconciler interface {
	ReconcileRootTrustPolicyDeletion(req reconcile.Request) error
}

type RootTrustPolicyReconcilerFuncs struct {
	OnReconcileRootTrustPolicy         func(obj *admin_solo_io_v2.RootTrustPolicy) (reconcile.Result, error)
	OnReconcileRootTrustPolicyDeletion func(req reconcile.Request) error
}

func (f *RootTrustPolicyReconcilerFuncs) ReconcileRootTrustPolicy(obj *admin_solo_io_v2.RootTrustPolicy) (reconcile.Result, error) {
	if f.OnReconcileRootTrustPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileRootTrustPolicy(obj)
}

func (f *RootTrustPolicyReconcilerFuncs) ReconcileRootTrustPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileRootTrustPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileRootTrustPolicyDeletion(req)
}

// Reconcile and finalize the RootTrustPolicy Resource
// implemented by the user
type RootTrustPolicyFinalizer interface {
	RootTrustPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	RootTrustPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeRootTrustPolicy(obj *admin_solo_io_v2.RootTrustPolicy) error
}

type RootTrustPolicyReconcileLoop interface {
	RunRootTrustPolicyReconciler(ctx context.Context, rec RootTrustPolicyReconciler, predicates ...predicate.Predicate) error
}

type rootTrustPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewRootTrustPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) RootTrustPolicyReconcileLoop {
	return &rootTrustPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &admin_solo_io_v2.RootTrustPolicy{}, options),
	}
}

func (c *rootTrustPolicyReconcileLoop) RunRootTrustPolicyReconciler(ctx context.Context, reconciler RootTrustPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericRootTrustPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(RootTrustPolicyFinalizer); ok {
		reconcilerWrapper = genericRootTrustPolicyFinalizer{
			genericRootTrustPolicyReconciler: genericReconciler,
			finalizingReconciler:             finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericRootTrustPolicyHandler implements a generic reconcile.Reconciler
type genericRootTrustPolicyReconciler struct {
	reconciler RootTrustPolicyReconciler
}

func (r genericRootTrustPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_solo_io_v2.RootTrustPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: RootTrustPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileRootTrustPolicy(obj)
}

func (r genericRootTrustPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(RootTrustPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileRootTrustPolicyDeletion(request)
	}
	return nil
}

// genericRootTrustPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericRootTrustPolicyFinalizer struct {
	genericRootTrustPolicyReconciler
	finalizingReconciler RootTrustPolicyFinalizer
}

func (r genericRootTrustPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.RootTrustPolicyFinalizerName()
}

func (r genericRootTrustPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*admin_solo_io_v2.RootTrustPolicy)
	if !ok {
		return errors.Errorf("internal error: RootTrustPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeRootTrustPolicy(obj)
}

// Reconcile Upsert events for the ExtAuthServer Resource.
// implemented by the user
type ExtAuthServerReconciler interface {
	ReconcileExtAuthServer(obj *admin_solo_io_v2.ExtAuthServer) (reconcile.Result, error)
}

// Reconcile deletion events for the ExtAuthServer Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type ExtAuthServerDeletionReconciler interface {
	ReconcileExtAuthServerDeletion(req reconcile.Request) error
}

type ExtAuthServerReconcilerFuncs struct {
	OnReconcileExtAuthServer         func(obj *admin_solo_io_v2.ExtAuthServer) (reconcile.Result, error)
	OnReconcileExtAuthServerDeletion func(req reconcile.Request) error
}

func (f *ExtAuthServerReconcilerFuncs) ReconcileExtAuthServer(obj *admin_solo_io_v2.ExtAuthServer) (reconcile.Result, error) {
	if f.OnReconcileExtAuthServer == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileExtAuthServer(obj)
}

func (f *ExtAuthServerReconcilerFuncs) ReconcileExtAuthServerDeletion(req reconcile.Request) error {
	if f.OnReconcileExtAuthServerDeletion == nil {
		return nil
	}
	return f.OnReconcileExtAuthServerDeletion(req)
}

// Reconcile and finalize the ExtAuthServer Resource
// implemented by the user
type ExtAuthServerFinalizer interface {
	ExtAuthServerReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	ExtAuthServerFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeExtAuthServer(obj *admin_solo_io_v2.ExtAuthServer) error
}

type ExtAuthServerReconcileLoop interface {
	RunExtAuthServerReconciler(ctx context.Context, rec ExtAuthServerReconciler, predicates ...predicate.Predicate) error
}

type extAuthServerReconcileLoop struct {
	loop reconcile.Loop
}

func NewExtAuthServerReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) ExtAuthServerReconcileLoop {
	return &extAuthServerReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &admin_solo_io_v2.ExtAuthServer{}, options),
	}
}

func (c *extAuthServerReconcileLoop) RunExtAuthServerReconciler(ctx context.Context, reconciler ExtAuthServerReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericExtAuthServerReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(ExtAuthServerFinalizer); ok {
		reconcilerWrapper = genericExtAuthServerFinalizer{
			genericExtAuthServerReconciler: genericReconciler,
			finalizingReconciler:           finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericExtAuthServerHandler implements a generic reconcile.Reconciler
type genericExtAuthServerReconciler struct {
	reconciler ExtAuthServerReconciler
}

func (r genericExtAuthServerReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_solo_io_v2.ExtAuthServer)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ExtAuthServer handler received event for %T", object)
	}
	return r.reconciler.ReconcileExtAuthServer(obj)
}

func (r genericExtAuthServerReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(ExtAuthServerDeletionReconciler); ok {
		return deletionReconciler.ReconcileExtAuthServerDeletion(request)
	}
	return nil
}

// genericExtAuthServerFinalizer implements a generic reconcile.FinalizingReconciler
type genericExtAuthServerFinalizer struct {
	genericExtAuthServerReconciler
	finalizingReconciler ExtAuthServerFinalizer
}

func (r genericExtAuthServerFinalizer) FinalizerName() string {
	return r.finalizingReconciler.ExtAuthServerFinalizerName()
}

func (r genericExtAuthServerFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*admin_solo_io_v2.ExtAuthServer)
	if !ok {
		return errors.Errorf("internal error: ExtAuthServer handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeExtAuthServer(obj)
}

// Reconcile Upsert events for the RateLimitServerSettings Resource.
// implemented by the user
type RateLimitServerSettingsReconciler interface {
	ReconcileRateLimitServerSettings(obj *admin_solo_io_v2.RateLimitServerSettings) (reconcile.Result, error)
}

// Reconcile deletion events for the RateLimitServerSettings Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type RateLimitServerSettingsDeletionReconciler interface {
	ReconcileRateLimitServerSettingsDeletion(req reconcile.Request) error
}

type RateLimitServerSettingsReconcilerFuncs struct {
	OnReconcileRateLimitServerSettings         func(obj *admin_solo_io_v2.RateLimitServerSettings) (reconcile.Result, error)
	OnReconcileRateLimitServerSettingsDeletion func(req reconcile.Request) error
}

func (f *RateLimitServerSettingsReconcilerFuncs) ReconcileRateLimitServerSettings(obj *admin_solo_io_v2.RateLimitServerSettings) (reconcile.Result, error) {
	if f.OnReconcileRateLimitServerSettings == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileRateLimitServerSettings(obj)
}

func (f *RateLimitServerSettingsReconcilerFuncs) ReconcileRateLimitServerSettingsDeletion(req reconcile.Request) error {
	if f.OnReconcileRateLimitServerSettingsDeletion == nil {
		return nil
	}
	return f.OnReconcileRateLimitServerSettingsDeletion(req)
}

// Reconcile and finalize the RateLimitServerSettings Resource
// implemented by the user
type RateLimitServerSettingsFinalizer interface {
	RateLimitServerSettingsReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	RateLimitServerSettingsFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeRateLimitServerSettings(obj *admin_solo_io_v2.RateLimitServerSettings) error
}

type RateLimitServerSettingsReconcileLoop interface {
	RunRateLimitServerSettingsReconciler(ctx context.Context, rec RateLimitServerSettingsReconciler, predicates ...predicate.Predicate) error
}

type rateLimitServerSettingsReconcileLoop struct {
	loop reconcile.Loop
}

func NewRateLimitServerSettingsReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) RateLimitServerSettingsReconcileLoop {
	return &rateLimitServerSettingsReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &admin_solo_io_v2.RateLimitServerSettings{}, options),
	}
}

func (c *rateLimitServerSettingsReconcileLoop) RunRateLimitServerSettingsReconciler(ctx context.Context, reconciler RateLimitServerSettingsReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericRateLimitServerSettingsReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(RateLimitServerSettingsFinalizer); ok {
		reconcilerWrapper = genericRateLimitServerSettingsFinalizer{
			genericRateLimitServerSettingsReconciler: genericReconciler,
			finalizingReconciler:                     finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericRateLimitServerSettingsHandler implements a generic reconcile.Reconciler
type genericRateLimitServerSettingsReconciler struct {
	reconciler RateLimitServerSettingsReconciler
}

func (r genericRateLimitServerSettingsReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_solo_io_v2.RateLimitServerSettings)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: RateLimitServerSettings handler received event for %T", object)
	}
	return r.reconciler.ReconcileRateLimitServerSettings(obj)
}

func (r genericRateLimitServerSettingsReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(RateLimitServerSettingsDeletionReconciler); ok {
		return deletionReconciler.ReconcileRateLimitServerSettingsDeletion(request)
	}
	return nil
}

// genericRateLimitServerSettingsFinalizer implements a generic reconcile.FinalizingReconciler
type genericRateLimitServerSettingsFinalizer struct {
	genericRateLimitServerSettingsReconciler
	finalizingReconciler RateLimitServerSettingsFinalizer
}

func (r genericRateLimitServerSettingsFinalizer) FinalizerName() string {
	return r.finalizingReconciler.RateLimitServerSettingsFinalizerName()
}

func (r genericRateLimitServerSettingsFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*admin_solo_io_v2.RateLimitServerSettings)
	if !ok {
		return errors.Errorf("internal error: RateLimitServerSettings handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeRateLimitServerSettings(obj)
}

// Reconcile Upsert events for the RateLimitServerConfig Resource.
// implemented by the user
type RateLimitServerConfigReconciler interface {
	ReconcileRateLimitServerConfig(obj *admin_solo_io_v2.RateLimitServerConfig) (reconcile.Result, error)
}

// Reconcile deletion events for the RateLimitServerConfig Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type RateLimitServerConfigDeletionReconciler interface {
	ReconcileRateLimitServerConfigDeletion(req reconcile.Request) error
}

type RateLimitServerConfigReconcilerFuncs struct {
	OnReconcileRateLimitServerConfig         func(obj *admin_solo_io_v2.RateLimitServerConfig) (reconcile.Result, error)
	OnReconcileRateLimitServerConfigDeletion func(req reconcile.Request) error
}

func (f *RateLimitServerConfigReconcilerFuncs) ReconcileRateLimitServerConfig(obj *admin_solo_io_v2.RateLimitServerConfig) (reconcile.Result, error) {
	if f.OnReconcileRateLimitServerConfig == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileRateLimitServerConfig(obj)
}

func (f *RateLimitServerConfigReconcilerFuncs) ReconcileRateLimitServerConfigDeletion(req reconcile.Request) error {
	if f.OnReconcileRateLimitServerConfigDeletion == nil {
		return nil
	}
	return f.OnReconcileRateLimitServerConfigDeletion(req)
}

// Reconcile and finalize the RateLimitServerConfig Resource
// implemented by the user
type RateLimitServerConfigFinalizer interface {
	RateLimitServerConfigReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	RateLimitServerConfigFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeRateLimitServerConfig(obj *admin_solo_io_v2.RateLimitServerConfig) error
}

type RateLimitServerConfigReconcileLoop interface {
	RunRateLimitServerConfigReconciler(ctx context.Context, rec RateLimitServerConfigReconciler, predicates ...predicate.Predicate) error
}

type rateLimitServerConfigReconcileLoop struct {
	loop reconcile.Loop
}

func NewRateLimitServerConfigReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) RateLimitServerConfigReconcileLoop {
	return &rateLimitServerConfigReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &admin_solo_io_v2.RateLimitServerConfig{}, options),
	}
}

func (c *rateLimitServerConfigReconcileLoop) RunRateLimitServerConfigReconciler(ctx context.Context, reconciler RateLimitServerConfigReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericRateLimitServerConfigReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(RateLimitServerConfigFinalizer); ok {
		reconcilerWrapper = genericRateLimitServerConfigFinalizer{
			genericRateLimitServerConfigReconciler: genericReconciler,
			finalizingReconciler:                   finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericRateLimitServerConfigHandler implements a generic reconcile.Reconciler
type genericRateLimitServerConfigReconciler struct {
	reconciler RateLimitServerConfigReconciler
}

func (r genericRateLimitServerConfigReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_solo_io_v2.RateLimitServerConfig)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: RateLimitServerConfig handler received event for %T", object)
	}
	return r.reconciler.ReconcileRateLimitServerConfig(obj)
}

func (r genericRateLimitServerConfigReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(RateLimitServerConfigDeletionReconciler); ok {
		return deletionReconciler.ReconcileRateLimitServerConfigDeletion(request)
	}
	return nil
}

// genericRateLimitServerConfigFinalizer implements a generic reconcile.FinalizingReconciler
type genericRateLimitServerConfigFinalizer struct {
	genericRateLimitServerConfigReconciler
	finalizingReconciler RateLimitServerConfigFinalizer
}

func (r genericRateLimitServerConfigFinalizer) FinalizerName() string {
	return r.finalizingReconciler.RateLimitServerConfigFinalizerName()
}

func (r genericRateLimitServerConfigFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*admin_solo_io_v2.RateLimitServerConfig)
	if !ok {
		return errors.Errorf("internal error: RateLimitServerConfig handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeRateLimitServerConfig(obj)
}

// Reconcile Upsert events for the Dashboard Resource.
// implemented by the user
type DashboardReconciler interface {
	ReconcileDashboard(obj *admin_solo_io_v2.Dashboard) (reconcile.Result, error)
}

// Reconcile deletion events for the Dashboard Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type DashboardDeletionReconciler interface {
	ReconcileDashboardDeletion(req reconcile.Request) error
}

type DashboardReconcilerFuncs struct {
	OnReconcileDashboard         func(obj *admin_solo_io_v2.Dashboard) (reconcile.Result, error)
	OnReconcileDashboardDeletion func(req reconcile.Request) error
}

func (f *DashboardReconcilerFuncs) ReconcileDashboard(obj *admin_solo_io_v2.Dashboard) (reconcile.Result, error) {
	if f.OnReconcileDashboard == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileDashboard(obj)
}

func (f *DashboardReconcilerFuncs) ReconcileDashboardDeletion(req reconcile.Request) error {
	if f.OnReconcileDashboardDeletion == nil {
		return nil
	}
	return f.OnReconcileDashboardDeletion(req)
}

// Reconcile and finalize the Dashboard Resource
// implemented by the user
type DashboardFinalizer interface {
	DashboardReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	DashboardFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeDashboard(obj *admin_solo_io_v2.Dashboard) error
}

type DashboardReconcileLoop interface {
	RunDashboardReconciler(ctx context.Context, rec DashboardReconciler, predicates ...predicate.Predicate) error
}

type dashboardReconcileLoop struct {
	loop reconcile.Loop
}

func NewDashboardReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) DashboardReconcileLoop {
	return &dashboardReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &admin_solo_io_v2.Dashboard{}, options),
	}
}

func (c *dashboardReconcileLoop) RunDashboardReconciler(ctx context.Context, reconciler DashboardReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericDashboardReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(DashboardFinalizer); ok {
		reconcilerWrapper = genericDashboardFinalizer{
			genericDashboardReconciler: genericReconciler,
			finalizingReconciler:       finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericDashboardHandler implements a generic reconcile.Reconciler
type genericDashboardReconciler struct {
	reconciler DashboardReconciler
}

func (r genericDashboardReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_solo_io_v2.Dashboard)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: Dashboard handler received event for %T", object)
	}
	return r.reconciler.ReconcileDashboard(obj)
}

func (r genericDashboardReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(DashboardDeletionReconciler); ok {
		return deletionReconciler.ReconcileDashboardDeletion(request)
	}
	return nil
}

// genericDashboardFinalizer implements a generic reconcile.FinalizingReconciler
type genericDashboardFinalizer struct {
	genericDashboardReconciler
	finalizingReconciler DashboardFinalizer
}

func (r genericDashboardFinalizer) FinalizerName() string {
	return r.finalizingReconciler.DashboardFinalizerName()
}

func (r genericDashboardFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*admin_solo_io_v2.Dashboard)
	if !ok {
		return errors.Errorf("internal error: Dashboard handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeDashboard(obj)
}

// Reconcile Upsert events for the IstioLifecycleManager Resource.
// implemented by the user
type IstioLifecycleManagerReconciler interface {
	ReconcileIstioLifecycleManager(obj *admin_solo_io_v2.IstioLifecycleManager) (reconcile.Result, error)
}

// Reconcile deletion events for the IstioLifecycleManager Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type IstioLifecycleManagerDeletionReconciler interface {
	ReconcileIstioLifecycleManagerDeletion(req reconcile.Request) error
}

type IstioLifecycleManagerReconcilerFuncs struct {
	OnReconcileIstioLifecycleManager         func(obj *admin_solo_io_v2.IstioLifecycleManager) (reconcile.Result, error)
	OnReconcileIstioLifecycleManagerDeletion func(req reconcile.Request) error
}

func (f *IstioLifecycleManagerReconcilerFuncs) ReconcileIstioLifecycleManager(obj *admin_solo_io_v2.IstioLifecycleManager) (reconcile.Result, error) {
	if f.OnReconcileIstioLifecycleManager == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileIstioLifecycleManager(obj)
}

func (f *IstioLifecycleManagerReconcilerFuncs) ReconcileIstioLifecycleManagerDeletion(req reconcile.Request) error {
	if f.OnReconcileIstioLifecycleManagerDeletion == nil {
		return nil
	}
	return f.OnReconcileIstioLifecycleManagerDeletion(req)
}

// Reconcile and finalize the IstioLifecycleManager Resource
// implemented by the user
type IstioLifecycleManagerFinalizer interface {
	IstioLifecycleManagerReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	IstioLifecycleManagerFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeIstioLifecycleManager(obj *admin_solo_io_v2.IstioLifecycleManager) error
}

type IstioLifecycleManagerReconcileLoop interface {
	RunIstioLifecycleManagerReconciler(ctx context.Context, rec IstioLifecycleManagerReconciler, predicates ...predicate.Predicate) error
}

type istioLifecycleManagerReconcileLoop struct {
	loop reconcile.Loop
}

func NewIstioLifecycleManagerReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) IstioLifecycleManagerReconcileLoop {
	return &istioLifecycleManagerReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &admin_solo_io_v2.IstioLifecycleManager{}, options),
	}
}

func (c *istioLifecycleManagerReconcileLoop) RunIstioLifecycleManagerReconciler(ctx context.Context, reconciler IstioLifecycleManagerReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericIstioLifecycleManagerReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(IstioLifecycleManagerFinalizer); ok {
		reconcilerWrapper = genericIstioLifecycleManagerFinalizer{
			genericIstioLifecycleManagerReconciler: genericReconciler,
			finalizingReconciler:                   finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericIstioLifecycleManagerHandler implements a generic reconcile.Reconciler
type genericIstioLifecycleManagerReconciler struct {
	reconciler IstioLifecycleManagerReconciler
}

func (r genericIstioLifecycleManagerReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*admin_solo_io_v2.IstioLifecycleManager)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: IstioLifecycleManager handler received event for %T", object)
	}
	return r.reconciler.ReconcileIstioLifecycleManager(obj)
}

func (r genericIstioLifecycleManagerReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(IstioLifecycleManagerDeletionReconciler); ok {
		return deletionReconciler.ReconcileIstioLifecycleManagerDeletion(request)
	}
	return nil
}

// genericIstioLifecycleManagerFinalizer implements a generic reconcile.FinalizingReconciler
type genericIstioLifecycleManagerFinalizer struct {
	genericIstioLifecycleManagerReconciler
	finalizingReconciler IstioLifecycleManagerFinalizer
}

func (r genericIstioLifecycleManagerFinalizer) FinalizerName() string {
	return r.finalizingReconciler.IstioLifecycleManagerFinalizerName()
}

func (r genericIstioLifecycleManagerFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*admin_solo_io_v2.IstioLifecycleManager)
	if !ok {
		return errors.Errorf("internal error: IstioLifecycleManager handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeIstioLifecycleManager(obj)
}
