// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./sets.go -destination mocks/sets.go

package v2sets

import (
	admin_solo_io_v2 "github.com/solo-io/solo-apis/pkg/api/admin.solo.io/v2"

	"github.com/rotisserie/eris"
	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"k8s.io/apimachinery/pkg/util/sets"
)

type WorkspaceSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*admin_solo_io_v2.Workspace) bool) []*admin_solo_io_v2.Workspace
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*admin_solo_io_v2.Workspace) bool) []*admin_solo_io_v2.Workspace
	// Return the Set as a map of key to resource.
	Map() map[string]*admin_solo_io_v2.Workspace
	// Insert a resource into the set.
	Insert(workspace ...*admin_solo_io_v2.Workspace)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(workspaceSet WorkspaceSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(workspace ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(workspace ezkube.ResourceId)
	// Return the union with the provided set
	Union(set WorkspaceSet) WorkspaceSet
	// Return the difference with the provided set
	Difference(set WorkspaceSet) WorkspaceSet
	// Return the intersection with the provided set
	Intersection(set WorkspaceSet) WorkspaceSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*admin_solo_io_v2.Workspace, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another WorkspaceSet
	Delta(newSet WorkspaceSet) sksets.ResourceDelta
	// Create a deep copy of the current WorkspaceSet
	Clone() WorkspaceSet
}

func makeGenericWorkspaceSet(workspaceList []*admin_solo_io_v2.Workspace) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range workspaceList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type workspaceSet struct {
	set sksets.ResourceSet
}

func NewWorkspaceSet(workspaceList ...*admin_solo_io_v2.Workspace) WorkspaceSet {
	return &workspaceSet{set: makeGenericWorkspaceSet(workspaceList)}
}

func NewWorkspaceSetFromList(workspaceList *admin_solo_io_v2.WorkspaceList) WorkspaceSet {
	list := make([]*admin_solo_io_v2.Workspace, 0, len(workspaceList.Items))
	for idx := range workspaceList.Items {
		list = append(list, &workspaceList.Items[idx])
	}
	return &workspaceSet{set: makeGenericWorkspaceSet(list)}
}

func (s *workspaceSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *workspaceSet) List(filterResource ...func(*admin_solo_io_v2.Workspace) bool) []*admin_solo_io_v2.Workspace {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.Workspace))
		})
	}

	objs := s.Generic().List(genericFilters...)
	workspaceList := make([]*admin_solo_io_v2.Workspace, 0, len(objs))
	for _, obj := range objs {
		workspaceList = append(workspaceList, obj.(*admin_solo_io_v2.Workspace))
	}
	return workspaceList
}

func (s *workspaceSet) UnsortedList(filterResource ...func(*admin_solo_io_v2.Workspace) bool) []*admin_solo_io_v2.Workspace {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.Workspace))
		})
	}

	var workspaceList []*admin_solo_io_v2.Workspace
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		workspaceList = append(workspaceList, obj.(*admin_solo_io_v2.Workspace))
	}
	return workspaceList
}

func (s *workspaceSet) Map() map[string]*admin_solo_io_v2.Workspace {
	if s == nil {
		return nil
	}

	newMap := map[string]*admin_solo_io_v2.Workspace{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*admin_solo_io_v2.Workspace)
	}
	return newMap
}

func (s *workspaceSet) Insert(
	workspaceList ...*admin_solo_io_v2.Workspace,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range workspaceList {
		s.Generic().Insert(obj)
	}
}

func (s *workspaceSet) Has(workspace ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(workspace)
}

func (s *workspaceSet) Equal(
	workspaceSet WorkspaceSet,
) bool {
	if s == nil {
		return workspaceSet == nil
	}
	return s.Generic().Equal(workspaceSet.Generic())
}

func (s *workspaceSet) Delete(Workspace ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(Workspace)
}

func (s *workspaceSet) Union(set WorkspaceSet) WorkspaceSet {
	if s == nil {
		return set
	}
	return NewWorkspaceSet(append(s.List(), set.List()...)...)
}

func (s *workspaceSet) Difference(set WorkspaceSet) WorkspaceSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &workspaceSet{set: newSet}
}

func (s *workspaceSet) Intersection(set WorkspaceSet) WorkspaceSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var workspaceList []*admin_solo_io_v2.Workspace
	for _, obj := range newSet.List() {
		workspaceList = append(workspaceList, obj.(*admin_solo_io_v2.Workspace))
	}
	return NewWorkspaceSet(workspaceList...)
}

func (s *workspaceSet) Find(id ezkube.ResourceId) (*admin_solo_io_v2.Workspace, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Workspace %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&admin_solo_io_v2.Workspace{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*admin_solo_io_v2.Workspace), nil
}

func (s *workspaceSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *workspaceSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *workspaceSet) Delta(newSet WorkspaceSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *workspaceSet) Clone() WorkspaceSet {
	if s == nil {
		return nil
	}
	return &workspaceSet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type WorkspaceSettingsSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*admin_solo_io_v2.WorkspaceSettings) bool) []*admin_solo_io_v2.WorkspaceSettings
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*admin_solo_io_v2.WorkspaceSettings) bool) []*admin_solo_io_v2.WorkspaceSettings
	// Return the Set as a map of key to resource.
	Map() map[string]*admin_solo_io_v2.WorkspaceSettings
	// Insert a resource into the set.
	Insert(workspaceSettings ...*admin_solo_io_v2.WorkspaceSettings)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(workspaceSettingsSet WorkspaceSettingsSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(workspaceSettings ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(workspaceSettings ezkube.ResourceId)
	// Return the union with the provided set
	Union(set WorkspaceSettingsSet) WorkspaceSettingsSet
	// Return the difference with the provided set
	Difference(set WorkspaceSettingsSet) WorkspaceSettingsSet
	// Return the intersection with the provided set
	Intersection(set WorkspaceSettingsSet) WorkspaceSettingsSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*admin_solo_io_v2.WorkspaceSettings, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another WorkspaceSettingsSet
	Delta(newSet WorkspaceSettingsSet) sksets.ResourceDelta
	// Create a deep copy of the current WorkspaceSettingsSet
	Clone() WorkspaceSettingsSet
}

func makeGenericWorkspaceSettingsSet(workspaceSettingsList []*admin_solo_io_v2.WorkspaceSettings) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range workspaceSettingsList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type workspaceSettingsSet struct {
	set sksets.ResourceSet
}

func NewWorkspaceSettingsSet(workspaceSettingsList ...*admin_solo_io_v2.WorkspaceSettings) WorkspaceSettingsSet {
	return &workspaceSettingsSet{set: makeGenericWorkspaceSettingsSet(workspaceSettingsList)}
}

func NewWorkspaceSettingsSetFromList(workspaceSettingsList *admin_solo_io_v2.WorkspaceSettingsList) WorkspaceSettingsSet {
	list := make([]*admin_solo_io_v2.WorkspaceSettings, 0, len(workspaceSettingsList.Items))
	for idx := range workspaceSettingsList.Items {
		list = append(list, &workspaceSettingsList.Items[idx])
	}
	return &workspaceSettingsSet{set: makeGenericWorkspaceSettingsSet(list)}
}

func (s *workspaceSettingsSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *workspaceSettingsSet) List(filterResource ...func(*admin_solo_io_v2.WorkspaceSettings) bool) []*admin_solo_io_v2.WorkspaceSettings {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.WorkspaceSettings))
		})
	}

	objs := s.Generic().List(genericFilters...)
	workspaceSettingsList := make([]*admin_solo_io_v2.WorkspaceSettings, 0, len(objs))
	for _, obj := range objs {
		workspaceSettingsList = append(workspaceSettingsList, obj.(*admin_solo_io_v2.WorkspaceSettings))
	}
	return workspaceSettingsList
}

func (s *workspaceSettingsSet) UnsortedList(filterResource ...func(*admin_solo_io_v2.WorkspaceSettings) bool) []*admin_solo_io_v2.WorkspaceSettings {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.WorkspaceSettings))
		})
	}

	var workspaceSettingsList []*admin_solo_io_v2.WorkspaceSettings
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		workspaceSettingsList = append(workspaceSettingsList, obj.(*admin_solo_io_v2.WorkspaceSettings))
	}
	return workspaceSettingsList
}

func (s *workspaceSettingsSet) Map() map[string]*admin_solo_io_v2.WorkspaceSettings {
	if s == nil {
		return nil
	}

	newMap := map[string]*admin_solo_io_v2.WorkspaceSettings{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*admin_solo_io_v2.WorkspaceSettings)
	}
	return newMap
}

func (s *workspaceSettingsSet) Insert(
	workspaceSettingsList ...*admin_solo_io_v2.WorkspaceSettings,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range workspaceSettingsList {
		s.Generic().Insert(obj)
	}
}

func (s *workspaceSettingsSet) Has(workspaceSettings ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(workspaceSettings)
}

func (s *workspaceSettingsSet) Equal(
	workspaceSettingsSet WorkspaceSettingsSet,
) bool {
	if s == nil {
		return workspaceSettingsSet == nil
	}
	return s.Generic().Equal(workspaceSettingsSet.Generic())
}

func (s *workspaceSettingsSet) Delete(WorkspaceSettings ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(WorkspaceSettings)
}

func (s *workspaceSettingsSet) Union(set WorkspaceSettingsSet) WorkspaceSettingsSet {
	if s == nil {
		return set
	}
	return NewWorkspaceSettingsSet(append(s.List(), set.List()...)...)
}

func (s *workspaceSettingsSet) Difference(set WorkspaceSettingsSet) WorkspaceSettingsSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &workspaceSettingsSet{set: newSet}
}

func (s *workspaceSettingsSet) Intersection(set WorkspaceSettingsSet) WorkspaceSettingsSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var workspaceSettingsList []*admin_solo_io_v2.WorkspaceSettings
	for _, obj := range newSet.List() {
		workspaceSettingsList = append(workspaceSettingsList, obj.(*admin_solo_io_v2.WorkspaceSettings))
	}
	return NewWorkspaceSettingsSet(workspaceSettingsList...)
}

func (s *workspaceSettingsSet) Find(id ezkube.ResourceId) (*admin_solo_io_v2.WorkspaceSettings, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find WorkspaceSettings %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&admin_solo_io_v2.WorkspaceSettings{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*admin_solo_io_v2.WorkspaceSettings), nil
}

func (s *workspaceSettingsSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *workspaceSettingsSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *workspaceSettingsSet) Delta(newSet WorkspaceSettingsSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *workspaceSettingsSet) Clone() WorkspaceSettingsSet {
	if s == nil {
		return nil
	}
	return &workspaceSettingsSet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type KubernetesClusterSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*admin_solo_io_v2.KubernetesCluster) bool) []*admin_solo_io_v2.KubernetesCluster
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*admin_solo_io_v2.KubernetesCluster) bool) []*admin_solo_io_v2.KubernetesCluster
	// Return the Set as a map of key to resource.
	Map() map[string]*admin_solo_io_v2.KubernetesCluster
	// Insert a resource into the set.
	Insert(kubernetesCluster ...*admin_solo_io_v2.KubernetesCluster)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(kubernetesClusterSet KubernetesClusterSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(kubernetesCluster ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(kubernetesCluster ezkube.ResourceId)
	// Return the union with the provided set
	Union(set KubernetesClusterSet) KubernetesClusterSet
	// Return the difference with the provided set
	Difference(set KubernetesClusterSet) KubernetesClusterSet
	// Return the intersection with the provided set
	Intersection(set KubernetesClusterSet) KubernetesClusterSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*admin_solo_io_v2.KubernetesCluster, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another KubernetesClusterSet
	Delta(newSet KubernetesClusterSet) sksets.ResourceDelta
	// Create a deep copy of the current KubernetesClusterSet
	Clone() KubernetesClusterSet
}

func makeGenericKubernetesClusterSet(kubernetesClusterList []*admin_solo_io_v2.KubernetesCluster) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range kubernetesClusterList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type kubernetesClusterSet struct {
	set sksets.ResourceSet
}

func NewKubernetesClusterSet(kubernetesClusterList ...*admin_solo_io_v2.KubernetesCluster) KubernetesClusterSet {
	return &kubernetesClusterSet{set: makeGenericKubernetesClusterSet(kubernetesClusterList)}
}

func NewKubernetesClusterSetFromList(kubernetesClusterList *admin_solo_io_v2.KubernetesClusterList) KubernetesClusterSet {
	list := make([]*admin_solo_io_v2.KubernetesCluster, 0, len(kubernetesClusterList.Items))
	for idx := range kubernetesClusterList.Items {
		list = append(list, &kubernetesClusterList.Items[idx])
	}
	return &kubernetesClusterSet{set: makeGenericKubernetesClusterSet(list)}
}

func (s *kubernetesClusterSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *kubernetesClusterSet) List(filterResource ...func(*admin_solo_io_v2.KubernetesCluster) bool) []*admin_solo_io_v2.KubernetesCluster {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.KubernetesCluster))
		})
	}

	objs := s.Generic().List(genericFilters...)
	kubernetesClusterList := make([]*admin_solo_io_v2.KubernetesCluster, 0, len(objs))
	for _, obj := range objs {
		kubernetesClusterList = append(kubernetesClusterList, obj.(*admin_solo_io_v2.KubernetesCluster))
	}
	return kubernetesClusterList
}

func (s *kubernetesClusterSet) UnsortedList(filterResource ...func(*admin_solo_io_v2.KubernetesCluster) bool) []*admin_solo_io_v2.KubernetesCluster {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.KubernetesCluster))
		})
	}

	var kubernetesClusterList []*admin_solo_io_v2.KubernetesCluster
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		kubernetesClusterList = append(kubernetesClusterList, obj.(*admin_solo_io_v2.KubernetesCluster))
	}
	return kubernetesClusterList
}

func (s *kubernetesClusterSet) Map() map[string]*admin_solo_io_v2.KubernetesCluster {
	if s == nil {
		return nil
	}

	newMap := map[string]*admin_solo_io_v2.KubernetesCluster{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*admin_solo_io_v2.KubernetesCluster)
	}
	return newMap
}

func (s *kubernetesClusterSet) Insert(
	kubernetesClusterList ...*admin_solo_io_v2.KubernetesCluster,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range kubernetesClusterList {
		s.Generic().Insert(obj)
	}
}

func (s *kubernetesClusterSet) Has(kubernetesCluster ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(kubernetesCluster)
}

func (s *kubernetesClusterSet) Equal(
	kubernetesClusterSet KubernetesClusterSet,
) bool {
	if s == nil {
		return kubernetesClusterSet == nil
	}
	return s.Generic().Equal(kubernetesClusterSet.Generic())
}

func (s *kubernetesClusterSet) Delete(KubernetesCluster ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(KubernetesCluster)
}

func (s *kubernetesClusterSet) Union(set KubernetesClusterSet) KubernetesClusterSet {
	if s == nil {
		return set
	}
	return NewKubernetesClusterSet(append(s.List(), set.List()...)...)
}

func (s *kubernetesClusterSet) Difference(set KubernetesClusterSet) KubernetesClusterSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &kubernetesClusterSet{set: newSet}
}

func (s *kubernetesClusterSet) Intersection(set KubernetesClusterSet) KubernetesClusterSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var kubernetesClusterList []*admin_solo_io_v2.KubernetesCluster
	for _, obj := range newSet.List() {
		kubernetesClusterList = append(kubernetesClusterList, obj.(*admin_solo_io_v2.KubernetesCluster))
	}
	return NewKubernetesClusterSet(kubernetesClusterList...)
}

func (s *kubernetesClusterSet) Find(id ezkube.ResourceId) (*admin_solo_io_v2.KubernetesCluster, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find KubernetesCluster %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&admin_solo_io_v2.KubernetesCluster{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*admin_solo_io_v2.KubernetesCluster), nil
}

func (s *kubernetesClusterSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *kubernetesClusterSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *kubernetesClusterSet) Delta(newSet KubernetesClusterSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *kubernetesClusterSet) Clone() KubernetesClusterSet {
	if s == nil {
		return nil
	}
	return &kubernetesClusterSet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type RootTrustPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*admin_solo_io_v2.RootTrustPolicy) bool) []*admin_solo_io_v2.RootTrustPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*admin_solo_io_v2.RootTrustPolicy) bool) []*admin_solo_io_v2.RootTrustPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*admin_solo_io_v2.RootTrustPolicy
	// Insert a resource into the set.
	Insert(rootTrustPolicy ...*admin_solo_io_v2.RootTrustPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(rootTrustPolicySet RootTrustPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(rootTrustPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(rootTrustPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set RootTrustPolicySet) RootTrustPolicySet
	// Return the difference with the provided set
	Difference(set RootTrustPolicySet) RootTrustPolicySet
	// Return the intersection with the provided set
	Intersection(set RootTrustPolicySet) RootTrustPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*admin_solo_io_v2.RootTrustPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another RootTrustPolicySet
	Delta(newSet RootTrustPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current RootTrustPolicySet
	Clone() RootTrustPolicySet
}

func makeGenericRootTrustPolicySet(rootTrustPolicyList []*admin_solo_io_v2.RootTrustPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range rootTrustPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type rootTrustPolicySet struct {
	set sksets.ResourceSet
}

func NewRootTrustPolicySet(rootTrustPolicyList ...*admin_solo_io_v2.RootTrustPolicy) RootTrustPolicySet {
	return &rootTrustPolicySet{set: makeGenericRootTrustPolicySet(rootTrustPolicyList)}
}

func NewRootTrustPolicySetFromList(rootTrustPolicyList *admin_solo_io_v2.RootTrustPolicyList) RootTrustPolicySet {
	list := make([]*admin_solo_io_v2.RootTrustPolicy, 0, len(rootTrustPolicyList.Items))
	for idx := range rootTrustPolicyList.Items {
		list = append(list, &rootTrustPolicyList.Items[idx])
	}
	return &rootTrustPolicySet{set: makeGenericRootTrustPolicySet(list)}
}

func (s *rootTrustPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *rootTrustPolicySet) List(filterResource ...func(*admin_solo_io_v2.RootTrustPolicy) bool) []*admin_solo_io_v2.RootTrustPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.RootTrustPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	rootTrustPolicyList := make([]*admin_solo_io_v2.RootTrustPolicy, 0, len(objs))
	for _, obj := range objs {
		rootTrustPolicyList = append(rootTrustPolicyList, obj.(*admin_solo_io_v2.RootTrustPolicy))
	}
	return rootTrustPolicyList
}

func (s *rootTrustPolicySet) UnsortedList(filterResource ...func(*admin_solo_io_v2.RootTrustPolicy) bool) []*admin_solo_io_v2.RootTrustPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.RootTrustPolicy))
		})
	}

	var rootTrustPolicyList []*admin_solo_io_v2.RootTrustPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		rootTrustPolicyList = append(rootTrustPolicyList, obj.(*admin_solo_io_v2.RootTrustPolicy))
	}
	return rootTrustPolicyList
}

func (s *rootTrustPolicySet) Map() map[string]*admin_solo_io_v2.RootTrustPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*admin_solo_io_v2.RootTrustPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*admin_solo_io_v2.RootTrustPolicy)
	}
	return newMap
}

func (s *rootTrustPolicySet) Insert(
	rootTrustPolicyList ...*admin_solo_io_v2.RootTrustPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range rootTrustPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *rootTrustPolicySet) Has(rootTrustPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(rootTrustPolicy)
}

func (s *rootTrustPolicySet) Equal(
	rootTrustPolicySet RootTrustPolicySet,
) bool {
	if s == nil {
		return rootTrustPolicySet == nil
	}
	return s.Generic().Equal(rootTrustPolicySet.Generic())
}

func (s *rootTrustPolicySet) Delete(RootTrustPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(RootTrustPolicy)
}

func (s *rootTrustPolicySet) Union(set RootTrustPolicySet) RootTrustPolicySet {
	if s == nil {
		return set
	}
	return NewRootTrustPolicySet(append(s.List(), set.List()...)...)
}

func (s *rootTrustPolicySet) Difference(set RootTrustPolicySet) RootTrustPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &rootTrustPolicySet{set: newSet}
}

func (s *rootTrustPolicySet) Intersection(set RootTrustPolicySet) RootTrustPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var rootTrustPolicyList []*admin_solo_io_v2.RootTrustPolicy
	for _, obj := range newSet.List() {
		rootTrustPolicyList = append(rootTrustPolicyList, obj.(*admin_solo_io_v2.RootTrustPolicy))
	}
	return NewRootTrustPolicySet(rootTrustPolicyList...)
}

func (s *rootTrustPolicySet) Find(id ezkube.ResourceId) (*admin_solo_io_v2.RootTrustPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find RootTrustPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&admin_solo_io_v2.RootTrustPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*admin_solo_io_v2.RootTrustPolicy), nil
}

func (s *rootTrustPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *rootTrustPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *rootTrustPolicySet) Delta(newSet RootTrustPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *rootTrustPolicySet) Clone() RootTrustPolicySet {
	if s == nil {
		return nil
	}
	return &rootTrustPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type ExtAuthServerSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*admin_solo_io_v2.ExtAuthServer) bool) []*admin_solo_io_v2.ExtAuthServer
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*admin_solo_io_v2.ExtAuthServer) bool) []*admin_solo_io_v2.ExtAuthServer
	// Return the Set as a map of key to resource.
	Map() map[string]*admin_solo_io_v2.ExtAuthServer
	// Insert a resource into the set.
	Insert(extAuthServer ...*admin_solo_io_v2.ExtAuthServer)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(extAuthServerSet ExtAuthServerSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(extAuthServer ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(extAuthServer ezkube.ResourceId)
	// Return the union with the provided set
	Union(set ExtAuthServerSet) ExtAuthServerSet
	// Return the difference with the provided set
	Difference(set ExtAuthServerSet) ExtAuthServerSet
	// Return the intersection with the provided set
	Intersection(set ExtAuthServerSet) ExtAuthServerSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*admin_solo_io_v2.ExtAuthServer, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another ExtAuthServerSet
	Delta(newSet ExtAuthServerSet) sksets.ResourceDelta
	// Create a deep copy of the current ExtAuthServerSet
	Clone() ExtAuthServerSet
}

func makeGenericExtAuthServerSet(extAuthServerList []*admin_solo_io_v2.ExtAuthServer) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range extAuthServerList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type extAuthServerSet struct {
	set sksets.ResourceSet
}

func NewExtAuthServerSet(extAuthServerList ...*admin_solo_io_v2.ExtAuthServer) ExtAuthServerSet {
	return &extAuthServerSet{set: makeGenericExtAuthServerSet(extAuthServerList)}
}

func NewExtAuthServerSetFromList(extAuthServerList *admin_solo_io_v2.ExtAuthServerList) ExtAuthServerSet {
	list := make([]*admin_solo_io_v2.ExtAuthServer, 0, len(extAuthServerList.Items))
	for idx := range extAuthServerList.Items {
		list = append(list, &extAuthServerList.Items[idx])
	}
	return &extAuthServerSet{set: makeGenericExtAuthServerSet(list)}
}

func (s *extAuthServerSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *extAuthServerSet) List(filterResource ...func(*admin_solo_io_v2.ExtAuthServer) bool) []*admin_solo_io_v2.ExtAuthServer {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.ExtAuthServer))
		})
	}

	objs := s.Generic().List(genericFilters...)
	extAuthServerList := make([]*admin_solo_io_v2.ExtAuthServer, 0, len(objs))
	for _, obj := range objs {
		extAuthServerList = append(extAuthServerList, obj.(*admin_solo_io_v2.ExtAuthServer))
	}
	return extAuthServerList
}

func (s *extAuthServerSet) UnsortedList(filterResource ...func(*admin_solo_io_v2.ExtAuthServer) bool) []*admin_solo_io_v2.ExtAuthServer {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.ExtAuthServer))
		})
	}

	var extAuthServerList []*admin_solo_io_v2.ExtAuthServer
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		extAuthServerList = append(extAuthServerList, obj.(*admin_solo_io_v2.ExtAuthServer))
	}
	return extAuthServerList
}

func (s *extAuthServerSet) Map() map[string]*admin_solo_io_v2.ExtAuthServer {
	if s == nil {
		return nil
	}

	newMap := map[string]*admin_solo_io_v2.ExtAuthServer{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*admin_solo_io_v2.ExtAuthServer)
	}
	return newMap
}

func (s *extAuthServerSet) Insert(
	extAuthServerList ...*admin_solo_io_v2.ExtAuthServer,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range extAuthServerList {
		s.Generic().Insert(obj)
	}
}

func (s *extAuthServerSet) Has(extAuthServer ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(extAuthServer)
}

func (s *extAuthServerSet) Equal(
	extAuthServerSet ExtAuthServerSet,
) bool {
	if s == nil {
		return extAuthServerSet == nil
	}
	return s.Generic().Equal(extAuthServerSet.Generic())
}

func (s *extAuthServerSet) Delete(ExtAuthServer ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(ExtAuthServer)
}

func (s *extAuthServerSet) Union(set ExtAuthServerSet) ExtAuthServerSet {
	if s == nil {
		return set
	}
	return NewExtAuthServerSet(append(s.List(), set.List()...)...)
}

func (s *extAuthServerSet) Difference(set ExtAuthServerSet) ExtAuthServerSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &extAuthServerSet{set: newSet}
}

func (s *extAuthServerSet) Intersection(set ExtAuthServerSet) ExtAuthServerSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var extAuthServerList []*admin_solo_io_v2.ExtAuthServer
	for _, obj := range newSet.List() {
		extAuthServerList = append(extAuthServerList, obj.(*admin_solo_io_v2.ExtAuthServer))
	}
	return NewExtAuthServerSet(extAuthServerList...)
}

func (s *extAuthServerSet) Find(id ezkube.ResourceId) (*admin_solo_io_v2.ExtAuthServer, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find ExtAuthServer %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&admin_solo_io_v2.ExtAuthServer{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*admin_solo_io_v2.ExtAuthServer), nil
}

func (s *extAuthServerSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *extAuthServerSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *extAuthServerSet) Delta(newSet ExtAuthServerSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *extAuthServerSet) Clone() ExtAuthServerSet {
	if s == nil {
		return nil
	}
	return &extAuthServerSet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type RateLimitServerSettingsSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*admin_solo_io_v2.RateLimitServerSettings) bool) []*admin_solo_io_v2.RateLimitServerSettings
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*admin_solo_io_v2.RateLimitServerSettings) bool) []*admin_solo_io_v2.RateLimitServerSettings
	// Return the Set as a map of key to resource.
	Map() map[string]*admin_solo_io_v2.RateLimitServerSettings
	// Insert a resource into the set.
	Insert(rateLimitServerSettings ...*admin_solo_io_v2.RateLimitServerSettings)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(rateLimitServerSettingsSet RateLimitServerSettingsSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(rateLimitServerSettings ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(rateLimitServerSettings ezkube.ResourceId)
	// Return the union with the provided set
	Union(set RateLimitServerSettingsSet) RateLimitServerSettingsSet
	// Return the difference with the provided set
	Difference(set RateLimitServerSettingsSet) RateLimitServerSettingsSet
	// Return the intersection with the provided set
	Intersection(set RateLimitServerSettingsSet) RateLimitServerSettingsSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*admin_solo_io_v2.RateLimitServerSettings, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another RateLimitServerSettingsSet
	Delta(newSet RateLimitServerSettingsSet) sksets.ResourceDelta
	// Create a deep copy of the current RateLimitServerSettingsSet
	Clone() RateLimitServerSettingsSet
}

func makeGenericRateLimitServerSettingsSet(rateLimitServerSettingsList []*admin_solo_io_v2.RateLimitServerSettings) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range rateLimitServerSettingsList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type rateLimitServerSettingsSet struct {
	set sksets.ResourceSet
}

func NewRateLimitServerSettingsSet(rateLimitServerSettingsList ...*admin_solo_io_v2.RateLimitServerSettings) RateLimitServerSettingsSet {
	return &rateLimitServerSettingsSet{set: makeGenericRateLimitServerSettingsSet(rateLimitServerSettingsList)}
}

func NewRateLimitServerSettingsSetFromList(rateLimitServerSettingsList *admin_solo_io_v2.RateLimitServerSettingsList) RateLimitServerSettingsSet {
	list := make([]*admin_solo_io_v2.RateLimitServerSettings, 0, len(rateLimitServerSettingsList.Items))
	for idx := range rateLimitServerSettingsList.Items {
		list = append(list, &rateLimitServerSettingsList.Items[idx])
	}
	return &rateLimitServerSettingsSet{set: makeGenericRateLimitServerSettingsSet(list)}
}

func (s *rateLimitServerSettingsSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *rateLimitServerSettingsSet) List(filterResource ...func(*admin_solo_io_v2.RateLimitServerSettings) bool) []*admin_solo_io_v2.RateLimitServerSettings {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.RateLimitServerSettings))
		})
	}

	objs := s.Generic().List(genericFilters...)
	rateLimitServerSettingsList := make([]*admin_solo_io_v2.RateLimitServerSettings, 0, len(objs))
	for _, obj := range objs {
		rateLimitServerSettingsList = append(rateLimitServerSettingsList, obj.(*admin_solo_io_v2.RateLimitServerSettings))
	}
	return rateLimitServerSettingsList
}

func (s *rateLimitServerSettingsSet) UnsortedList(filterResource ...func(*admin_solo_io_v2.RateLimitServerSettings) bool) []*admin_solo_io_v2.RateLimitServerSettings {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.RateLimitServerSettings))
		})
	}

	var rateLimitServerSettingsList []*admin_solo_io_v2.RateLimitServerSettings
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		rateLimitServerSettingsList = append(rateLimitServerSettingsList, obj.(*admin_solo_io_v2.RateLimitServerSettings))
	}
	return rateLimitServerSettingsList
}

func (s *rateLimitServerSettingsSet) Map() map[string]*admin_solo_io_v2.RateLimitServerSettings {
	if s == nil {
		return nil
	}

	newMap := map[string]*admin_solo_io_v2.RateLimitServerSettings{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*admin_solo_io_v2.RateLimitServerSettings)
	}
	return newMap
}

func (s *rateLimitServerSettingsSet) Insert(
	rateLimitServerSettingsList ...*admin_solo_io_v2.RateLimitServerSettings,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range rateLimitServerSettingsList {
		s.Generic().Insert(obj)
	}
}

func (s *rateLimitServerSettingsSet) Has(rateLimitServerSettings ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(rateLimitServerSettings)
}

func (s *rateLimitServerSettingsSet) Equal(
	rateLimitServerSettingsSet RateLimitServerSettingsSet,
) bool {
	if s == nil {
		return rateLimitServerSettingsSet == nil
	}
	return s.Generic().Equal(rateLimitServerSettingsSet.Generic())
}

func (s *rateLimitServerSettingsSet) Delete(RateLimitServerSettings ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(RateLimitServerSettings)
}

func (s *rateLimitServerSettingsSet) Union(set RateLimitServerSettingsSet) RateLimitServerSettingsSet {
	if s == nil {
		return set
	}
	return NewRateLimitServerSettingsSet(append(s.List(), set.List()...)...)
}

func (s *rateLimitServerSettingsSet) Difference(set RateLimitServerSettingsSet) RateLimitServerSettingsSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &rateLimitServerSettingsSet{set: newSet}
}

func (s *rateLimitServerSettingsSet) Intersection(set RateLimitServerSettingsSet) RateLimitServerSettingsSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var rateLimitServerSettingsList []*admin_solo_io_v2.RateLimitServerSettings
	for _, obj := range newSet.List() {
		rateLimitServerSettingsList = append(rateLimitServerSettingsList, obj.(*admin_solo_io_v2.RateLimitServerSettings))
	}
	return NewRateLimitServerSettingsSet(rateLimitServerSettingsList...)
}

func (s *rateLimitServerSettingsSet) Find(id ezkube.ResourceId) (*admin_solo_io_v2.RateLimitServerSettings, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find RateLimitServerSettings %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&admin_solo_io_v2.RateLimitServerSettings{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*admin_solo_io_v2.RateLimitServerSettings), nil
}

func (s *rateLimitServerSettingsSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *rateLimitServerSettingsSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *rateLimitServerSettingsSet) Delta(newSet RateLimitServerSettingsSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *rateLimitServerSettingsSet) Clone() RateLimitServerSettingsSet {
	if s == nil {
		return nil
	}
	return &rateLimitServerSettingsSet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type RateLimitServerConfigSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*admin_solo_io_v2.RateLimitServerConfig) bool) []*admin_solo_io_v2.RateLimitServerConfig
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*admin_solo_io_v2.RateLimitServerConfig) bool) []*admin_solo_io_v2.RateLimitServerConfig
	// Return the Set as a map of key to resource.
	Map() map[string]*admin_solo_io_v2.RateLimitServerConfig
	// Insert a resource into the set.
	Insert(rateLimitServerConfig ...*admin_solo_io_v2.RateLimitServerConfig)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(rateLimitServerConfigSet RateLimitServerConfigSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(rateLimitServerConfig ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(rateLimitServerConfig ezkube.ResourceId)
	// Return the union with the provided set
	Union(set RateLimitServerConfigSet) RateLimitServerConfigSet
	// Return the difference with the provided set
	Difference(set RateLimitServerConfigSet) RateLimitServerConfigSet
	// Return the intersection with the provided set
	Intersection(set RateLimitServerConfigSet) RateLimitServerConfigSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*admin_solo_io_v2.RateLimitServerConfig, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another RateLimitServerConfigSet
	Delta(newSet RateLimitServerConfigSet) sksets.ResourceDelta
	// Create a deep copy of the current RateLimitServerConfigSet
	Clone() RateLimitServerConfigSet
}

func makeGenericRateLimitServerConfigSet(rateLimitServerConfigList []*admin_solo_io_v2.RateLimitServerConfig) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range rateLimitServerConfigList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type rateLimitServerConfigSet struct {
	set sksets.ResourceSet
}

func NewRateLimitServerConfigSet(rateLimitServerConfigList ...*admin_solo_io_v2.RateLimitServerConfig) RateLimitServerConfigSet {
	return &rateLimitServerConfigSet{set: makeGenericRateLimitServerConfigSet(rateLimitServerConfigList)}
}

func NewRateLimitServerConfigSetFromList(rateLimitServerConfigList *admin_solo_io_v2.RateLimitServerConfigList) RateLimitServerConfigSet {
	list := make([]*admin_solo_io_v2.RateLimitServerConfig, 0, len(rateLimitServerConfigList.Items))
	for idx := range rateLimitServerConfigList.Items {
		list = append(list, &rateLimitServerConfigList.Items[idx])
	}
	return &rateLimitServerConfigSet{set: makeGenericRateLimitServerConfigSet(list)}
}

func (s *rateLimitServerConfigSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *rateLimitServerConfigSet) List(filterResource ...func(*admin_solo_io_v2.RateLimitServerConfig) bool) []*admin_solo_io_v2.RateLimitServerConfig {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.RateLimitServerConfig))
		})
	}

	objs := s.Generic().List(genericFilters...)
	rateLimitServerConfigList := make([]*admin_solo_io_v2.RateLimitServerConfig, 0, len(objs))
	for _, obj := range objs {
		rateLimitServerConfigList = append(rateLimitServerConfigList, obj.(*admin_solo_io_v2.RateLimitServerConfig))
	}
	return rateLimitServerConfigList
}

func (s *rateLimitServerConfigSet) UnsortedList(filterResource ...func(*admin_solo_io_v2.RateLimitServerConfig) bool) []*admin_solo_io_v2.RateLimitServerConfig {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.RateLimitServerConfig))
		})
	}

	var rateLimitServerConfigList []*admin_solo_io_v2.RateLimitServerConfig
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		rateLimitServerConfigList = append(rateLimitServerConfigList, obj.(*admin_solo_io_v2.RateLimitServerConfig))
	}
	return rateLimitServerConfigList
}

func (s *rateLimitServerConfigSet) Map() map[string]*admin_solo_io_v2.RateLimitServerConfig {
	if s == nil {
		return nil
	}

	newMap := map[string]*admin_solo_io_v2.RateLimitServerConfig{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*admin_solo_io_v2.RateLimitServerConfig)
	}
	return newMap
}

func (s *rateLimitServerConfigSet) Insert(
	rateLimitServerConfigList ...*admin_solo_io_v2.RateLimitServerConfig,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range rateLimitServerConfigList {
		s.Generic().Insert(obj)
	}
}

func (s *rateLimitServerConfigSet) Has(rateLimitServerConfig ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(rateLimitServerConfig)
}

func (s *rateLimitServerConfigSet) Equal(
	rateLimitServerConfigSet RateLimitServerConfigSet,
) bool {
	if s == nil {
		return rateLimitServerConfigSet == nil
	}
	return s.Generic().Equal(rateLimitServerConfigSet.Generic())
}

func (s *rateLimitServerConfigSet) Delete(RateLimitServerConfig ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(RateLimitServerConfig)
}

func (s *rateLimitServerConfigSet) Union(set RateLimitServerConfigSet) RateLimitServerConfigSet {
	if s == nil {
		return set
	}
	return NewRateLimitServerConfigSet(append(s.List(), set.List()...)...)
}

func (s *rateLimitServerConfigSet) Difference(set RateLimitServerConfigSet) RateLimitServerConfigSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &rateLimitServerConfigSet{set: newSet}
}

func (s *rateLimitServerConfigSet) Intersection(set RateLimitServerConfigSet) RateLimitServerConfigSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var rateLimitServerConfigList []*admin_solo_io_v2.RateLimitServerConfig
	for _, obj := range newSet.List() {
		rateLimitServerConfigList = append(rateLimitServerConfigList, obj.(*admin_solo_io_v2.RateLimitServerConfig))
	}
	return NewRateLimitServerConfigSet(rateLimitServerConfigList...)
}

func (s *rateLimitServerConfigSet) Find(id ezkube.ResourceId) (*admin_solo_io_v2.RateLimitServerConfig, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find RateLimitServerConfig %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&admin_solo_io_v2.RateLimitServerConfig{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*admin_solo_io_v2.RateLimitServerConfig), nil
}

func (s *rateLimitServerConfigSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *rateLimitServerConfigSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *rateLimitServerConfigSet) Delta(newSet RateLimitServerConfigSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *rateLimitServerConfigSet) Clone() RateLimitServerConfigSet {
	if s == nil {
		return nil
	}
	return &rateLimitServerConfigSet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type DashboardSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*admin_solo_io_v2.Dashboard) bool) []*admin_solo_io_v2.Dashboard
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*admin_solo_io_v2.Dashboard) bool) []*admin_solo_io_v2.Dashboard
	// Return the Set as a map of key to resource.
	Map() map[string]*admin_solo_io_v2.Dashboard
	// Insert a resource into the set.
	Insert(dashboard ...*admin_solo_io_v2.Dashboard)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(dashboardSet DashboardSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(dashboard ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(dashboard ezkube.ResourceId)
	// Return the union with the provided set
	Union(set DashboardSet) DashboardSet
	// Return the difference with the provided set
	Difference(set DashboardSet) DashboardSet
	// Return the intersection with the provided set
	Intersection(set DashboardSet) DashboardSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*admin_solo_io_v2.Dashboard, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another DashboardSet
	Delta(newSet DashboardSet) sksets.ResourceDelta
	// Create a deep copy of the current DashboardSet
	Clone() DashboardSet
}

func makeGenericDashboardSet(dashboardList []*admin_solo_io_v2.Dashboard) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range dashboardList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type dashboardSet struct {
	set sksets.ResourceSet
}

func NewDashboardSet(dashboardList ...*admin_solo_io_v2.Dashboard) DashboardSet {
	return &dashboardSet{set: makeGenericDashboardSet(dashboardList)}
}

func NewDashboardSetFromList(dashboardList *admin_solo_io_v2.DashboardList) DashboardSet {
	list := make([]*admin_solo_io_v2.Dashboard, 0, len(dashboardList.Items))
	for idx := range dashboardList.Items {
		list = append(list, &dashboardList.Items[idx])
	}
	return &dashboardSet{set: makeGenericDashboardSet(list)}
}

func (s *dashboardSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *dashboardSet) List(filterResource ...func(*admin_solo_io_v2.Dashboard) bool) []*admin_solo_io_v2.Dashboard {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.Dashboard))
		})
	}

	objs := s.Generic().List(genericFilters...)
	dashboardList := make([]*admin_solo_io_v2.Dashboard, 0, len(objs))
	for _, obj := range objs {
		dashboardList = append(dashboardList, obj.(*admin_solo_io_v2.Dashboard))
	}
	return dashboardList
}

func (s *dashboardSet) UnsortedList(filterResource ...func(*admin_solo_io_v2.Dashboard) bool) []*admin_solo_io_v2.Dashboard {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*admin_solo_io_v2.Dashboard))
		})
	}

	var dashboardList []*admin_solo_io_v2.Dashboard
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		dashboardList = append(dashboardList, obj.(*admin_solo_io_v2.Dashboard))
	}
	return dashboardList
}

func (s *dashboardSet) Map() map[string]*admin_solo_io_v2.Dashboard {
	if s == nil {
		return nil
	}

	newMap := map[string]*admin_solo_io_v2.Dashboard{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*admin_solo_io_v2.Dashboard)
	}
	return newMap
}

func (s *dashboardSet) Insert(
	dashboardList ...*admin_solo_io_v2.Dashboard,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range dashboardList {
		s.Generic().Insert(obj)
	}
}

func (s *dashboardSet) Has(dashboard ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(dashboard)
}

func (s *dashboardSet) Equal(
	dashboardSet DashboardSet,
) bool {
	if s == nil {
		return dashboardSet == nil
	}
	return s.Generic().Equal(dashboardSet.Generic())
}

func (s *dashboardSet) Delete(Dashboard ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(Dashboard)
}

func (s *dashboardSet) Union(set DashboardSet) DashboardSet {
	if s == nil {
		return set
	}
	return NewDashboardSet(append(s.List(), set.List()...)...)
}

func (s *dashboardSet) Difference(set DashboardSet) DashboardSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &dashboardSet{set: newSet}
}

func (s *dashboardSet) Intersection(set DashboardSet) DashboardSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var dashboardList []*admin_solo_io_v2.Dashboard
	for _, obj := range newSet.List() {
		dashboardList = append(dashboardList, obj.(*admin_solo_io_v2.Dashboard))
	}
	return NewDashboardSet(dashboardList...)
}

func (s *dashboardSet) Find(id ezkube.ResourceId) (*admin_solo_io_v2.Dashboard, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Dashboard %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&admin_solo_io_v2.Dashboard{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*admin_solo_io_v2.Dashboard), nil
}

func (s *dashboardSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *dashboardSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *dashboardSet) Delta(newSet DashboardSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *dashboardSet) Clone() DashboardSet {
	if s == nil {
		return nil
	}
	return &dashboardSet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}
