// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./reconcilers.go -destination mocks/reconcilers.go

// Definitions for the Kubernetes Controllers
package controller



import (
	"context"

    fed_gateway_solo_io_v1 "github.com/solo-io/solo-apis/pkg/api/fed.gateway.solo.io/v1"

    "github.com/pkg/errors"
    "github.com/solo-io/skv2/pkg/ezkube"
    "github.com/solo-io/skv2/pkg/reconcile"
    "sigs.k8s.io/controller-runtime/pkg/manager"
    "sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the FederatedGateway Resource.
// implemented by the user
type FederatedGatewayReconciler interface {
    ReconcileFederatedGateway(obj *fed_gateway_solo_io_v1.FederatedGateway) (reconcile.Result, error)
}

// Reconcile deletion events for the FederatedGateway Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type FederatedGatewayDeletionReconciler interface {
    ReconcileFederatedGatewayDeletion(req reconcile.Request) error
}

type FederatedGatewayReconcilerFuncs struct {
    OnReconcileFederatedGateway func(obj *fed_gateway_solo_io_v1.FederatedGateway) (reconcile.Result, error)
    OnReconcileFederatedGatewayDeletion func(req reconcile.Request) error
}

func (f *FederatedGatewayReconcilerFuncs) ReconcileFederatedGateway(obj *fed_gateway_solo_io_v1.FederatedGateway) (reconcile.Result, error) {
    if f.OnReconcileFederatedGateway == nil {
        return reconcile.Result{}, nil
    }
    return f.OnReconcileFederatedGateway(obj)
}

func (f *FederatedGatewayReconcilerFuncs) ReconcileFederatedGatewayDeletion(req reconcile.Request) error {
    if f.OnReconcileFederatedGatewayDeletion == nil {
        return nil
    }
    return f.OnReconcileFederatedGatewayDeletion(req)
}

// Reconcile and finalize the FederatedGateway Resource
// implemented by the user
type FederatedGatewayFinalizer interface {
    FederatedGatewayReconciler

    // name of the finalizer used by this handler.
    // finalizer names should be unique for a single task
    FederatedGatewayFinalizerName() string

    // finalize the object before it is deleted.
    // Watchers created with a finalizing handler will a
    FinalizeFederatedGateway(obj *fed_gateway_solo_io_v1.FederatedGateway) error
}

type FederatedGatewayReconcileLoop interface {
    RunFederatedGatewayReconciler(ctx context.Context, rec FederatedGatewayReconciler, predicates ...predicate.Predicate) error
}

type federatedGatewayReconcileLoop struct {
    loop reconcile.Loop
}

func NewFederatedGatewayReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) FederatedGatewayReconcileLoop {
    return &federatedGatewayReconcileLoop{
    	// empty cluster indicates this reconciler is built for the local cluster
        loop: reconcile.NewLoop(name, "", mgr, &fed_gateway_solo_io_v1.FederatedGateway{}, options),
    }
}

func (c *federatedGatewayReconcileLoop) RunFederatedGatewayReconciler(ctx context.Context, reconciler FederatedGatewayReconciler, predicates ...predicate.Predicate) error {
    genericReconciler := genericFederatedGatewayReconciler{
        reconciler: reconciler,
    }

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(FederatedGatewayFinalizer); ok {
        reconcilerWrapper = genericFederatedGatewayFinalizer{
            genericFederatedGatewayReconciler: genericReconciler,
            finalizingReconciler: finalizingReconciler,
        }
    } else {
        reconcilerWrapper = genericReconciler
    }
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericFederatedGatewayHandler implements a generic reconcile.Reconciler
type genericFederatedGatewayReconciler struct {
    reconciler FederatedGatewayReconciler
}

func (r genericFederatedGatewayReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
    obj, ok := object.(*fed_gateway_solo_io_v1.FederatedGateway)
    if !ok {
        return reconcile.Result{}, errors.Errorf("internal error: FederatedGateway handler received event for %T", object)
    }
    return r.reconciler.ReconcileFederatedGateway(obj)
}

func (r genericFederatedGatewayReconciler) ReconcileDeletion(request reconcile.Request) error {
    if deletionReconciler, ok := r.reconciler.(FederatedGatewayDeletionReconciler); ok {
        return deletionReconciler.ReconcileFederatedGatewayDeletion(request)
    }
    return nil
}

// genericFederatedGatewayFinalizer implements a generic reconcile.FinalizingReconciler
type genericFederatedGatewayFinalizer struct {
    genericFederatedGatewayReconciler
    finalizingReconciler FederatedGatewayFinalizer
}


func (r genericFederatedGatewayFinalizer) FinalizerName() string {
    return r.finalizingReconciler.FederatedGatewayFinalizerName()
}

func (r genericFederatedGatewayFinalizer) Finalize(object ezkube.Object) error {
    obj, ok := object.(*fed_gateway_solo_io_v1.FederatedGateway)
    if !ok {
        return errors.Errorf("internal error: FederatedGateway handler received event for %T", object)
    }
    return r.finalizingReconciler.FinalizeFederatedGateway(obj)
}

// Reconcile Upsert events for the FederatedMatchableHttpGateway Resource.
// implemented by the user
type FederatedMatchableHttpGatewayReconciler interface {
    ReconcileFederatedMatchableHttpGateway(obj *fed_gateway_solo_io_v1.FederatedMatchableHttpGateway) (reconcile.Result, error)
}

// Reconcile deletion events for the FederatedMatchableHttpGateway Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type FederatedMatchableHttpGatewayDeletionReconciler interface {
    ReconcileFederatedMatchableHttpGatewayDeletion(req reconcile.Request) error
}

type FederatedMatchableHttpGatewayReconcilerFuncs struct {
    OnReconcileFederatedMatchableHttpGateway func(obj *fed_gateway_solo_io_v1.FederatedMatchableHttpGateway) (reconcile.Result, error)
    OnReconcileFederatedMatchableHttpGatewayDeletion func(req reconcile.Request) error
}

func (f *FederatedMatchableHttpGatewayReconcilerFuncs) ReconcileFederatedMatchableHttpGateway(obj *fed_gateway_solo_io_v1.FederatedMatchableHttpGateway) (reconcile.Result, error) {
    if f.OnReconcileFederatedMatchableHttpGateway == nil {
        return reconcile.Result{}, nil
    }
    return f.OnReconcileFederatedMatchableHttpGateway(obj)
}

func (f *FederatedMatchableHttpGatewayReconcilerFuncs) ReconcileFederatedMatchableHttpGatewayDeletion(req reconcile.Request) error {
    if f.OnReconcileFederatedMatchableHttpGatewayDeletion == nil {
        return nil
    }
    return f.OnReconcileFederatedMatchableHttpGatewayDeletion(req)
}

// Reconcile and finalize the FederatedMatchableHttpGateway Resource
// implemented by the user
type FederatedMatchableHttpGatewayFinalizer interface {
    FederatedMatchableHttpGatewayReconciler

    // name of the finalizer used by this handler.
    // finalizer names should be unique for a single task
    FederatedMatchableHttpGatewayFinalizerName() string

    // finalize the object before it is deleted.
    // Watchers created with a finalizing handler will a
    FinalizeFederatedMatchableHttpGateway(obj *fed_gateway_solo_io_v1.FederatedMatchableHttpGateway) error
}

type FederatedMatchableHttpGatewayReconcileLoop interface {
    RunFederatedMatchableHttpGatewayReconciler(ctx context.Context, rec FederatedMatchableHttpGatewayReconciler, predicates ...predicate.Predicate) error
}

type federatedMatchableHttpGatewayReconcileLoop struct {
    loop reconcile.Loop
}

func NewFederatedMatchableHttpGatewayReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) FederatedMatchableHttpGatewayReconcileLoop {
    return &federatedMatchableHttpGatewayReconcileLoop{
    	// empty cluster indicates this reconciler is built for the local cluster
        loop: reconcile.NewLoop(name, "", mgr, &fed_gateway_solo_io_v1.FederatedMatchableHttpGateway{}, options),
    }
}

func (c *federatedMatchableHttpGatewayReconcileLoop) RunFederatedMatchableHttpGatewayReconciler(ctx context.Context, reconciler FederatedMatchableHttpGatewayReconciler, predicates ...predicate.Predicate) error {
    genericReconciler := genericFederatedMatchableHttpGatewayReconciler{
        reconciler: reconciler,
    }

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(FederatedMatchableHttpGatewayFinalizer); ok {
        reconcilerWrapper = genericFederatedMatchableHttpGatewayFinalizer{
            genericFederatedMatchableHttpGatewayReconciler: genericReconciler,
            finalizingReconciler: finalizingReconciler,
        }
    } else {
        reconcilerWrapper = genericReconciler
    }
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericFederatedMatchableHttpGatewayHandler implements a generic reconcile.Reconciler
type genericFederatedMatchableHttpGatewayReconciler struct {
    reconciler FederatedMatchableHttpGatewayReconciler
}

func (r genericFederatedMatchableHttpGatewayReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
    obj, ok := object.(*fed_gateway_solo_io_v1.FederatedMatchableHttpGateway)
    if !ok {
        return reconcile.Result{}, errors.Errorf("internal error: FederatedMatchableHttpGateway handler received event for %T", object)
    }
    return r.reconciler.ReconcileFederatedMatchableHttpGateway(obj)
}

func (r genericFederatedMatchableHttpGatewayReconciler) ReconcileDeletion(request reconcile.Request) error {
    if deletionReconciler, ok := r.reconciler.(FederatedMatchableHttpGatewayDeletionReconciler); ok {
        return deletionReconciler.ReconcileFederatedMatchableHttpGatewayDeletion(request)
    }
    return nil
}

// genericFederatedMatchableHttpGatewayFinalizer implements a generic reconcile.FinalizingReconciler
type genericFederatedMatchableHttpGatewayFinalizer struct {
    genericFederatedMatchableHttpGatewayReconciler
    finalizingReconciler FederatedMatchableHttpGatewayFinalizer
}


func (r genericFederatedMatchableHttpGatewayFinalizer) FinalizerName() string {
    return r.finalizingReconciler.FederatedMatchableHttpGatewayFinalizerName()
}

func (r genericFederatedMatchableHttpGatewayFinalizer) Finalize(object ezkube.Object) error {
    obj, ok := object.(*fed_gateway_solo_io_v1.FederatedMatchableHttpGateway)
    if !ok {
        return errors.Errorf("internal error: FederatedMatchableHttpGateway handler received event for %T", object)
    }
    return r.finalizingReconciler.FinalizeFederatedMatchableHttpGateway(obj)
}

// Reconcile Upsert events for the FederatedMatchableTcpGateway Resource.
// implemented by the user
type FederatedMatchableTcpGatewayReconciler interface {
    ReconcileFederatedMatchableTcpGateway(obj *fed_gateway_solo_io_v1.FederatedMatchableTcpGateway) (reconcile.Result, error)
}

// Reconcile deletion events for the FederatedMatchableTcpGateway Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type FederatedMatchableTcpGatewayDeletionReconciler interface {
    ReconcileFederatedMatchableTcpGatewayDeletion(req reconcile.Request) error
}

type FederatedMatchableTcpGatewayReconcilerFuncs struct {
    OnReconcileFederatedMatchableTcpGateway func(obj *fed_gateway_solo_io_v1.FederatedMatchableTcpGateway) (reconcile.Result, error)
    OnReconcileFederatedMatchableTcpGatewayDeletion func(req reconcile.Request) error
}

func (f *FederatedMatchableTcpGatewayReconcilerFuncs) ReconcileFederatedMatchableTcpGateway(obj *fed_gateway_solo_io_v1.FederatedMatchableTcpGateway) (reconcile.Result, error) {
    if f.OnReconcileFederatedMatchableTcpGateway == nil {
        return reconcile.Result{}, nil
    }
    return f.OnReconcileFederatedMatchableTcpGateway(obj)
}

func (f *FederatedMatchableTcpGatewayReconcilerFuncs) ReconcileFederatedMatchableTcpGatewayDeletion(req reconcile.Request) error {
    if f.OnReconcileFederatedMatchableTcpGatewayDeletion == nil {
        return nil
    }
    return f.OnReconcileFederatedMatchableTcpGatewayDeletion(req)
}

// Reconcile and finalize the FederatedMatchableTcpGateway Resource
// implemented by the user
type FederatedMatchableTcpGatewayFinalizer interface {
    FederatedMatchableTcpGatewayReconciler

    // name of the finalizer used by this handler.
    // finalizer names should be unique for a single task
    FederatedMatchableTcpGatewayFinalizerName() string

    // finalize the object before it is deleted.
    // Watchers created with a finalizing handler will a
    FinalizeFederatedMatchableTcpGateway(obj *fed_gateway_solo_io_v1.FederatedMatchableTcpGateway) error
}

type FederatedMatchableTcpGatewayReconcileLoop interface {
    RunFederatedMatchableTcpGatewayReconciler(ctx context.Context, rec FederatedMatchableTcpGatewayReconciler, predicates ...predicate.Predicate) error
}

type federatedMatchableTcpGatewayReconcileLoop struct {
    loop reconcile.Loop
}

func NewFederatedMatchableTcpGatewayReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) FederatedMatchableTcpGatewayReconcileLoop {
    return &federatedMatchableTcpGatewayReconcileLoop{
    	// empty cluster indicates this reconciler is built for the local cluster
        loop: reconcile.NewLoop(name, "", mgr, &fed_gateway_solo_io_v1.FederatedMatchableTcpGateway{}, options),
    }
}

func (c *federatedMatchableTcpGatewayReconcileLoop) RunFederatedMatchableTcpGatewayReconciler(ctx context.Context, reconciler FederatedMatchableTcpGatewayReconciler, predicates ...predicate.Predicate) error {
    genericReconciler := genericFederatedMatchableTcpGatewayReconciler{
        reconciler: reconciler,
    }

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(FederatedMatchableTcpGatewayFinalizer); ok {
        reconcilerWrapper = genericFederatedMatchableTcpGatewayFinalizer{
            genericFederatedMatchableTcpGatewayReconciler: genericReconciler,
            finalizingReconciler: finalizingReconciler,
        }
    } else {
        reconcilerWrapper = genericReconciler
    }
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericFederatedMatchableTcpGatewayHandler implements a generic reconcile.Reconciler
type genericFederatedMatchableTcpGatewayReconciler struct {
    reconciler FederatedMatchableTcpGatewayReconciler
}

func (r genericFederatedMatchableTcpGatewayReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
    obj, ok := object.(*fed_gateway_solo_io_v1.FederatedMatchableTcpGateway)
    if !ok {
        return reconcile.Result{}, errors.Errorf("internal error: FederatedMatchableTcpGateway handler received event for %T", object)
    }
    return r.reconciler.ReconcileFederatedMatchableTcpGateway(obj)
}

func (r genericFederatedMatchableTcpGatewayReconciler) ReconcileDeletion(request reconcile.Request) error {
    if deletionReconciler, ok := r.reconciler.(FederatedMatchableTcpGatewayDeletionReconciler); ok {
        return deletionReconciler.ReconcileFederatedMatchableTcpGatewayDeletion(request)
    }
    return nil
}

// genericFederatedMatchableTcpGatewayFinalizer implements a generic reconcile.FinalizingReconciler
type genericFederatedMatchableTcpGatewayFinalizer struct {
    genericFederatedMatchableTcpGatewayReconciler
    finalizingReconciler FederatedMatchableTcpGatewayFinalizer
}


func (r genericFederatedMatchableTcpGatewayFinalizer) FinalizerName() string {
    return r.finalizingReconciler.FederatedMatchableTcpGatewayFinalizerName()
}

func (r genericFederatedMatchableTcpGatewayFinalizer) Finalize(object ezkube.Object) error {
    obj, ok := object.(*fed_gateway_solo_io_v1.FederatedMatchableTcpGateway)
    if !ok {
        return errors.Errorf("internal error: FederatedMatchableTcpGateway handler received event for %T", object)
    }
    return r.finalizingReconciler.FinalizeFederatedMatchableTcpGateway(obj)
}

// Reconcile Upsert events for the FederatedRouteTable Resource.
// implemented by the user
type FederatedRouteTableReconciler interface {
    ReconcileFederatedRouteTable(obj *fed_gateway_solo_io_v1.FederatedRouteTable) (reconcile.Result, error)
}

// Reconcile deletion events for the FederatedRouteTable Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type FederatedRouteTableDeletionReconciler interface {
    ReconcileFederatedRouteTableDeletion(req reconcile.Request) error
}

type FederatedRouteTableReconcilerFuncs struct {
    OnReconcileFederatedRouteTable func(obj *fed_gateway_solo_io_v1.FederatedRouteTable) (reconcile.Result, error)
    OnReconcileFederatedRouteTableDeletion func(req reconcile.Request) error
}

func (f *FederatedRouteTableReconcilerFuncs) ReconcileFederatedRouteTable(obj *fed_gateway_solo_io_v1.FederatedRouteTable) (reconcile.Result, error) {
    if f.OnReconcileFederatedRouteTable == nil {
        return reconcile.Result{}, nil
    }
    return f.OnReconcileFederatedRouteTable(obj)
}

func (f *FederatedRouteTableReconcilerFuncs) ReconcileFederatedRouteTableDeletion(req reconcile.Request) error {
    if f.OnReconcileFederatedRouteTableDeletion == nil {
        return nil
    }
    return f.OnReconcileFederatedRouteTableDeletion(req)
}

// Reconcile and finalize the FederatedRouteTable Resource
// implemented by the user
type FederatedRouteTableFinalizer interface {
    FederatedRouteTableReconciler

    // name of the finalizer used by this handler.
    // finalizer names should be unique for a single task
    FederatedRouteTableFinalizerName() string

    // finalize the object before it is deleted.
    // Watchers created with a finalizing handler will a
    FinalizeFederatedRouteTable(obj *fed_gateway_solo_io_v1.FederatedRouteTable) error
}

type FederatedRouteTableReconcileLoop interface {
    RunFederatedRouteTableReconciler(ctx context.Context, rec FederatedRouteTableReconciler, predicates ...predicate.Predicate) error
}

type federatedRouteTableReconcileLoop struct {
    loop reconcile.Loop
}

func NewFederatedRouteTableReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) FederatedRouteTableReconcileLoop {
    return &federatedRouteTableReconcileLoop{
    	// empty cluster indicates this reconciler is built for the local cluster
        loop: reconcile.NewLoop(name, "", mgr, &fed_gateway_solo_io_v1.FederatedRouteTable{}, options),
    }
}

func (c *federatedRouteTableReconcileLoop) RunFederatedRouteTableReconciler(ctx context.Context, reconciler FederatedRouteTableReconciler, predicates ...predicate.Predicate) error {
    genericReconciler := genericFederatedRouteTableReconciler{
        reconciler: reconciler,
    }

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(FederatedRouteTableFinalizer); ok {
        reconcilerWrapper = genericFederatedRouteTableFinalizer{
            genericFederatedRouteTableReconciler: genericReconciler,
            finalizingReconciler: finalizingReconciler,
        }
    } else {
        reconcilerWrapper = genericReconciler
    }
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericFederatedRouteTableHandler implements a generic reconcile.Reconciler
type genericFederatedRouteTableReconciler struct {
    reconciler FederatedRouteTableReconciler
}

func (r genericFederatedRouteTableReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
    obj, ok := object.(*fed_gateway_solo_io_v1.FederatedRouteTable)
    if !ok {
        return reconcile.Result{}, errors.Errorf("internal error: FederatedRouteTable handler received event for %T", object)
    }
    return r.reconciler.ReconcileFederatedRouteTable(obj)
}

func (r genericFederatedRouteTableReconciler) ReconcileDeletion(request reconcile.Request) error {
    if deletionReconciler, ok := r.reconciler.(FederatedRouteTableDeletionReconciler); ok {
        return deletionReconciler.ReconcileFederatedRouteTableDeletion(request)
    }
    return nil
}

// genericFederatedRouteTableFinalizer implements a generic reconcile.FinalizingReconciler
type genericFederatedRouteTableFinalizer struct {
    genericFederatedRouteTableReconciler
    finalizingReconciler FederatedRouteTableFinalizer
}


func (r genericFederatedRouteTableFinalizer) FinalizerName() string {
    return r.finalizingReconciler.FederatedRouteTableFinalizerName()
}

func (r genericFederatedRouteTableFinalizer) Finalize(object ezkube.Object) error {
    obj, ok := object.(*fed_gateway_solo_io_v1.FederatedRouteTable)
    if !ok {
        return errors.Errorf("internal error: FederatedRouteTable handler received event for %T", object)
    }
    return r.finalizingReconciler.FinalizeFederatedRouteTable(obj)
}

// Reconcile Upsert events for the FederatedVirtualService Resource.
// implemented by the user
type FederatedVirtualServiceReconciler interface {
    ReconcileFederatedVirtualService(obj *fed_gateway_solo_io_v1.FederatedVirtualService) (reconcile.Result, error)
}

// Reconcile deletion events for the FederatedVirtualService Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type FederatedVirtualServiceDeletionReconciler interface {
    ReconcileFederatedVirtualServiceDeletion(req reconcile.Request) error
}

type FederatedVirtualServiceReconcilerFuncs struct {
    OnReconcileFederatedVirtualService func(obj *fed_gateway_solo_io_v1.FederatedVirtualService) (reconcile.Result, error)
    OnReconcileFederatedVirtualServiceDeletion func(req reconcile.Request) error
}

func (f *FederatedVirtualServiceReconcilerFuncs) ReconcileFederatedVirtualService(obj *fed_gateway_solo_io_v1.FederatedVirtualService) (reconcile.Result, error) {
    if f.OnReconcileFederatedVirtualService == nil {
        return reconcile.Result{}, nil
    }
    return f.OnReconcileFederatedVirtualService(obj)
}

func (f *FederatedVirtualServiceReconcilerFuncs) ReconcileFederatedVirtualServiceDeletion(req reconcile.Request) error {
    if f.OnReconcileFederatedVirtualServiceDeletion == nil {
        return nil
    }
    return f.OnReconcileFederatedVirtualServiceDeletion(req)
}

// Reconcile and finalize the FederatedVirtualService Resource
// implemented by the user
type FederatedVirtualServiceFinalizer interface {
    FederatedVirtualServiceReconciler

    // name of the finalizer used by this handler.
    // finalizer names should be unique for a single task
    FederatedVirtualServiceFinalizerName() string

    // finalize the object before it is deleted.
    // Watchers created with a finalizing handler will a
    FinalizeFederatedVirtualService(obj *fed_gateway_solo_io_v1.FederatedVirtualService) error
}

type FederatedVirtualServiceReconcileLoop interface {
    RunFederatedVirtualServiceReconciler(ctx context.Context, rec FederatedVirtualServiceReconciler, predicates ...predicate.Predicate) error
}

type federatedVirtualServiceReconcileLoop struct {
    loop reconcile.Loop
}

func NewFederatedVirtualServiceReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) FederatedVirtualServiceReconcileLoop {
    return &federatedVirtualServiceReconcileLoop{
    	// empty cluster indicates this reconciler is built for the local cluster
        loop: reconcile.NewLoop(name, "", mgr, &fed_gateway_solo_io_v1.FederatedVirtualService{}, options),
    }
}

func (c *federatedVirtualServiceReconcileLoop) RunFederatedVirtualServiceReconciler(ctx context.Context, reconciler FederatedVirtualServiceReconciler, predicates ...predicate.Predicate) error {
    genericReconciler := genericFederatedVirtualServiceReconciler{
        reconciler: reconciler,
    }

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(FederatedVirtualServiceFinalizer); ok {
        reconcilerWrapper = genericFederatedVirtualServiceFinalizer{
            genericFederatedVirtualServiceReconciler: genericReconciler,
            finalizingReconciler: finalizingReconciler,
        }
    } else {
        reconcilerWrapper = genericReconciler
    }
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericFederatedVirtualServiceHandler implements a generic reconcile.Reconciler
type genericFederatedVirtualServiceReconciler struct {
    reconciler FederatedVirtualServiceReconciler
}

func (r genericFederatedVirtualServiceReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
    obj, ok := object.(*fed_gateway_solo_io_v1.FederatedVirtualService)
    if !ok {
        return reconcile.Result{}, errors.Errorf("internal error: FederatedVirtualService handler received event for %T", object)
    }
    return r.reconciler.ReconcileFederatedVirtualService(obj)
}

func (r genericFederatedVirtualServiceReconciler) ReconcileDeletion(request reconcile.Request) error {
    if deletionReconciler, ok := r.reconciler.(FederatedVirtualServiceDeletionReconciler); ok {
        return deletionReconciler.ReconcileFederatedVirtualServiceDeletion(request)
    }
    return nil
}

// genericFederatedVirtualServiceFinalizer implements a generic reconcile.FinalizingReconciler
type genericFederatedVirtualServiceFinalizer struct {
    genericFederatedVirtualServiceReconciler
    finalizingReconciler FederatedVirtualServiceFinalizer
}


func (r genericFederatedVirtualServiceFinalizer) FinalizerName() string {
    return r.finalizingReconciler.FederatedVirtualServiceFinalizerName()
}

func (r genericFederatedVirtualServiceFinalizer) Finalize(object ezkube.Object) error {
    obj, ok := object.(*fed_gateway_solo_io_v1.FederatedVirtualService)
    if !ok {
        return errors.Errorf("internal error: FederatedVirtualService handler received event for %T", object)
    }
    return r.finalizingReconciler.FinalizeFederatedVirtualService(obj)
}
