// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./clients.go -destination mocks/clients.go

package v2

import (
	"context"

	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// MulticlusterClientset for the security.solo.io/v2 APIs
type MulticlusterClientset interface {
	// Cluster returns a Clientset for the given cluster
	Cluster(cluster string) (Clientset, error)
}

type multiclusterClientset struct {
	client multicluster.Client
}

func NewMulticlusterClientset(client multicluster.Client) MulticlusterClientset {
	return &multiclusterClientset{client: client}
}

func (m *multiclusterClientset) Cluster(cluster string) (Clientset, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

// clienset for the security.solo.io/v2 APIs
type Clientset interface {
	// clienset for the security.solo.io/v2/v2 APIs
	AccessPolicies() AccessPolicyClient
	// clienset for the security.solo.io/v2/v2 APIs
	CORSPolicies() CORSPolicyClient
	// clienset for the security.solo.io/v2/v2 APIs
	CSRFPolicies() CSRFPolicyClient
	// clienset for the security.solo.io/v2/v2 APIs
	ExtAuthPolicies() ExtAuthPolicyClient
	// clienset for the security.solo.io/v2/v2 APIs
	WAFPolicies() WAFPolicyClient
	// clienset for the security.solo.io/v2/v2 APIs
	JWTPolicies() JWTPolicyClient
}

type clientSet struct {
	client client.Client
}

func NewClientsetFromConfig(cfg *rest.Config) (Clientset, error) {
	scheme := scheme.Scheme
	if err := AddToScheme(scheme); err != nil {
		return nil, err
	}
	client, err := client.New(cfg, client.Options{
		Scheme: scheme,
	})
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

func NewClientset(client client.Client) Clientset {
	return &clientSet{client: client}
}

// clienset for the security.solo.io/v2/v2 APIs
func (c *clientSet) AccessPolicies() AccessPolicyClient {
	return NewAccessPolicyClient(c.client)
}

// clienset for the security.solo.io/v2/v2 APIs
func (c *clientSet) CORSPolicies() CORSPolicyClient {
	return NewCORSPolicyClient(c.client)
}

// clienset for the security.solo.io/v2/v2 APIs
func (c *clientSet) CSRFPolicies() CSRFPolicyClient {
	return NewCSRFPolicyClient(c.client)
}

// clienset for the security.solo.io/v2/v2 APIs
func (c *clientSet) ExtAuthPolicies() ExtAuthPolicyClient {
	return NewExtAuthPolicyClient(c.client)
}

// clienset for the security.solo.io/v2/v2 APIs
func (c *clientSet) WAFPolicies() WAFPolicyClient {
	return NewWAFPolicyClient(c.client)
}

// clienset for the security.solo.io/v2/v2 APIs
func (c *clientSet) JWTPolicies() JWTPolicyClient {
	return NewJWTPolicyClient(c.client)
}

// Reader knows how to read and list AccessPolicys.
type AccessPolicyReader interface {
	// Get retrieves a AccessPolicy for the given object key
	GetAccessPolicy(ctx context.Context, key client.ObjectKey) (*AccessPolicy, error)

	// List retrieves list of AccessPolicys for a given namespace and list options.
	ListAccessPolicy(ctx context.Context, opts ...client.ListOption) (*AccessPolicyList, error)
}

// AccessPolicyTransitionFunction instructs the AccessPolicyWriter how to transition between an existing
// AccessPolicy object and a desired on an Upsert
type AccessPolicyTransitionFunction func(existing, desired *AccessPolicy) error

// Writer knows how to create, delete, and update AccessPolicys.
type AccessPolicyWriter interface {
	// Create saves the AccessPolicy object.
	CreateAccessPolicy(ctx context.Context, obj *AccessPolicy, opts ...client.CreateOption) error

	// Delete deletes the AccessPolicy object.
	DeleteAccessPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given AccessPolicy object.
	UpdateAccessPolicy(ctx context.Context, obj *AccessPolicy, opts ...client.UpdateOption) error

	// Patch patches the given AccessPolicy object.
	PatchAccessPolicy(ctx context.Context, obj *AccessPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all AccessPolicy objects matching the given options.
	DeleteAllOfAccessPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the AccessPolicy object.
	UpsertAccessPolicy(ctx context.Context, obj *AccessPolicy, transitionFuncs ...AccessPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a AccessPolicy object.
type AccessPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given AccessPolicy object.
	UpdateAccessPolicyStatus(ctx context.Context, obj *AccessPolicy, opts ...client.UpdateOption) error

	// Patch patches the given AccessPolicy object's subresource.
	PatchAccessPolicyStatus(ctx context.Context, obj *AccessPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on AccessPolicys.
type AccessPolicyClient interface {
	AccessPolicyReader
	AccessPolicyWriter
	AccessPolicyStatusWriter
}

type accessPolicyClient struct {
	client client.Client
}

func NewAccessPolicyClient(client client.Client) *accessPolicyClient {
	return &accessPolicyClient{client: client}
}

func (c *accessPolicyClient) GetAccessPolicy(ctx context.Context, key client.ObjectKey) (*AccessPolicy, error) {
	obj := &AccessPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *accessPolicyClient) ListAccessPolicy(ctx context.Context, opts ...client.ListOption) (*AccessPolicyList, error) {
	list := &AccessPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *accessPolicyClient) CreateAccessPolicy(ctx context.Context, obj *AccessPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *accessPolicyClient) DeleteAccessPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &AccessPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *accessPolicyClient) UpdateAccessPolicy(ctx context.Context, obj *AccessPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *accessPolicyClient) PatchAccessPolicy(ctx context.Context, obj *AccessPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *accessPolicyClient) DeleteAllOfAccessPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &AccessPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *accessPolicyClient) UpsertAccessPolicy(ctx context.Context, obj *AccessPolicy, transitionFuncs ...AccessPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*AccessPolicy), desired.(*AccessPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *accessPolicyClient) UpdateAccessPolicyStatus(ctx context.Context, obj *AccessPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *accessPolicyClient) PatchAccessPolicyStatus(ctx context.Context, obj *AccessPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides AccessPolicyClients for multiple clusters.
type MulticlusterAccessPolicyClient interface {
	// Cluster returns a AccessPolicyClient for the given cluster
	Cluster(cluster string) (AccessPolicyClient, error)
}

type multiclusterAccessPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterAccessPolicyClient(client multicluster.Client) MulticlusterAccessPolicyClient {
	return &multiclusterAccessPolicyClient{client: client}
}

func (m *multiclusterAccessPolicyClient) Cluster(cluster string) (AccessPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewAccessPolicyClient(client), nil
}

// Reader knows how to read and list CORSPolicys.
type CORSPolicyReader interface {
	// Get retrieves a CORSPolicy for the given object key
	GetCORSPolicy(ctx context.Context, key client.ObjectKey) (*CORSPolicy, error)

	// List retrieves list of CORSPolicys for a given namespace and list options.
	ListCORSPolicy(ctx context.Context, opts ...client.ListOption) (*CORSPolicyList, error)
}

// CORSPolicyTransitionFunction instructs the CORSPolicyWriter how to transition between an existing
// CORSPolicy object and a desired on an Upsert
type CORSPolicyTransitionFunction func(existing, desired *CORSPolicy) error

// Writer knows how to create, delete, and update CORSPolicys.
type CORSPolicyWriter interface {
	// Create saves the CORSPolicy object.
	CreateCORSPolicy(ctx context.Context, obj *CORSPolicy, opts ...client.CreateOption) error

	// Delete deletes the CORSPolicy object.
	DeleteCORSPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given CORSPolicy object.
	UpdateCORSPolicy(ctx context.Context, obj *CORSPolicy, opts ...client.UpdateOption) error

	// Patch patches the given CORSPolicy object.
	PatchCORSPolicy(ctx context.Context, obj *CORSPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all CORSPolicy objects matching the given options.
	DeleteAllOfCORSPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the CORSPolicy object.
	UpsertCORSPolicy(ctx context.Context, obj *CORSPolicy, transitionFuncs ...CORSPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a CORSPolicy object.
type CORSPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given CORSPolicy object.
	UpdateCORSPolicyStatus(ctx context.Context, obj *CORSPolicy, opts ...client.UpdateOption) error

	// Patch patches the given CORSPolicy object's subresource.
	PatchCORSPolicyStatus(ctx context.Context, obj *CORSPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on CORSPolicys.
type CORSPolicyClient interface {
	CORSPolicyReader
	CORSPolicyWriter
	CORSPolicyStatusWriter
}

type cORSPolicyClient struct {
	client client.Client
}

func NewCORSPolicyClient(client client.Client) *cORSPolicyClient {
	return &cORSPolicyClient{client: client}
}

func (c *cORSPolicyClient) GetCORSPolicy(ctx context.Context, key client.ObjectKey) (*CORSPolicy, error) {
	obj := &CORSPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *cORSPolicyClient) ListCORSPolicy(ctx context.Context, opts ...client.ListOption) (*CORSPolicyList, error) {
	list := &CORSPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *cORSPolicyClient) CreateCORSPolicy(ctx context.Context, obj *CORSPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *cORSPolicyClient) DeleteCORSPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &CORSPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *cORSPolicyClient) UpdateCORSPolicy(ctx context.Context, obj *CORSPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *cORSPolicyClient) PatchCORSPolicy(ctx context.Context, obj *CORSPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *cORSPolicyClient) DeleteAllOfCORSPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &CORSPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *cORSPolicyClient) UpsertCORSPolicy(ctx context.Context, obj *CORSPolicy, transitionFuncs ...CORSPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*CORSPolicy), desired.(*CORSPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *cORSPolicyClient) UpdateCORSPolicyStatus(ctx context.Context, obj *CORSPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *cORSPolicyClient) PatchCORSPolicyStatus(ctx context.Context, obj *CORSPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides CORSPolicyClients for multiple clusters.
type MulticlusterCORSPolicyClient interface {
	// Cluster returns a CORSPolicyClient for the given cluster
	Cluster(cluster string) (CORSPolicyClient, error)
}

type multiclusterCORSPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterCORSPolicyClient(client multicluster.Client) MulticlusterCORSPolicyClient {
	return &multiclusterCORSPolicyClient{client: client}
}

func (m *multiclusterCORSPolicyClient) Cluster(cluster string) (CORSPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewCORSPolicyClient(client), nil
}

// Reader knows how to read and list CSRFPolicys.
type CSRFPolicyReader interface {
	// Get retrieves a CSRFPolicy for the given object key
	GetCSRFPolicy(ctx context.Context, key client.ObjectKey) (*CSRFPolicy, error)

	// List retrieves list of CSRFPolicys for a given namespace and list options.
	ListCSRFPolicy(ctx context.Context, opts ...client.ListOption) (*CSRFPolicyList, error)
}

// CSRFPolicyTransitionFunction instructs the CSRFPolicyWriter how to transition between an existing
// CSRFPolicy object and a desired on an Upsert
type CSRFPolicyTransitionFunction func(existing, desired *CSRFPolicy) error

// Writer knows how to create, delete, and update CSRFPolicys.
type CSRFPolicyWriter interface {
	// Create saves the CSRFPolicy object.
	CreateCSRFPolicy(ctx context.Context, obj *CSRFPolicy, opts ...client.CreateOption) error

	// Delete deletes the CSRFPolicy object.
	DeleteCSRFPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given CSRFPolicy object.
	UpdateCSRFPolicy(ctx context.Context, obj *CSRFPolicy, opts ...client.UpdateOption) error

	// Patch patches the given CSRFPolicy object.
	PatchCSRFPolicy(ctx context.Context, obj *CSRFPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all CSRFPolicy objects matching the given options.
	DeleteAllOfCSRFPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the CSRFPolicy object.
	UpsertCSRFPolicy(ctx context.Context, obj *CSRFPolicy, transitionFuncs ...CSRFPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a CSRFPolicy object.
type CSRFPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given CSRFPolicy object.
	UpdateCSRFPolicyStatus(ctx context.Context, obj *CSRFPolicy, opts ...client.UpdateOption) error

	// Patch patches the given CSRFPolicy object's subresource.
	PatchCSRFPolicyStatus(ctx context.Context, obj *CSRFPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on CSRFPolicys.
type CSRFPolicyClient interface {
	CSRFPolicyReader
	CSRFPolicyWriter
	CSRFPolicyStatusWriter
}

type cSRFPolicyClient struct {
	client client.Client
}

func NewCSRFPolicyClient(client client.Client) *cSRFPolicyClient {
	return &cSRFPolicyClient{client: client}
}

func (c *cSRFPolicyClient) GetCSRFPolicy(ctx context.Context, key client.ObjectKey) (*CSRFPolicy, error) {
	obj := &CSRFPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *cSRFPolicyClient) ListCSRFPolicy(ctx context.Context, opts ...client.ListOption) (*CSRFPolicyList, error) {
	list := &CSRFPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *cSRFPolicyClient) CreateCSRFPolicy(ctx context.Context, obj *CSRFPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *cSRFPolicyClient) DeleteCSRFPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &CSRFPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *cSRFPolicyClient) UpdateCSRFPolicy(ctx context.Context, obj *CSRFPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *cSRFPolicyClient) PatchCSRFPolicy(ctx context.Context, obj *CSRFPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *cSRFPolicyClient) DeleteAllOfCSRFPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &CSRFPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *cSRFPolicyClient) UpsertCSRFPolicy(ctx context.Context, obj *CSRFPolicy, transitionFuncs ...CSRFPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*CSRFPolicy), desired.(*CSRFPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *cSRFPolicyClient) UpdateCSRFPolicyStatus(ctx context.Context, obj *CSRFPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *cSRFPolicyClient) PatchCSRFPolicyStatus(ctx context.Context, obj *CSRFPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides CSRFPolicyClients for multiple clusters.
type MulticlusterCSRFPolicyClient interface {
	// Cluster returns a CSRFPolicyClient for the given cluster
	Cluster(cluster string) (CSRFPolicyClient, error)
}

type multiclusterCSRFPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterCSRFPolicyClient(client multicluster.Client) MulticlusterCSRFPolicyClient {
	return &multiclusterCSRFPolicyClient{client: client}
}

func (m *multiclusterCSRFPolicyClient) Cluster(cluster string) (CSRFPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewCSRFPolicyClient(client), nil
}

// Reader knows how to read and list ExtAuthPolicys.
type ExtAuthPolicyReader interface {
	// Get retrieves a ExtAuthPolicy for the given object key
	GetExtAuthPolicy(ctx context.Context, key client.ObjectKey) (*ExtAuthPolicy, error)

	// List retrieves list of ExtAuthPolicys for a given namespace and list options.
	ListExtAuthPolicy(ctx context.Context, opts ...client.ListOption) (*ExtAuthPolicyList, error)
}

// ExtAuthPolicyTransitionFunction instructs the ExtAuthPolicyWriter how to transition between an existing
// ExtAuthPolicy object and a desired on an Upsert
type ExtAuthPolicyTransitionFunction func(existing, desired *ExtAuthPolicy) error

// Writer knows how to create, delete, and update ExtAuthPolicys.
type ExtAuthPolicyWriter interface {
	// Create saves the ExtAuthPolicy object.
	CreateExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, opts ...client.CreateOption) error

	// Delete deletes the ExtAuthPolicy object.
	DeleteExtAuthPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given ExtAuthPolicy object.
	UpdateExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, opts ...client.UpdateOption) error

	// Patch patches the given ExtAuthPolicy object.
	PatchExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all ExtAuthPolicy objects matching the given options.
	DeleteAllOfExtAuthPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the ExtAuthPolicy object.
	UpsertExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, transitionFuncs ...ExtAuthPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a ExtAuthPolicy object.
type ExtAuthPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given ExtAuthPolicy object.
	UpdateExtAuthPolicyStatus(ctx context.Context, obj *ExtAuthPolicy, opts ...client.UpdateOption) error

	// Patch patches the given ExtAuthPolicy object's subresource.
	PatchExtAuthPolicyStatus(ctx context.Context, obj *ExtAuthPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on ExtAuthPolicys.
type ExtAuthPolicyClient interface {
	ExtAuthPolicyReader
	ExtAuthPolicyWriter
	ExtAuthPolicyStatusWriter
}

type extAuthPolicyClient struct {
	client client.Client
}

func NewExtAuthPolicyClient(client client.Client) *extAuthPolicyClient {
	return &extAuthPolicyClient{client: client}
}

func (c *extAuthPolicyClient) GetExtAuthPolicy(ctx context.Context, key client.ObjectKey) (*ExtAuthPolicy, error) {
	obj := &ExtAuthPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *extAuthPolicyClient) ListExtAuthPolicy(ctx context.Context, opts ...client.ListOption) (*ExtAuthPolicyList, error) {
	list := &ExtAuthPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *extAuthPolicyClient) CreateExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *extAuthPolicyClient) DeleteExtAuthPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &ExtAuthPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *extAuthPolicyClient) UpdateExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *extAuthPolicyClient) PatchExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *extAuthPolicyClient) DeleteAllOfExtAuthPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &ExtAuthPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *extAuthPolicyClient) UpsertExtAuthPolicy(ctx context.Context, obj *ExtAuthPolicy, transitionFuncs ...ExtAuthPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*ExtAuthPolicy), desired.(*ExtAuthPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *extAuthPolicyClient) UpdateExtAuthPolicyStatus(ctx context.Context, obj *ExtAuthPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *extAuthPolicyClient) PatchExtAuthPolicyStatus(ctx context.Context, obj *ExtAuthPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides ExtAuthPolicyClients for multiple clusters.
type MulticlusterExtAuthPolicyClient interface {
	// Cluster returns a ExtAuthPolicyClient for the given cluster
	Cluster(cluster string) (ExtAuthPolicyClient, error)
}

type multiclusterExtAuthPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterExtAuthPolicyClient(client multicluster.Client) MulticlusterExtAuthPolicyClient {
	return &multiclusterExtAuthPolicyClient{client: client}
}

func (m *multiclusterExtAuthPolicyClient) Cluster(cluster string) (ExtAuthPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewExtAuthPolicyClient(client), nil
}

// Reader knows how to read and list WAFPolicys.
type WAFPolicyReader interface {
	// Get retrieves a WAFPolicy for the given object key
	GetWAFPolicy(ctx context.Context, key client.ObjectKey) (*WAFPolicy, error)

	// List retrieves list of WAFPolicys for a given namespace and list options.
	ListWAFPolicy(ctx context.Context, opts ...client.ListOption) (*WAFPolicyList, error)
}

// WAFPolicyTransitionFunction instructs the WAFPolicyWriter how to transition between an existing
// WAFPolicy object and a desired on an Upsert
type WAFPolicyTransitionFunction func(existing, desired *WAFPolicy) error

// Writer knows how to create, delete, and update WAFPolicys.
type WAFPolicyWriter interface {
	// Create saves the WAFPolicy object.
	CreateWAFPolicy(ctx context.Context, obj *WAFPolicy, opts ...client.CreateOption) error

	// Delete deletes the WAFPolicy object.
	DeleteWAFPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given WAFPolicy object.
	UpdateWAFPolicy(ctx context.Context, obj *WAFPolicy, opts ...client.UpdateOption) error

	// Patch patches the given WAFPolicy object.
	PatchWAFPolicy(ctx context.Context, obj *WAFPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all WAFPolicy objects matching the given options.
	DeleteAllOfWAFPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the WAFPolicy object.
	UpsertWAFPolicy(ctx context.Context, obj *WAFPolicy, transitionFuncs ...WAFPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a WAFPolicy object.
type WAFPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given WAFPolicy object.
	UpdateWAFPolicyStatus(ctx context.Context, obj *WAFPolicy, opts ...client.UpdateOption) error

	// Patch patches the given WAFPolicy object's subresource.
	PatchWAFPolicyStatus(ctx context.Context, obj *WAFPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on WAFPolicys.
type WAFPolicyClient interface {
	WAFPolicyReader
	WAFPolicyWriter
	WAFPolicyStatusWriter
}

type wAFPolicyClient struct {
	client client.Client
}

func NewWAFPolicyClient(client client.Client) *wAFPolicyClient {
	return &wAFPolicyClient{client: client}
}

func (c *wAFPolicyClient) GetWAFPolicy(ctx context.Context, key client.ObjectKey) (*WAFPolicy, error) {
	obj := &WAFPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *wAFPolicyClient) ListWAFPolicy(ctx context.Context, opts ...client.ListOption) (*WAFPolicyList, error) {
	list := &WAFPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *wAFPolicyClient) CreateWAFPolicy(ctx context.Context, obj *WAFPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *wAFPolicyClient) DeleteWAFPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &WAFPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *wAFPolicyClient) UpdateWAFPolicy(ctx context.Context, obj *WAFPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *wAFPolicyClient) PatchWAFPolicy(ctx context.Context, obj *WAFPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *wAFPolicyClient) DeleteAllOfWAFPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &WAFPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *wAFPolicyClient) UpsertWAFPolicy(ctx context.Context, obj *WAFPolicy, transitionFuncs ...WAFPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*WAFPolicy), desired.(*WAFPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *wAFPolicyClient) UpdateWAFPolicyStatus(ctx context.Context, obj *WAFPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *wAFPolicyClient) PatchWAFPolicyStatus(ctx context.Context, obj *WAFPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides WAFPolicyClients for multiple clusters.
type MulticlusterWAFPolicyClient interface {
	// Cluster returns a WAFPolicyClient for the given cluster
	Cluster(cluster string) (WAFPolicyClient, error)
}

type multiclusterWAFPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterWAFPolicyClient(client multicluster.Client) MulticlusterWAFPolicyClient {
	return &multiclusterWAFPolicyClient{client: client}
}

func (m *multiclusterWAFPolicyClient) Cluster(cluster string) (WAFPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewWAFPolicyClient(client), nil
}

// Reader knows how to read and list JWTPolicys.
type JWTPolicyReader interface {
	// Get retrieves a JWTPolicy for the given object key
	GetJWTPolicy(ctx context.Context, key client.ObjectKey) (*JWTPolicy, error)

	// List retrieves list of JWTPolicys for a given namespace and list options.
	ListJWTPolicy(ctx context.Context, opts ...client.ListOption) (*JWTPolicyList, error)
}

// JWTPolicyTransitionFunction instructs the JWTPolicyWriter how to transition between an existing
// JWTPolicy object and a desired on an Upsert
type JWTPolicyTransitionFunction func(existing, desired *JWTPolicy) error

// Writer knows how to create, delete, and update JWTPolicys.
type JWTPolicyWriter interface {
	// Create saves the JWTPolicy object.
	CreateJWTPolicy(ctx context.Context, obj *JWTPolicy, opts ...client.CreateOption) error

	// Delete deletes the JWTPolicy object.
	DeleteJWTPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given JWTPolicy object.
	UpdateJWTPolicy(ctx context.Context, obj *JWTPolicy, opts ...client.UpdateOption) error

	// Patch patches the given JWTPolicy object.
	PatchJWTPolicy(ctx context.Context, obj *JWTPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all JWTPolicy objects matching the given options.
	DeleteAllOfJWTPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the JWTPolicy object.
	UpsertJWTPolicy(ctx context.Context, obj *JWTPolicy, transitionFuncs ...JWTPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a JWTPolicy object.
type JWTPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given JWTPolicy object.
	UpdateJWTPolicyStatus(ctx context.Context, obj *JWTPolicy, opts ...client.UpdateOption) error

	// Patch patches the given JWTPolicy object's subresource.
	PatchJWTPolicyStatus(ctx context.Context, obj *JWTPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on JWTPolicys.
type JWTPolicyClient interface {
	JWTPolicyReader
	JWTPolicyWriter
	JWTPolicyStatusWriter
}

type jWTPolicyClient struct {
	client client.Client
}

func NewJWTPolicyClient(client client.Client) *jWTPolicyClient {
	return &jWTPolicyClient{client: client}
}

func (c *jWTPolicyClient) GetJWTPolicy(ctx context.Context, key client.ObjectKey) (*JWTPolicy, error) {
	obj := &JWTPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *jWTPolicyClient) ListJWTPolicy(ctx context.Context, opts ...client.ListOption) (*JWTPolicyList, error) {
	list := &JWTPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *jWTPolicyClient) CreateJWTPolicy(ctx context.Context, obj *JWTPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *jWTPolicyClient) DeleteJWTPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &JWTPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *jWTPolicyClient) UpdateJWTPolicy(ctx context.Context, obj *JWTPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *jWTPolicyClient) PatchJWTPolicy(ctx context.Context, obj *JWTPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *jWTPolicyClient) DeleteAllOfJWTPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &JWTPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *jWTPolicyClient) UpsertJWTPolicy(ctx context.Context, obj *JWTPolicy, transitionFuncs ...JWTPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*JWTPolicy), desired.(*JWTPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *jWTPolicyClient) UpdateJWTPolicyStatus(ctx context.Context, obj *JWTPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *jWTPolicyClient) PatchJWTPolicyStatus(ctx context.Context, obj *JWTPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides JWTPolicyClients for multiple clusters.
type MulticlusterJWTPolicyClient interface {
	// Cluster returns a JWTPolicyClient for the given cluster
	Cluster(cluster string) (JWTPolicyClient, error)
}

type multiclusterJWTPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterJWTPolicyClient(client multicluster.Client) MulticlusterJWTPolicyClient {
	return &multiclusterJWTPolicyClient{client: client}
}

func (m *multiclusterJWTPolicyClient) Cluster(cluster string) (JWTPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewJWTPolicyClient(client), nil
}
