// Code generated by protoc-gen-ext. DO NOT EDIT.
// source: github.com/solo-io/solo-apis/api/gloo/enterprise.gloo/v1/auth_config.proto

package v1

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"strings"

	"github.com/solo-io/protoc-gen-ext/pkg/clone"
	"google.golang.org/protobuf/proto"

	github_com_golang_protobuf_ptypes_duration "github.com/golang/protobuf/ptypes/duration"

	github_com_golang_protobuf_ptypes_empty "github.com/golang/protobuf/ptypes/empty"

	github_com_golang_protobuf_ptypes_struct "github.com/golang/protobuf/ptypes/struct"

	github_com_golang_protobuf_ptypes_wrappers "github.com/golang/protobuf/ptypes/wrappers"

	github_com_solo_io_solo_kit_pkg_api_v1_resources_core "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
)

// ensure the imports are used
var (
	_ = errors.New("")
	_ = fmt.Print
	_ = binary.LittleEndian
	_ = bytes.Compare
	_ = strings.Compare
	_ = clone.Cloner(nil)
	_ = proto.Message(nil)
)

// Clone function
func (m *AuthConfigSpec) Clone() proto.Message {
	var target *AuthConfigSpec
	if m == nil {
		return target
	}
	target = &AuthConfigSpec{}

	if m.GetConfigs() != nil {
		target.Configs = make([]*AuthConfigSpec_Config, len(m.GetConfigs()))
		for idx, v := range m.GetConfigs() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Configs[idx] = h.Clone().(*AuthConfigSpec_Config)
			} else {
				target.Configs[idx] = proto.Clone(v).(*AuthConfigSpec_Config)
			}

		}
	}

	if h, ok := interface{}(m.GetBooleanExpr()).(clone.Cloner); ok {
		target.BooleanExpr = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	} else {
		target.BooleanExpr = proto.Clone(m.GetBooleanExpr()).(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	}

	return target
}

// Clone function
func (m *ExtAuthExtension) Clone() proto.Message {
	var target *ExtAuthExtension
	if m == nil {
		return target
	}
	target = &ExtAuthExtension{}

	switch m.Spec.(type) {

	case *ExtAuthExtension_Disable:

		target.Spec = &ExtAuthExtension_Disable{
			Disable: m.GetDisable(),
		}

	case *ExtAuthExtension_ConfigRef:

		if h, ok := interface{}(m.GetConfigRef()).(clone.Cloner); ok {
			target.Spec = &ExtAuthExtension_ConfigRef{
				ConfigRef: h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef),
			}
		} else {
			target.Spec = &ExtAuthExtension_ConfigRef{
				ConfigRef: proto.Clone(m.GetConfigRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef),
			}
		}

	case *ExtAuthExtension_CustomAuth:

		if h, ok := interface{}(m.GetCustomAuth()).(clone.Cloner); ok {
			target.Spec = &ExtAuthExtension_CustomAuth{
				CustomAuth: h.Clone().(*CustomAuth),
			}
		} else {
			target.Spec = &ExtAuthExtension_CustomAuth{
				CustomAuth: proto.Clone(m.GetCustomAuth()).(*CustomAuth),
			}
		}

	}

	return target
}

// Clone function
func (m *Settings) Clone() proto.Message {
	var target *Settings
	if m == nil {
		return target
	}
	target = &Settings{}

	if h, ok := interface{}(m.GetExtauthzServerRef()).(clone.Cloner); ok {
		target.ExtauthzServerRef = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	} else {
		target.ExtauthzServerRef = proto.Clone(m.GetExtauthzServerRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	}

	if h, ok := interface{}(m.GetHttpService()).(clone.Cloner); ok {
		target.HttpService = h.Clone().(*HttpService)
	} else {
		target.HttpService = proto.Clone(m.GetHttpService()).(*HttpService)
	}

	target.UserIdHeader = m.GetUserIdHeader()

	if h, ok := interface{}(m.GetRequestTimeout()).(clone.Cloner); ok {
		target.RequestTimeout = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.RequestTimeout = proto.Clone(m.GetRequestTimeout()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	target.FailureModeAllow = m.GetFailureModeAllow()

	if h, ok := interface{}(m.GetRequestBody()).(clone.Cloner); ok {
		target.RequestBody = h.Clone().(*BufferSettings)
	} else {
		target.RequestBody = proto.Clone(m.GetRequestBody()).(*BufferSettings)
	}

	target.ClearRouteCache = m.GetClearRouteCache()

	target.StatusOnError = m.GetStatusOnError()

	target.TransportApiVersion = m.GetTransportApiVersion()

	target.StatPrefix = m.GetStatPrefix()

	return target
}

// Clone function
func (m *HttpService) Clone() proto.Message {
	var target *HttpService
	if m == nil {
		return target
	}
	target = &HttpService{}

	target.PathPrefix = m.GetPathPrefix()

	if h, ok := interface{}(m.GetRequest()).(clone.Cloner); ok {
		target.Request = h.Clone().(*HttpService_Request)
	} else {
		target.Request = proto.Clone(m.GetRequest()).(*HttpService_Request)
	}

	if h, ok := interface{}(m.GetResponse()).(clone.Cloner); ok {
		target.Response = h.Clone().(*HttpService_Response)
	} else {
		target.Response = proto.Clone(m.GetResponse()).(*HttpService_Response)
	}

	return target
}

// Clone function
func (m *BufferSettings) Clone() proto.Message {
	var target *BufferSettings
	if m == nil {
		return target
	}
	target = &BufferSettings{}

	target.MaxRequestBytes = m.GetMaxRequestBytes()

	target.AllowPartialMessage = m.GetAllowPartialMessage()

	target.PackAsBytes = m.GetPackAsBytes()

	return target
}

// Clone function
func (m *CustomAuth) Clone() proto.Message {
	var target *CustomAuth
	if m == nil {
		return target
	}
	target = &CustomAuth{}

	if m.GetContextExtensions() != nil {
		target.ContextExtensions = make(map[string]string, len(m.GetContextExtensions()))
		for k, v := range m.GetContextExtensions() {

			target.ContextExtensions[k] = v

		}
	}

	target.Name = m.GetName()

	return target
}

// Clone function
func (m *AuthPlugin) Clone() proto.Message {
	var target *AuthPlugin
	if m == nil {
		return target
	}
	target = &AuthPlugin{}

	target.Name = m.GetName()

	target.PluginFileName = m.GetPluginFileName()

	target.ExportedSymbolName = m.GetExportedSymbolName()

	if h, ok := interface{}(m.GetConfig()).(clone.Cloner); ok {
		target.Config = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
	} else {
		target.Config = proto.Clone(m.GetConfig()).(*github_com_golang_protobuf_ptypes_struct.Struct)
	}

	return target
}

// Clone function
func (m *BasicAuth) Clone() proto.Message {
	var target *BasicAuth
	if m == nil {
		return target
	}
	target = &BasicAuth{}

	target.Realm = m.GetRealm()

	if h, ok := interface{}(m.GetApr()).(clone.Cloner); ok {
		target.Apr = h.Clone().(*BasicAuth_Apr)
	} else {
		target.Apr = proto.Clone(m.GetApr()).(*BasicAuth_Apr)
	}

	return target
}

// Clone function
func (m *OAuth) Clone() proto.Message {
	var target *OAuth
	if m == nil {
		return target
	}
	target = &OAuth{}

	target.ClientId = m.GetClientId()

	if h, ok := interface{}(m.GetClientSecretRef()).(clone.Cloner); ok {
		target.ClientSecretRef = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	} else {
		target.ClientSecretRef = proto.Clone(m.GetClientSecretRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	}

	target.IssuerUrl = m.GetIssuerUrl()

	if m.GetAuthEndpointQueryParams() != nil {
		target.AuthEndpointQueryParams = make(map[string]string, len(m.GetAuthEndpointQueryParams()))
		for k, v := range m.GetAuthEndpointQueryParams() {

			target.AuthEndpointQueryParams[k] = v

		}
	}

	target.AppUrl = m.GetAppUrl()

	target.CallbackPath = m.GetCallbackPath()

	if m.GetScopes() != nil {
		target.Scopes = make([]string, len(m.GetScopes()))
		for idx, v := range m.GetScopes() {

			target.Scopes[idx] = v

		}
	}

	return target
}

// Clone function
func (m *OAuth2) Clone() proto.Message {
	var target *OAuth2
	if m == nil {
		return target
	}
	target = &OAuth2{}

	switch m.OauthType.(type) {

	case *OAuth2_OidcAuthorizationCode:

		if h, ok := interface{}(m.GetOidcAuthorizationCode()).(clone.Cloner); ok {
			target.OauthType = &OAuth2_OidcAuthorizationCode{
				OidcAuthorizationCode: h.Clone().(*OidcAuthorizationCode),
			}
		} else {
			target.OauthType = &OAuth2_OidcAuthorizationCode{
				OidcAuthorizationCode: proto.Clone(m.GetOidcAuthorizationCode()).(*OidcAuthorizationCode),
			}
		}

	case *OAuth2_AccessTokenValidation:

		if h, ok := interface{}(m.GetAccessTokenValidation()).(clone.Cloner); ok {
			target.OauthType = &OAuth2_AccessTokenValidation{
				AccessTokenValidation: h.Clone().(*AccessTokenValidation),
			}
		} else {
			target.OauthType = &OAuth2_AccessTokenValidation{
				AccessTokenValidation: proto.Clone(m.GetAccessTokenValidation()).(*AccessTokenValidation),
			}
		}

	}

	return target
}

// Clone function
func (m *RedisOptions) Clone() proto.Message {
	var target *RedisOptions
	if m == nil {
		return target
	}
	target = &RedisOptions{}

	target.Host = m.GetHost()

	target.Db = m.GetDb()

	target.PoolSize = m.GetPoolSize()

	return target
}

// Clone function
func (m *UserSession) Clone() proto.Message {
	var target *UserSession
	if m == nil {
		return target
	}
	target = &UserSession{}

	target.FailOnFetchFailure = m.GetFailOnFetchFailure()

	if h, ok := interface{}(m.GetCookieOptions()).(clone.Cloner); ok {
		target.CookieOptions = h.Clone().(*UserSession_CookieOptions)
	} else {
		target.CookieOptions = proto.Clone(m.GetCookieOptions()).(*UserSession_CookieOptions)
	}

	switch m.Session.(type) {

	case *UserSession_Cookie:

		if h, ok := interface{}(m.GetCookie()).(clone.Cloner); ok {
			target.Session = &UserSession_Cookie{
				Cookie: h.Clone().(*UserSession_InternalSession),
			}
		} else {
			target.Session = &UserSession_Cookie{
				Cookie: proto.Clone(m.GetCookie()).(*UserSession_InternalSession),
			}
		}

	case *UserSession_Redis:

		if h, ok := interface{}(m.GetRedis()).(clone.Cloner); ok {
			target.Session = &UserSession_Redis{
				Redis: h.Clone().(*UserSession_RedisSession),
			}
		} else {
			target.Session = &UserSession_Redis{
				Redis: proto.Clone(m.GetRedis()).(*UserSession_RedisSession),
			}
		}

	}

	return target
}

// Clone function
func (m *HeaderConfiguration) Clone() proto.Message {
	var target *HeaderConfiguration
	if m == nil {
		return target
	}
	target = &HeaderConfiguration{}

	target.IdTokenHeader = m.GetIdTokenHeader()

	target.AccessTokenHeader = m.GetAccessTokenHeader()

	return target
}

// Clone function
func (m *DiscoveryOverride) Clone() proto.Message {
	var target *DiscoveryOverride
	if m == nil {
		return target
	}
	target = &DiscoveryOverride{}

	target.AuthEndpoint = m.GetAuthEndpoint()

	target.TokenEndpoint = m.GetTokenEndpoint()

	target.JwksUri = m.GetJwksUri()

	if m.GetScopes() != nil {
		target.Scopes = make([]string, len(m.GetScopes()))
		for idx, v := range m.GetScopes() {

			target.Scopes[idx] = v

		}
	}

	if m.GetResponseTypes() != nil {
		target.ResponseTypes = make([]string, len(m.GetResponseTypes()))
		for idx, v := range m.GetResponseTypes() {

			target.ResponseTypes[idx] = v

		}
	}

	if m.GetSubjects() != nil {
		target.Subjects = make([]string, len(m.GetSubjects()))
		for idx, v := range m.GetSubjects() {

			target.Subjects[idx] = v

		}
	}

	if m.GetIdTokenAlgs() != nil {
		target.IdTokenAlgs = make([]string, len(m.GetIdTokenAlgs()))
		for idx, v := range m.GetIdTokenAlgs() {

			target.IdTokenAlgs[idx] = v

		}
	}

	if m.GetAuthMethods() != nil {
		target.AuthMethods = make([]string, len(m.GetAuthMethods()))
		for idx, v := range m.GetAuthMethods() {

			target.AuthMethods[idx] = v

		}
	}

	if m.GetClaims() != nil {
		target.Claims = make([]string, len(m.GetClaims()))
		for idx, v := range m.GetClaims() {

			target.Claims[idx] = v

		}
	}

	return target
}

// Clone function
func (m *JwksOnDemandCacheRefreshPolicy) Clone() proto.Message {
	var target *JwksOnDemandCacheRefreshPolicy
	if m == nil {
		return target
	}
	target = &JwksOnDemandCacheRefreshPolicy{}

	switch m.Policy.(type) {

	case *JwksOnDemandCacheRefreshPolicy_Never:

		if h, ok := interface{}(m.GetNever()).(clone.Cloner); ok {
			target.Policy = &JwksOnDemandCacheRefreshPolicy_Never{
				Never: h.Clone().(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		} else {
			target.Policy = &JwksOnDemandCacheRefreshPolicy_Never{
				Never: proto.Clone(m.GetNever()).(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		}

	case *JwksOnDemandCacheRefreshPolicy_Always:

		if h, ok := interface{}(m.GetAlways()).(clone.Cloner); ok {
			target.Policy = &JwksOnDemandCacheRefreshPolicy_Always{
				Always: h.Clone().(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		} else {
			target.Policy = &JwksOnDemandCacheRefreshPolicy_Always{
				Always: proto.Clone(m.GetAlways()).(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		}

	case *JwksOnDemandCacheRefreshPolicy_MaxIdpReqPerPollingInterval:

		target.Policy = &JwksOnDemandCacheRefreshPolicy_MaxIdpReqPerPollingInterval{
			MaxIdpReqPerPollingInterval: m.GetMaxIdpReqPerPollingInterval(),
		}

	}

	return target
}

// Clone function
func (m *OidcAuthorizationCode) Clone() proto.Message {
	var target *OidcAuthorizationCode
	if m == nil {
		return target
	}
	target = &OidcAuthorizationCode{}

	target.ClientId = m.GetClientId()

	if h, ok := interface{}(m.GetClientSecretRef()).(clone.Cloner); ok {
		target.ClientSecretRef = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	} else {
		target.ClientSecretRef = proto.Clone(m.GetClientSecretRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	}

	target.IssuerUrl = m.GetIssuerUrl()

	if m.GetAuthEndpointQueryParams() != nil {
		target.AuthEndpointQueryParams = make(map[string]string, len(m.GetAuthEndpointQueryParams()))
		for k, v := range m.GetAuthEndpointQueryParams() {

			target.AuthEndpointQueryParams[k] = v

		}
	}

	if m.GetTokenEndpointQueryParams() != nil {
		target.TokenEndpointQueryParams = make(map[string]string, len(m.GetTokenEndpointQueryParams()))
		for k, v := range m.GetTokenEndpointQueryParams() {

			target.TokenEndpointQueryParams[k] = v

		}
	}

	target.AppUrl = m.GetAppUrl()

	target.CallbackPath = m.GetCallbackPath()

	target.LogoutPath = m.GetLogoutPath()

	target.AfterLogoutUrl = m.GetAfterLogoutUrl()

	if m.GetScopes() != nil {
		target.Scopes = make([]string, len(m.GetScopes()))
		for idx, v := range m.GetScopes() {

			target.Scopes[idx] = v

		}
	}

	if h, ok := interface{}(m.GetSession()).(clone.Cloner); ok {
		target.Session = h.Clone().(*UserSession)
	} else {
		target.Session = proto.Clone(m.GetSession()).(*UserSession)
	}

	if h, ok := interface{}(m.GetHeaders()).(clone.Cloner); ok {
		target.Headers = h.Clone().(*HeaderConfiguration)
	} else {
		target.Headers = proto.Clone(m.GetHeaders()).(*HeaderConfiguration)
	}

	if h, ok := interface{}(m.GetDiscoveryOverride()).(clone.Cloner); ok {
		target.DiscoveryOverride = h.Clone().(*DiscoveryOverride)
	} else {
		target.DiscoveryOverride = proto.Clone(m.GetDiscoveryOverride()).(*DiscoveryOverride)
	}

	if h, ok := interface{}(m.GetDiscoveryPollInterval()).(clone.Cloner); ok {
		target.DiscoveryPollInterval = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.DiscoveryPollInterval = proto.Clone(m.GetDiscoveryPollInterval()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	if h, ok := interface{}(m.GetJwksCacheRefreshPolicy()).(clone.Cloner); ok {
		target.JwksCacheRefreshPolicy = h.Clone().(*JwksOnDemandCacheRefreshPolicy)
	} else {
		target.JwksCacheRefreshPolicy = proto.Clone(m.GetJwksCacheRefreshPolicy()).(*JwksOnDemandCacheRefreshPolicy)
	}

	return target
}

// Clone function
func (m *AccessTokenValidation) Clone() proto.Message {
	var target *AccessTokenValidation
	if m == nil {
		return target
	}
	target = &AccessTokenValidation{}

	target.UserinfoUrl = m.GetUserinfoUrl()

	if h, ok := interface{}(m.GetCacheTimeout()).(clone.Cloner); ok {
		target.CacheTimeout = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.CacheTimeout = proto.Clone(m.GetCacheTimeout()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	switch m.ValidationType.(type) {

	case *AccessTokenValidation_IntrospectionUrl:

		target.ValidationType = &AccessTokenValidation_IntrospectionUrl{
			IntrospectionUrl: m.GetIntrospectionUrl(),
		}

	case *AccessTokenValidation_Jwt:

		if h, ok := interface{}(m.GetJwt()).(clone.Cloner); ok {
			target.ValidationType = &AccessTokenValidation_Jwt{
				Jwt: h.Clone().(*AccessTokenValidation_JwtValidation),
			}
		} else {
			target.ValidationType = &AccessTokenValidation_Jwt{
				Jwt: proto.Clone(m.GetJwt()).(*AccessTokenValidation_JwtValidation),
			}
		}

	case *AccessTokenValidation_Introspection:

		if h, ok := interface{}(m.GetIntrospection()).(clone.Cloner); ok {
			target.ValidationType = &AccessTokenValidation_Introspection{
				Introspection: h.Clone().(*AccessTokenValidation_IntrospectionValidation),
			}
		} else {
			target.ValidationType = &AccessTokenValidation_Introspection{
				Introspection: proto.Clone(m.GetIntrospection()).(*AccessTokenValidation_IntrospectionValidation),
			}
		}

	}

	switch m.ScopeValidation.(type) {

	case *AccessTokenValidation_RequiredScopes:

		if h, ok := interface{}(m.GetRequiredScopes()).(clone.Cloner); ok {
			target.ScopeValidation = &AccessTokenValidation_RequiredScopes{
				RequiredScopes: h.Clone().(*AccessTokenValidation_ScopeList),
			}
		} else {
			target.ScopeValidation = &AccessTokenValidation_RequiredScopes{
				RequiredScopes: proto.Clone(m.GetRequiredScopes()).(*AccessTokenValidation_ScopeList),
			}
		}

	}

	return target
}

// Clone function
func (m *OauthSecret) Clone() proto.Message {
	var target *OauthSecret
	if m == nil {
		return target
	}
	target = &OauthSecret{}

	target.ClientSecret = m.GetClientSecret()

	return target
}

// Clone function
func (m *ApiKeyAuth) Clone() proto.Message {
	var target *ApiKeyAuth
	if m == nil {
		return target
	}
	target = &ApiKeyAuth{}

	if m.GetLabelSelector() != nil {
		target.LabelSelector = make(map[string]string, len(m.GetLabelSelector()))
		for k, v := range m.GetLabelSelector() {

			target.LabelSelector[k] = v

		}
	}

	if m.GetApiKeySecretRefs() != nil {
		target.ApiKeySecretRefs = make([]*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef, len(m.GetApiKeySecretRefs()))
		for idx, v := range m.GetApiKeySecretRefs() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ApiKeySecretRefs[idx] = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
			} else {
				target.ApiKeySecretRefs[idx] = proto.Clone(v).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
			}

		}
	}

	target.HeaderName = m.GetHeaderName()

	if m.GetHeadersFromMetadata() != nil {
		target.HeadersFromMetadata = make(map[string]*ApiKeyAuth_SecretKey, len(m.GetHeadersFromMetadata()))
		for k, v := range m.GetHeadersFromMetadata() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.HeadersFromMetadata[k] = h.Clone().(*ApiKeyAuth_SecretKey)
			} else {
				target.HeadersFromMetadata[k] = proto.Clone(v).(*ApiKeyAuth_SecretKey)
			}

		}
	}

	return target
}

// Clone function
func (m *ApiKeySecret) Clone() proto.Message {
	var target *ApiKeySecret
	if m == nil {
		return target
	}
	target = &ApiKeySecret{}

	target.GenerateApiKey = m.GetGenerateApiKey()

	target.ApiKey = m.GetApiKey()

	if m.GetLabels() != nil {
		target.Labels = make([]string, len(m.GetLabels()))
		for idx, v := range m.GetLabels() {

			target.Labels[idx] = v

		}
	}

	if m.GetMetadata() != nil {
		target.Metadata = make(map[string]string, len(m.GetMetadata()))
		for k, v := range m.GetMetadata() {

			target.Metadata[k] = v

		}
	}

	return target
}

// Clone function
func (m *OpaAuth) Clone() proto.Message {
	var target *OpaAuth
	if m == nil {
		return target
	}
	target = &OpaAuth{}

	if m.GetModules() != nil {
		target.Modules = make([]*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef, len(m.GetModules()))
		for idx, v := range m.GetModules() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Modules[idx] = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
			} else {
				target.Modules[idx] = proto.Clone(v).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
			}

		}
	}

	target.Query = m.GetQuery()

	return target
}

// Clone function
func (m *Ldap) Clone() proto.Message {
	var target *Ldap
	if m == nil {
		return target
	}
	target = &Ldap{}

	target.Address = m.GetAddress()

	target.UserDnTemplate = m.GetUserDnTemplate()

	target.MembershipAttributeName = m.GetMembershipAttributeName()

	if m.GetAllowedGroups() != nil {
		target.AllowedGroups = make([]string, len(m.GetAllowedGroups()))
		for idx, v := range m.GetAllowedGroups() {

			target.AllowedGroups[idx] = v

		}
	}

	if h, ok := interface{}(m.GetPool()).(clone.Cloner); ok {
		target.Pool = h.Clone().(*Ldap_ConnectionPool)
	} else {
		target.Pool = proto.Clone(m.GetPool()).(*Ldap_ConnectionPool)
	}

	return target
}

// Clone function
func (m *PassThroughAuth) Clone() proto.Message {
	var target *PassThroughAuth
	if m == nil {
		return target
	}
	target = &PassThroughAuth{}

	if h, ok := interface{}(m.GetConfig()).(clone.Cloner); ok {
		target.Config = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
	} else {
		target.Config = proto.Clone(m.GetConfig()).(*github_com_golang_protobuf_ptypes_struct.Struct)
	}

	switch m.Protocol.(type) {

	case *PassThroughAuth_Grpc:

		if h, ok := interface{}(m.GetGrpc()).(clone.Cloner); ok {
			target.Protocol = &PassThroughAuth_Grpc{
				Grpc: h.Clone().(*PassThroughGrpc),
			}
		} else {
			target.Protocol = &PassThroughAuth_Grpc{
				Grpc: proto.Clone(m.GetGrpc()).(*PassThroughGrpc),
			}
		}

	}

	return target
}

// Clone function
func (m *PassThroughGrpc) Clone() proto.Message {
	var target *PassThroughGrpc
	if m == nil {
		return target
	}
	target = &PassThroughGrpc{}

	target.Address = m.GetAddress()

	if h, ok := interface{}(m.GetConnectionTimeout()).(clone.Cloner); ok {
		target.ConnectionTimeout = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.ConnectionTimeout = proto.Clone(m.GetConnectionTimeout()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	return target
}

// Clone function
func (m *ExtAuthConfig) Clone() proto.Message {
	var target *ExtAuthConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig{}

	target.AuthConfigRefName = m.GetAuthConfigRefName()

	if m.GetConfigs() != nil {
		target.Configs = make([]*ExtAuthConfig_Config, len(m.GetConfigs()))
		for idx, v := range m.GetConfigs() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Configs[idx] = h.Clone().(*ExtAuthConfig_Config)
			} else {
				target.Configs[idx] = proto.Clone(v).(*ExtAuthConfig_Config)
			}

		}
	}

	if h, ok := interface{}(m.GetBooleanExpr()).(clone.Cloner); ok {
		target.BooleanExpr = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	} else {
		target.BooleanExpr = proto.Clone(m.GetBooleanExpr()).(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	}

	return target
}

// Clone function
func (m *AuthConfigStatus) Clone() proto.Message {
	var target *AuthConfigStatus
	if m == nil {
		return target
	}
	target = &AuthConfigStatus{}

	target.State = m.GetState()

	target.Reason = m.GetReason()

	target.ReportedBy = m.GetReportedBy()

	if m.GetSubresourceStatuses() != nil {
		target.SubresourceStatuses = make(map[string]*AuthConfigStatus, len(m.GetSubresourceStatuses()))
		for k, v := range m.GetSubresourceStatuses() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.SubresourceStatuses[k] = h.Clone().(*AuthConfigStatus)
			} else {
				target.SubresourceStatuses[k] = proto.Clone(v).(*AuthConfigStatus)
			}

		}
	}

	if h, ok := interface{}(m.GetDetails()).(clone.Cloner); ok {
		target.Details = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
	} else {
		target.Details = proto.Clone(m.GetDetails()).(*github_com_golang_protobuf_ptypes_struct.Struct)
	}

	return target
}

// Clone function
func (m *AuthConfigSpec_Config) Clone() proto.Message {
	var target *AuthConfigSpec_Config
	if m == nil {
		return target
	}
	target = &AuthConfigSpec_Config{}

	if h, ok := interface{}(m.GetName()).(clone.Cloner); ok {
		target.Name = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	} else {
		target.Name = proto.Clone(m.GetName()).(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	}

	switch m.AuthConfig.(type) {

	case *AuthConfigSpec_Config_BasicAuth:

		if h, ok := interface{}(m.GetBasicAuth()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_BasicAuth{
				BasicAuth: h.Clone().(*BasicAuth),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_BasicAuth{
				BasicAuth: proto.Clone(m.GetBasicAuth()).(*BasicAuth),
			}
		}

	case *AuthConfigSpec_Config_Oauth:

		if h, ok := interface{}(m.GetOauth()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_Oauth{
				Oauth: h.Clone().(*OAuth),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_Oauth{
				Oauth: proto.Clone(m.GetOauth()).(*OAuth),
			}
		}

	case *AuthConfigSpec_Config_Oauth2:

		if h, ok := interface{}(m.GetOauth2()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_Oauth2{
				Oauth2: h.Clone().(*OAuth2),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_Oauth2{
				Oauth2: proto.Clone(m.GetOauth2()).(*OAuth2),
			}
		}

	case *AuthConfigSpec_Config_ApiKeyAuth:

		if h, ok := interface{}(m.GetApiKeyAuth()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_ApiKeyAuth{
				ApiKeyAuth: h.Clone().(*ApiKeyAuth),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_ApiKeyAuth{
				ApiKeyAuth: proto.Clone(m.GetApiKeyAuth()).(*ApiKeyAuth),
			}
		}

	case *AuthConfigSpec_Config_PluginAuth:

		if h, ok := interface{}(m.GetPluginAuth()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_PluginAuth{
				PluginAuth: h.Clone().(*AuthPlugin),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_PluginAuth{
				PluginAuth: proto.Clone(m.GetPluginAuth()).(*AuthPlugin),
			}
		}

	case *AuthConfigSpec_Config_OpaAuth:

		if h, ok := interface{}(m.GetOpaAuth()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_OpaAuth{
				OpaAuth: h.Clone().(*OpaAuth),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_OpaAuth{
				OpaAuth: proto.Clone(m.GetOpaAuth()).(*OpaAuth),
			}
		}

	case *AuthConfigSpec_Config_Ldap:

		if h, ok := interface{}(m.GetLdap()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_Ldap{
				Ldap: h.Clone().(*Ldap),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_Ldap{
				Ldap: proto.Clone(m.GetLdap()).(*Ldap),
			}
		}

	case *AuthConfigSpec_Config_Jwt:

		if h, ok := interface{}(m.GetJwt()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_Jwt{
				Jwt: h.Clone().(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_Jwt{
				Jwt: proto.Clone(m.GetJwt()).(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		}

	case *AuthConfigSpec_Config_PassThroughAuth:

		if h, ok := interface{}(m.GetPassThroughAuth()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_PassThroughAuth{
				PassThroughAuth: h.Clone().(*PassThroughAuth),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_PassThroughAuth{
				PassThroughAuth: proto.Clone(m.GetPassThroughAuth()).(*PassThroughAuth),
			}
		}

	}

	return target
}

// Clone function
func (m *HttpService_Request) Clone() proto.Message {
	var target *HttpService_Request
	if m == nil {
		return target
	}
	target = &HttpService_Request{}

	if m.GetAllowedHeaders() != nil {
		target.AllowedHeaders = make([]string, len(m.GetAllowedHeaders()))
		for idx, v := range m.GetAllowedHeaders() {

			target.AllowedHeaders[idx] = v

		}
	}

	if m.GetHeadersToAdd() != nil {
		target.HeadersToAdd = make(map[string]string, len(m.GetHeadersToAdd()))
		for k, v := range m.GetHeadersToAdd() {

			target.HeadersToAdd[k] = v

		}
	}

	if m.GetAllowedHeadersRegex() != nil {
		target.AllowedHeadersRegex = make([]string, len(m.GetAllowedHeadersRegex()))
		for idx, v := range m.GetAllowedHeadersRegex() {

			target.AllowedHeadersRegex[idx] = v

		}
	}

	return target
}

// Clone function
func (m *HttpService_Response) Clone() proto.Message {
	var target *HttpService_Response
	if m == nil {
		return target
	}
	target = &HttpService_Response{}

	if m.GetAllowedUpstreamHeaders() != nil {
		target.AllowedUpstreamHeaders = make([]string, len(m.GetAllowedUpstreamHeaders()))
		for idx, v := range m.GetAllowedUpstreamHeaders() {

			target.AllowedUpstreamHeaders[idx] = v

		}
	}

	if m.GetAllowedClientHeaders() != nil {
		target.AllowedClientHeaders = make([]string, len(m.GetAllowedClientHeaders()))
		for idx, v := range m.GetAllowedClientHeaders() {

			target.AllowedClientHeaders[idx] = v

		}
	}

	return target
}

// Clone function
func (m *BasicAuth_Apr) Clone() proto.Message {
	var target *BasicAuth_Apr
	if m == nil {
		return target
	}
	target = &BasicAuth_Apr{}

	if m.GetUsers() != nil {
		target.Users = make(map[string]*BasicAuth_Apr_SaltedHashedPassword, len(m.GetUsers()))
		for k, v := range m.GetUsers() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Users[k] = h.Clone().(*BasicAuth_Apr_SaltedHashedPassword)
			} else {
				target.Users[k] = proto.Clone(v).(*BasicAuth_Apr_SaltedHashedPassword)
			}

		}
	}

	return target
}

// Clone function
func (m *BasicAuth_Apr_SaltedHashedPassword) Clone() proto.Message {
	var target *BasicAuth_Apr_SaltedHashedPassword
	if m == nil {
		return target
	}
	target = &BasicAuth_Apr_SaltedHashedPassword{}

	target.Salt = m.GetSalt()

	target.HashedPassword = m.GetHashedPassword()

	return target
}

// Clone function
func (m *UserSession_InternalSession) Clone() proto.Message {
	var target *UserSession_InternalSession
	if m == nil {
		return target
	}
	target = &UserSession_InternalSession{}

	return target
}

// Clone function
func (m *UserSession_RedisSession) Clone() proto.Message {
	var target *UserSession_RedisSession
	if m == nil {
		return target
	}
	target = &UserSession_RedisSession{}

	if h, ok := interface{}(m.GetOptions()).(clone.Cloner); ok {
		target.Options = h.Clone().(*RedisOptions)
	} else {
		target.Options = proto.Clone(m.GetOptions()).(*RedisOptions)
	}

	target.KeyPrefix = m.GetKeyPrefix()

	target.CookieName = m.GetCookieName()

	if h, ok := interface{}(m.GetAllowRefreshing()).(clone.Cloner); ok {
		target.AllowRefreshing = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.AllowRefreshing = proto.Clone(m.GetAllowRefreshing()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	return target
}

// Clone function
func (m *UserSession_CookieOptions) Clone() proto.Message {
	var target *UserSession_CookieOptions
	if m == nil {
		return target
	}
	target = &UserSession_CookieOptions{}

	if h, ok := interface{}(m.GetMaxAge()).(clone.Cloner); ok {
		target.MaxAge = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	} else {
		target.MaxAge = proto.Clone(m.GetMaxAge()).(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	}

	target.NotSecure = m.GetNotSecure()

	if h, ok := interface{}(m.GetPath()).(clone.Cloner); ok {
		target.Path = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	} else {
		target.Path = proto.Clone(m.GetPath()).(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	}

	target.Domain = m.GetDomain()

	return target
}

// Clone function
func (m *AccessTokenValidation_JwtValidation) Clone() proto.Message {
	var target *AccessTokenValidation_JwtValidation
	if m == nil {
		return target
	}
	target = &AccessTokenValidation_JwtValidation{}

	target.Issuer = m.GetIssuer()

	switch m.JwksSourceSpecifier.(type) {

	case *AccessTokenValidation_JwtValidation_RemoteJwks_:

		if h, ok := interface{}(m.GetRemoteJwks()).(clone.Cloner); ok {
			target.JwksSourceSpecifier = &AccessTokenValidation_JwtValidation_RemoteJwks_{
				RemoteJwks: h.Clone().(*AccessTokenValidation_JwtValidation_RemoteJwks),
			}
		} else {
			target.JwksSourceSpecifier = &AccessTokenValidation_JwtValidation_RemoteJwks_{
				RemoteJwks: proto.Clone(m.GetRemoteJwks()).(*AccessTokenValidation_JwtValidation_RemoteJwks),
			}
		}

	case *AccessTokenValidation_JwtValidation_LocalJwks_:

		if h, ok := interface{}(m.GetLocalJwks()).(clone.Cloner); ok {
			target.JwksSourceSpecifier = &AccessTokenValidation_JwtValidation_LocalJwks_{
				LocalJwks: h.Clone().(*AccessTokenValidation_JwtValidation_LocalJwks),
			}
		} else {
			target.JwksSourceSpecifier = &AccessTokenValidation_JwtValidation_LocalJwks_{
				LocalJwks: proto.Clone(m.GetLocalJwks()).(*AccessTokenValidation_JwtValidation_LocalJwks),
			}
		}

	}

	return target
}

// Clone function
func (m *AccessTokenValidation_IntrospectionValidation) Clone() proto.Message {
	var target *AccessTokenValidation_IntrospectionValidation
	if m == nil {
		return target
	}
	target = &AccessTokenValidation_IntrospectionValidation{}

	target.IntrospectionUrl = m.GetIntrospectionUrl()

	target.ClientId = m.GetClientId()

	if h, ok := interface{}(m.GetClientSecretRef()).(clone.Cloner); ok {
		target.ClientSecretRef = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	} else {
		target.ClientSecretRef = proto.Clone(m.GetClientSecretRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	}

	target.UserIdAttributeName = m.GetUserIdAttributeName()

	return target
}

// Clone function
func (m *AccessTokenValidation_ScopeList) Clone() proto.Message {
	var target *AccessTokenValidation_ScopeList
	if m == nil {
		return target
	}
	target = &AccessTokenValidation_ScopeList{}

	if m.GetScope() != nil {
		target.Scope = make([]string, len(m.GetScope()))
		for idx, v := range m.GetScope() {

			target.Scope[idx] = v

		}
	}

	return target
}

// Clone function
func (m *AccessTokenValidation_JwtValidation_RemoteJwks) Clone() proto.Message {
	var target *AccessTokenValidation_JwtValidation_RemoteJwks
	if m == nil {
		return target
	}
	target = &AccessTokenValidation_JwtValidation_RemoteJwks{}

	target.Url = m.GetUrl()

	if h, ok := interface{}(m.GetRefreshInterval()).(clone.Cloner); ok {
		target.RefreshInterval = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.RefreshInterval = proto.Clone(m.GetRefreshInterval()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	return target
}

// Clone function
func (m *AccessTokenValidation_JwtValidation_LocalJwks) Clone() proto.Message {
	var target *AccessTokenValidation_JwtValidation_LocalJwks
	if m == nil {
		return target
	}
	target = &AccessTokenValidation_JwtValidation_LocalJwks{}

	target.InlineString = m.GetInlineString()

	return target
}

// Clone function
func (m *ApiKeyAuth_SecretKey) Clone() proto.Message {
	var target *ApiKeyAuth_SecretKey
	if m == nil {
		return target
	}
	target = &ApiKeyAuth_SecretKey{}

	target.Name = m.GetName()

	target.Required = m.GetRequired()

	return target
}

// Clone function
func (m *Ldap_ConnectionPool) Clone() proto.Message {
	var target *Ldap_ConnectionPool
	if m == nil {
		return target
	}
	target = &Ldap_ConnectionPool{}

	if h, ok := interface{}(m.GetMaxSize()).(clone.Cloner); ok {
		target.MaxSize = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	} else {
		target.MaxSize = proto.Clone(m.GetMaxSize()).(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	}

	if h, ok := interface{}(m.GetInitialSize()).(clone.Cloner); ok {
		target.InitialSize = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	} else {
		target.InitialSize = proto.Clone(m.GetInitialSize()).(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_OAuthConfig) Clone() proto.Message {
	var target *ExtAuthConfig_OAuthConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OAuthConfig{}

	target.ClientId = m.GetClientId()

	target.ClientSecret = m.GetClientSecret()

	target.IssuerUrl = m.GetIssuerUrl()

	if m.GetAuthEndpointQueryParams() != nil {
		target.AuthEndpointQueryParams = make(map[string]string, len(m.GetAuthEndpointQueryParams()))
		for k, v := range m.GetAuthEndpointQueryParams() {

			target.AuthEndpointQueryParams[k] = v

		}
	}

	target.AppUrl = m.GetAppUrl()

	target.CallbackPath = m.GetCallbackPath()

	if m.GetScopes() != nil {
		target.Scopes = make([]string, len(m.GetScopes()))
		for idx, v := range m.GetScopes() {

			target.Scopes[idx] = v

		}
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_OidcAuthorizationCodeConfig) Clone() proto.Message {
	var target *ExtAuthConfig_OidcAuthorizationCodeConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OidcAuthorizationCodeConfig{}

	target.ClientId = m.GetClientId()

	target.ClientSecret = m.GetClientSecret()

	target.IssuerUrl = m.GetIssuerUrl()

	if m.GetAuthEndpointQueryParams() != nil {
		target.AuthEndpointQueryParams = make(map[string]string, len(m.GetAuthEndpointQueryParams()))
		for k, v := range m.GetAuthEndpointQueryParams() {

			target.AuthEndpointQueryParams[k] = v

		}
	}

	if m.GetTokenEndpointQueryParams() != nil {
		target.TokenEndpointQueryParams = make(map[string]string, len(m.GetTokenEndpointQueryParams()))
		for k, v := range m.GetTokenEndpointQueryParams() {

			target.TokenEndpointQueryParams[k] = v

		}
	}

	target.AppUrl = m.GetAppUrl()

	target.CallbackPath = m.GetCallbackPath()

	target.LogoutPath = m.GetLogoutPath()

	target.AfterLogoutUrl = m.GetAfterLogoutUrl()

	if m.GetScopes() != nil {
		target.Scopes = make([]string, len(m.GetScopes()))
		for idx, v := range m.GetScopes() {

			target.Scopes[idx] = v

		}
	}

	if h, ok := interface{}(m.GetSession()).(clone.Cloner); ok {
		target.Session = h.Clone().(*UserSession)
	} else {
		target.Session = proto.Clone(m.GetSession()).(*UserSession)
	}

	if h, ok := interface{}(m.GetHeaders()).(clone.Cloner); ok {
		target.Headers = h.Clone().(*HeaderConfiguration)
	} else {
		target.Headers = proto.Clone(m.GetHeaders()).(*HeaderConfiguration)
	}

	if h, ok := interface{}(m.GetDiscoveryOverride()).(clone.Cloner); ok {
		target.DiscoveryOverride = h.Clone().(*DiscoveryOverride)
	} else {
		target.DiscoveryOverride = proto.Clone(m.GetDiscoveryOverride()).(*DiscoveryOverride)
	}

	if h, ok := interface{}(m.GetDiscoveryPollInterval()).(clone.Cloner); ok {
		target.DiscoveryPollInterval = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.DiscoveryPollInterval = proto.Clone(m.GetDiscoveryPollInterval()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	if h, ok := interface{}(m.GetJwksCacheRefreshPolicy()).(clone.Cloner); ok {
		target.JwksCacheRefreshPolicy = h.Clone().(*JwksOnDemandCacheRefreshPolicy)
	} else {
		target.JwksCacheRefreshPolicy = proto.Clone(m.GetJwksCacheRefreshPolicy()).(*JwksOnDemandCacheRefreshPolicy)
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_AccessTokenValidationConfig) Clone() proto.Message {
	var target *ExtAuthConfig_AccessTokenValidationConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_AccessTokenValidationConfig{}

	target.UserinfoUrl = m.GetUserinfoUrl()

	if h, ok := interface{}(m.GetCacheTimeout()).(clone.Cloner); ok {
		target.CacheTimeout = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.CacheTimeout = proto.Clone(m.GetCacheTimeout()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	switch m.ValidationType.(type) {

	case *ExtAuthConfig_AccessTokenValidationConfig_IntrospectionUrl:

		target.ValidationType = &ExtAuthConfig_AccessTokenValidationConfig_IntrospectionUrl{
			IntrospectionUrl: m.GetIntrospectionUrl(),
		}

	case *ExtAuthConfig_AccessTokenValidationConfig_Jwt:

		if h, ok := interface{}(m.GetJwt()).(clone.Cloner); ok {
			target.ValidationType = &ExtAuthConfig_AccessTokenValidationConfig_Jwt{
				Jwt: h.Clone().(*ExtAuthConfig_AccessTokenValidationConfig_JwtValidation),
			}
		} else {
			target.ValidationType = &ExtAuthConfig_AccessTokenValidationConfig_Jwt{
				Jwt: proto.Clone(m.GetJwt()).(*ExtAuthConfig_AccessTokenValidationConfig_JwtValidation),
			}
		}

	case *ExtAuthConfig_AccessTokenValidationConfig_Introspection:

		if h, ok := interface{}(m.GetIntrospection()).(clone.Cloner); ok {
			target.ValidationType = &ExtAuthConfig_AccessTokenValidationConfig_Introspection{
				Introspection: h.Clone().(*ExtAuthConfig_AccessTokenValidationConfig_IntrospectionValidation),
			}
		} else {
			target.ValidationType = &ExtAuthConfig_AccessTokenValidationConfig_Introspection{
				Introspection: proto.Clone(m.GetIntrospection()).(*ExtAuthConfig_AccessTokenValidationConfig_IntrospectionValidation),
			}
		}

	}

	switch m.ScopeValidation.(type) {

	case *ExtAuthConfig_AccessTokenValidationConfig_RequiredScopes:

		if h, ok := interface{}(m.GetRequiredScopes()).(clone.Cloner); ok {
			target.ScopeValidation = &ExtAuthConfig_AccessTokenValidationConfig_RequiredScopes{
				RequiredScopes: h.Clone().(*ExtAuthConfig_AccessTokenValidationConfig_ScopeList),
			}
		} else {
			target.ScopeValidation = &ExtAuthConfig_AccessTokenValidationConfig_RequiredScopes{
				RequiredScopes: proto.Clone(m.GetRequiredScopes()).(*ExtAuthConfig_AccessTokenValidationConfig_ScopeList),
			}
		}

	}

	return target
}

// Clone function
func (m *ExtAuthConfig_OAuth2Config) Clone() proto.Message {
	var target *ExtAuthConfig_OAuth2Config
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OAuth2Config{}

	switch m.OauthType.(type) {

	case *ExtAuthConfig_OAuth2Config_OidcAuthorizationCode:

		if h, ok := interface{}(m.GetOidcAuthorizationCode()).(clone.Cloner); ok {
			target.OauthType = &ExtAuthConfig_OAuth2Config_OidcAuthorizationCode{
				OidcAuthorizationCode: h.Clone().(*ExtAuthConfig_OidcAuthorizationCodeConfig),
			}
		} else {
			target.OauthType = &ExtAuthConfig_OAuth2Config_OidcAuthorizationCode{
				OidcAuthorizationCode: proto.Clone(m.GetOidcAuthorizationCode()).(*ExtAuthConfig_OidcAuthorizationCodeConfig),
			}
		}

	case *ExtAuthConfig_OAuth2Config_AccessTokenValidationConfig:

		if h, ok := interface{}(m.GetAccessTokenValidationConfig()).(clone.Cloner); ok {
			target.OauthType = &ExtAuthConfig_OAuth2Config_AccessTokenValidationConfig{
				AccessTokenValidationConfig: h.Clone().(*ExtAuthConfig_AccessTokenValidationConfig),
			}
		} else {
			target.OauthType = &ExtAuthConfig_OAuth2Config_AccessTokenValidationConfig{
				AccessTokenValidationConfig: proto.Clone(m.GetAccessTokenValidationConfig()).(*ExtAuthConfig_AccessTokenValidationConfig),
			}
		}

	}

	return target
}

// Clone function
func (m *ExtAuthConfig_ApiKeyAuthConfig) Clone() proto.Message {
	var target *ExtAuthConfig_ApiKeyAuthConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_ApiKeyAuthConfig{}

	if m.GetValidApiKeys() != nil {
		target.ValidApiKeys = make(map[string]*ExtAuthConfig_ApiKeyAuthConfig_KeyMetadata, len(m.GetValidApiKeys()))
		for k, v := range m.GetValidApiKeys() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ValidApiKeys[k] = h.Clone().(*ExtAuthConfig_ApiKeyAuthConfig_KeyMetadata)
			} else {
				target.ValidApiKeys[k] = proto.Clone(v).(*ExtAuthConfig_ApiKeyAuthConfig_KeyMetadata)
			}

		}
	}

	target.HeaderName = m.GetHeaderName()

	if m.GetHeadersFromKeyMetadata() != nil {
		target.HeadersFromKeyMetadata = make(map[string]string, len(m.GetHeadersFromKeyMetadata()))
		for k, v := range m.GetHeadersFromKeyMetadata() {

			target.HeadersFromKeyMetadata[k] = v

		}
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_OpaAuthConfig) Clone() proto.Message {
	var target *ExtAuthConfig_OpaAuthConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OpaAuthConfig{}

	if m.GetModules() != nil {
		target.Modules = make(map[string]string, len(m.GetModules()))
		for k, v := range m.GetModules() {

			target.Modules[k] = v

		}
	}

	target.Query = m.GetQuery()

	return target
}

// Clone function
func (m *ExtAuthConfig_Config) Clone() proto.Message {
	var target *ExtAuthConfig_Config
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_Config{}

	if h, ok := interface{}(m.GetName()).(clone.Cloner); ok {
		target.Name = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	} else {
		target.Name = proto.Clone(m.GetName()).(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	}

	switch m.AuthConfig.(type) {

	case *ExtAuthConfig_Config_Oauth:

		if h, ok := interface{}(m.GetOauth()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_Oauth{
				Oauth: h.Clone().(*ExtAuthConfig_OAuthConfig),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_Oauth{
				Oauth: proto.Clone(m.GetOauth()).(*ExtAuthConfig_OAuthConfig),
			}
		}

	case *ExtAuthConfig_Config_Oauth2:

		if h, ok := interface{}(m.GetOauth2()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_Oauth2{
				Oauth2: h.Clone().(*ExtAuthConfig_OAuth2Config),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_Oauth2{
				Oauth2: proto.Clone(m.GetOauth2()).(*ExtAuthConfig_OAuth2Config),
			}
		}

	case *ExtAuthConfig_Config_BasicAuth:

		if h, ok := interface{}(m.GetBasicAuth()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_BasicAuth{
				BasicAuth: h.Clone().(*BasicAuth),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_BasicAuth{
				BasicAuth: proto.Clone(m.GetBasicAuth()).(*BasicAuth),
			}
		}

	case *ExtAuthConfig_Config_ApiKeyAuth:

		if h, ok := interface{}(m.GetApiKeyAuth()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_ApiKeyAuth{
				ApiKeyAuth: h.Clone().(*ExtAuthConfig_ApiKeyAuthConfig),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_ApiKeyAuth{
				ApiKeyAuth: proto.Clone(m.GetApiKeyAuth()).(*ExtAuthConfig_ApiKeyAuthConfig),
			}
		}

	case *ExtAuthConfig_Config_PluginAuth:

		if h, ok := interface{}(m.GetPluginAuth()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_PluginAuth{
				PluginAuth: h.Clone().(*AuthPlugin),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_PluginAuth{
				PluginAuth: proto.Clone(m.GetPluginAuth()).(*AuthPlugin),
			}
		}

	case *ExtAuthConfig_Config_OpaAuth:

		if h, ok := interface{}(m.GetOpaAuth()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_OpaAuth{
				OpaAuth: h.Clone().(*ExtAuthConfig_OpaAuthConfig),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_OpaAuth{
				OpaAuth: proto.Clone(m.GetOpaAuth()).(*ExtAuthConfig_OpaAuthConfig),
			}
		}

	case *ExtAuthConfig_Config_Ldap:

		if h, ok := interface{}(m.GetLdap()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_Ldap{
				Ldap: h.Clone().(*Ldap),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_Ldap{
				Ldap: proto.Clone(m.GetLdap()).(*Ldap),
			}
		}

	case *ExtAuthConfig_Config_Jwt:

		if h, ok := interface{}(m.GetJwt()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_Jwt{
				Jwt: h.Clone().(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_Jwt{
				Jwt: proto.Clone(m.GetJwt()).(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		}

	case *ExtAuthConfig_Config_PassThroughAuth:

		if h, ok := interface{}(m.GetPassThroughAuth()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_PassThroughAuth{
				PassThroughAuth: h.Clone().(*PassThroughAuth),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_PassThroughAuth{
				PassThroughAuth: proto.Clone(m.GetPassThroughAuth()).(*PassThroughAuth),
			}
		}

	}

	return target
}

// Clone function
func (m *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation) Clone() proto.Message {
	var target *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_AccessTokenValidationConfig_JwtValidation{}

	target.Issuer = m.GetIssuer()

	switch m.JwksSourceSpecifier.(type) {

	case *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks_:

		if h, ok := interface{}(m.GetRemoteJwks()).(clone.Cloner); ok {
			target.JwksSourceSpecifier = &ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks_{
				RemoteJwks: h.Clone().(*ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks),
			}
		} else {
			target.JwksSourceSpecifier = &ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks_{
				RemoteJwks: proto.Clone(m.GetRemoteJwks()).(*ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks),
			}
		}

	case *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks_:

		if h, ok := interface{}(m.GetLocalJwks()).(clone.Cloner); ok {
			target.JwksSourceSpecifier = &ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks_{
				LocalJwks: h.Clone().(*ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks),
			}
		} else {
			target.JwksSourceSpecifier = &ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks_{
				LocalJwks: proto.Clone(m.GetLocalJwks()).(*ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks),
			}
		}

	}

	return target
}

// Clone function
func (m *ExtAuthConfig_AccessTokenValidationConfig_IntrospectionValidation) Clone() proto.Message {
	var target *ExtAuthConfig_AccessTokenValidationConfig_IntrospectionValidation
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_AccessTokenValidationConfig_IntrospectionValidation{}

	target.IntrospectionUrl = m.GetIntrospectionUrl()

	target.ClientId = m.GetClientId()

	target.ClientSecret = m.GetClientSecret()

	target.UserIdAttributeName = m.GetUserIdAttributeName()

	return target
}

// Clone function
func (m *ExtAuthConfig_AccessTokenValidationConfig_ScopeList) Clone() proto.Message {
	var target *ExtAuthConfig_AccessTokenValidationConfig_ScopeList
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_AccessTokenValidationConfig_ScopeList{}

	if m.GetScope() != nil {
		target.Scope = make([]string, len(m.GetScope()))
		for idx, v := range m.GetScope() {

			target.Scope[idx] = v

		}
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks) Clone() proto.Message {
	var target *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks{}

	target.Url = m.GetUrl()

	if h, ok := interface{}(m.GetRefreshInterval()).(clone.Cloner); ok {
		target.RefreshInterval = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.RefreshInterval = proto.Clone(m.GetRefreshInterval()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks) Clone() proto.Message {
	var target *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks{}

	target.InlineString = m.GetInlineString()

	return target
}

// Clone function
func (m *ExtAuthConfig_ApiKeyAuthConfig_KeyMetadata) Clone() proto.Message {
	var target *ExtAuthConfig_ApiKeyAuthConfig_KeyMetadata
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_ApiKeyAuthConfig_KeyMetadata{}

	target.Username = m.GetUsername()

	if m.GetMetadata() != nil {
		target.Metadata = make(map[string]string, len(m.GetMetadata()))
		for k, v := range m.GetMetadata() {

			target.Metadata[k] = v

		}
	}

	return target
}
