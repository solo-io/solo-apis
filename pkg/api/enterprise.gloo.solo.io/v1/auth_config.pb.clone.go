// Code generated by protoc-gen-ext. DO NOT EDIT.
// source: github.com/solo-io/solo-apis/api/gloo/enterprise.gloo/v1/auth_config.proto

package v1

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"strings"

	"github.com/solo-io/protoc-gen-ext/pkg/clone"
	"google.golang.org/protobuf/proto"

	github_com_golang_protobuf_ptypes_duration "github.com/golang/protobuf/ptypes/duration"

	github_com_golang_protobuf_ptypes_empty "github.com/golang/protobuf/ptypes/empty"

	github_com_golang_protobuf_ptypes_struct "github.com/golang/protobuf/ptypes/struct"

	github_com_golang_protobuf_ptypes_wrappers "github.com/golang/protobuf/ptypes/wrappers"

	github_com_solo_io_solo_kit_pkg_api_v1_resources_core "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
)

// ensure the imports are used
var (
	_ = errors.New("")
	_ = fmt.Print
	_ = binary.LittleEndian
	_ = bytes.Compare
	_ = strings.Compare
	_ = clone.Cloner(nil)
	_ = proto.Message(nil)
)

// Clone function
func (m *AuthConfigSpec) Clone() proto.Message {
	var target *AuthConfigSpec
	if m == nil {
		return target
	}
	target = &AuthConfigSpec{}

	if m.GetConfigs() != nil {
		target.Configs = make([]*AuthConfigSpec_Config, len(m.GetConfigs()))
		for idx, v := range m.GetConfigs() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Configs[idx] = h.Clone().(*AuthConfigSpec_Config)
			} else {
				target.Configs[idx] = proto.Clone(v).(*AuthConfigSpec_Config)
			}

		}
	}

	if h, ok := interface{}(m.GetBooleanExpr()).(clone.Cloner); ok {
		target.BooleanExpr = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	} else {
		target.BooleanExpr = proto.Clone(m.GetBooleanExpr()).(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	}

	target.FailOnRedirect = m.GetFailOnRedirect()

	return target
}

// Clone function
func (m *ExtAuthExtension) Clone() proto.Message {
	var target *ExtAuthExtension
	if m == nil {
		return target
	}
	target = &ExtAuthExtension{}

	switch m.Spec.(type) {

	case *ExtAuthExtension_Disable:

		target.Spec = &ExtAuthExtension_Disable{
			Disable: m.GetDisable(),
		}

	case *ExtAuthExtension_ConfigRef:

		if h, ok := interface{}(m.GetConfigRef()).(clone.Cloner); ok {
			target.Spec = &ExtAuthExtension_ConfigRef{
				ConfigRef: h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef),
			}
		} else {
			target.Spec = &ExtAuthExtension_ConfigRef{
				ConfigRef: proto.Clone(m.GetConfigRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef),
			}
		}

	case *ExtAuthExtension_CustomAuth:

		if h, ok := interface{}(m.GetCustomAuth()).(clone.Cloner); ok {
			target.Spec = &ExtAuthExtension_CustomAuth{
				CustomAuth: h.Clone().(*CustomAuth),
			}
		} else {
			target.Spec = &ExtAuthExtension_CustomAuth{
				CustomAuth: proto.Clone(m.GetCustomAuth()).(*CustomAuth),
			}
		}

	}

	return target
}

// Clone function
func (m *Settings) Clone() proto.Message {
	var target *Settings
	if m == nil {
		return target
	}
	target = &Settings{}

	if h, ok := interface{}(m.GetExtauthzServerRef()).(clone.Cloner); ok {
		target.ExtauthzServerRef = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	} else {
		target.ExtauthzServerRef = proto.Clone(m.GetExtauthzServerRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	}

	target.UserIdHeader = m.GetUserIdHeader()

	if h, ok := interface{}(m.GetRequestTimeout()).(clone.Cloner); ok {
		target.RequestTimeout = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.RequestTimeout = proto.Clone(m.GetRequestTimeout()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	target.FailureModeAllow = m.GetFailureModeAllow()

	if h, ok := interface{}(m.GetRequestBody()).(clone.Cloner); ok {
		target.RequestBody = h.Clone().(*BufferSettings)
	} else {
		target.RequestBody = proto.Clone(m.GetRequestBody()).(*BufferSettings)
	}

	target.ClearRouteCache = m.GetClearRouteCache()

	target.StatusOnError = m.GetStatusOnError()

	target.TransportApiVersion = m.GetTransportApiVersion()

	target.StatPrefix = m.GetStatPrefix()

	switch m.ServiceType.(type) {

	case *Settings_HttpService:

		if h, ok := interface{}(m.GetHttpService()).(clone.Cloner); ok {
			target.ServiceType = &Settings_HttpService{
				HttpService: h.Clone().(*HttpService),
			}
		} else {
			target.ServiceType = &Settings_HttpService{
				HttpService: proto.Clone(m.GetHttpService()).(*HttpService),
			}
		}

	case *Settings_GrpcService:

		if h, ok := interface{}(m.GetGrpcService()).(clone.Cloner); ok {
			target.ServiceType = &Settings_GrpcService{
				GrpcService: h.Clone().(*GrpcService),
			}
		} else {
			target.ServiceType = &Settings_GrpcService{
				GrpcService: proto.Clone(m.GetGrpcService()).(*GrpcService),
			}
		}

	}

	return target
}

// Clone function
func (m *GrpcService) Clone() proto.Message {
	var target *GrpcService
	if m == nil {
		return target
	}
	target = &GrpcService{}

	target.Authority = m.GetAuthority()

	return target
}

// Clone function
func (m *HttpService) Clone() proto.Message {
	var target *HttpService
	if m == nil {
		return target
	}
	target = &HttpService{}

	target.PathPrefix = m.GetPathPrefix()

	if h, ok := interface{}(m.GetRequest()).(clone.Cloner); ok {
		target.Request = h.Clone().(*HttpService_Request)
	} else {
		target.Request = proto.Clone(m.GetRequest()).(*HttpService_Request)
	}

	if h, ok := interface{}(m.GetResponse()).(clone.Cloner); ok {
		target.Response = h.Clone().(*HttpService_Response)
	} else {
		target.Response = proto.Clone(m.GetResponse()).(*HttpService_Response)
	}

	return target
}

// Clone function
func (m *BufferSettings) Clone() proto.Message {
	var target *BufferSettings
	if m == nil {
		return target
	}
	target = &BufferSettings{}

	target.MaxRequestBytes = m.GetMaxRequestBytes()

	target.AllowPartialMessage = m.GetAllowPartialMessage()

	target.PackAsBytes = m.GetPackAsBytes()

	return target
}

// Clone function
func (m *CustomAuth) Clone() proto.Message {
	var target *CustomAuth
	if m == nil {
		return target
	}
	target = &CustomAuth{}

	if m.GetContextExtensions() != nil {
		target.ContextExtensions = make(map[string]string, len(m.GetContextExtensions()))
		for k, v := range m.GetContextExtensions() {

			target.ContextExtensions[k] = v

		}
	}

	target.Name = m.GetName()

	return target
}

// Clone function
func (m *AuthPlugin) Clone() proto.Message {
	var target *AuthPlugin
	if m == nil {
		return target
	}
	target = &AuthPlugin{}

	target.Name = m.GetName()

	target.PluginFileName = m.GetPluginFileName()

	target.ExportedSymbolName = m.GetExportedSymbolName()

	if h, ok := interface{}(m.GetConfig()).(clone.Cloner); ok {
		target.Config = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
	} else {
		target.Config = proto.Clone(m.GetConfig()).(*github_com_golang_protobuf_ptypes_struct.Struct)
	}

	return target
}

// Clone function
func (m *BasicAuth) Clone() proto.Message {
	var target *BasicAuth
	if m == nil {
		return target
	}
	target = &BasicAuth{}

	target.Realm = m.GetRealm()

	if h, ok := interface{}(m.GetApr()).(clone.Cloner); ok {
		target.Apr = h.Clone().(*BasicAuth_Apr)
	} else {
		target.Apr = proto.Clone(m.GetApr()).(*BasicAuth_Apr)
	}

	if h, ok := interface{}(m.GetEncryption()).(clone.Cloner); ok {
		target.Encryption = h.Clone().(*BasicAuth_EncryptionType)
	} else {
		target.Encryption = proto.Clone(m.GetEncryption()).(*BasicAuth_EncryptionType)
	}

	switch m.UserSource.(type) {

	case *BasicAuth_UserList_:

		if h, ok := interface{}(m.GetUserList()).(clone.Cloner); ok {
			target.UserSource = &BasicAuth_UserList_{
				UserList: h.Clone().(*BasicAuth_UserList),
			}
		} else {
			target.UserSource = &BasicAuth_UserList_{
				UserList: proto.Clone(m.GetUserList()).(*BasicAuth_UserList),
			}
		}

	}

	return target
}

// Clone function
func (m *HmacAuth) Clone() proto.Message {
	var target *HmacAuth
	if m == nil {
		return target
	}
	target = &HmacAuth{}

	switch m.SecretStorage.(type) {

	case *HmacAuth_SecretRefs:

		if h, ok := interface{}(m.GetSecretRefs()).(clone.Cloner); ok {
			target.SecretStorage = &HmacAuth_SecretRefs{
				SecretRefs: h.Clone().(*SecretRefList),
			}
		} else {
			target.SecretStorage = &HmacAuth_SecretRefs{
				SecretRefs: proto.Clone(m.GetSecretRefs()).(*SecretRefList),
			}
		}

	}

	switch m.ImplementationType.(type) {

	case *HmacAuth_ParametersInHeaders:

		if h, ok := interface{}(m.GetParametersInHeaders()).(clone.Cloner); ok {
			target.ImplementationType = &HmacAuth_ParametersInHeaders{
				ParametersInHeaders: h.Clone().(*HmacParametersInHeaders),
			}
		} else {
			target.ImplementationType = &HmacAuth_ParametersInHeaders{
				ParametersInHeaders: proto.Clone(m.GetParametersInHeaders()).(*HmacParametersInHeaders),
			}
		}

	}

	return target
}

// Clone function
func (m *SecretRefList) Clone() proto.Message {
	var target *SecretRefList
	if m == nil {
		return target
	}
	target = &SecretRefList{}

	if m.GetSecretRefs() != nil {
		target.SecretRefs = make([]*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef, len(m.GetSecretRefs()))
		for idx, v := range m.GetSecretRefs() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.SecretRefs[idx] = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
			} else {
				target.SecretRefs[idx] = proto.Clone(v).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
			}

		}
	}

	return target
}

// Clone function
func (m *HmacParametersInHeaders) Clone() proto.Message {
	var target *HmacParametersInHeaders
	if m == nil {
		return target
	}
	target = &HmacParametersInHeaders{}

	return target
}

// Clone function
func (m *OAuth) Clone() proto.Message {
	var target *OAuth
	if m == nil {
		return target
	}
	target = &OAuth{}

	target.ClientId = m.GetClientId()

	if h, ok := interface{}(m.GetClientSecretRef()).(clone.Cloner); ok {
		target.ClientSecretRef = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	} else {
		target.ClientSecretRef = proto.Clone(m.GetClientSecretRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	}

	target.IssuerUrl = m.GetIssuerUrl()

	if m.GetAuthEndpointQueryParams() != nil {
		target.AuthEndpointQueryParams = make(map[string]string, len(m.GetAuthEndpointQueryParams()))
		for k, v := range m.GetAuthEndpointQueryParams() {

			target.AuthEndpointQueryParams[k] = v

		}
	}

	target.AppUrl = m.GetAppUrl()

	target.CallbackPath = m.GetCallbackPath()

	if m.GetScopes() != nil {
		target.Scopes = make([]string, len(m.GetScopes()))
		for idx, v := range m.GetScopes() {

			target.Scopes[idx] = v

		}
	}

	return target
}

// Clone function
func (m *OAuth2) Clone() proto.Message {
	var target *OAuth2
	if m == nil {
		return target
	}
	target = &OAuth2{}

	switch m.OauthType.(type) {

	case *OAuth2_OidcAuthorizationCode:

		if h, ok := interface{}(m.GetOidcAuthorizationCode()).(clone.Cloner); ok {
			target.OauthType = &OAuth2_OidcAuthorizationCode{
				OidcAuthorizationCode: h.Clone().(*OidcAuthorizationCode),
			}
		} else {
			target.OauthType = &OAuth2_OidcAuthorizationCode{
				OidcAuthorizationCode: proto.Clone(m.GetOidcAuthorizationCode()).(*OidcAuthorizationCode),
			}
		}

	case *OAuth2_AccessTokenValidation:

		if h, ok := interface{}(m.GetAccessTokenValidation()).(clone.Cloner); ok {
			target.OauthType = &OAuth2_AccessTokenValidation{
				AccessTokenValidation: h.Clone().(*AccessTokenValidation),
			}
		} else {
			target.OauthType = &OAuth2_AccessTokenValidation{
				AccessTokenValidation: proto.Clone(m.GetAccessTokenValidation()).(*AccessTokenValidation),
			}
		}

	case *OAuth2_Oauth2:

		if h, ok := interface{}(m.GetOauth2()).(clone.Cloner); ok {
			target.OauthType = &OAuth2_Oauth2{
				Oauth2: h.Clone().(*PlainOAuth2),
			}
		} else {
			target.OauthType = &OAuth2_Oauth2{
				Oauth2: proto.Clone(m.GetOauth2()).(*PlainOAuth2),
			}
		}

	}

	return target
}

// Clone function
func (m *RedisOptions) Clone() proto.Message {
	var target *RedisOptions
	if m == nil {
		return target
	}
	target = &RedisOptions{}

	target.Host = m.GetHost()

	target.Db = m.GetDb()

	target.PoolSize = m.GetPoolSize()

	target.TlsCertMountPath = m.GetTlsCertMountPath()

	target.SocketType = m.GetSocketType()

	return target
}

// Clone function
func (m *UserSession) Clone() proto.Message {
	var target *UserSession
	if m == nil {
		return target
	}
	target = &UserSession{}

	target.FailOnFetchFailure = m.GetFailOnFetchFailure()

	if h, ok := interface{}(m.GetCookieOptions()).(clone.Cloner); ok {
		target.CookieOptions = h.Clone().(*UserSession_CookieOptions)
	} else {
		target.CookieOptions = proto.Clone(m.GetCookieOptions()).(*UserSession_CookieOptions)
	}

	if h, ok := interface{}(m.GetCipherConfig()).(clone.Cloner); ok {
		target.CipherConfig = h.Clone().(*UserSession_CipherConfig)
	} else {
		target.CipherConfig = proto.Clone(m.GetCipherConfig()).(*UserSession_CipherConfig)
	}

	switch m.Session.(type) {

	case *UserSession_Cookie:

		if h, ok := interface{}(m.GetCookie()).(clone.Cloner); ok {
			target.Session = &UserSession_Cookie{
				Cookie: h.Clone().(*UserSession_InternalSession),
			}
		} else {
			target.Session = &UserSession_Cookie{
				Cookie: proto.Clone(m.GetCookie()).(*UserSession_InternalSession),
			}
		}

	case *UserSession_Redis:

		if h, ok := interface{}(m.GetRedis()).(clone.Cloner); ok {
			target.Session = &UserSession_Redis{
				Redis: h.Clone().(*UserSession_RedisSession),
			}
		} else {
			target.Session = &UserSession_Redis{
				Redis: proto.Clone(m.GetRedis()).(*UserSession_RedisSession),
			}
		}

	}

	return target
}

// Clone function
func (m *HeaderConfiguration) Clone() proto.Message {
	var target *HeaderConfiguration
	if m == nil {
		return target
	}
	target = &HeaderConfiguration{}

	target.IdTokenHeader = m.GetIdTokenHeader()

	target.AccessTokenHeader = m.GetAccessTokenHeader()

	if h, ok := interface{}(m.GetUseBearerSchemaForAuthorization()).(clone.Cloner); ok {
		target.UseBearerSchemaForAuthorization = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.UseBearerSchemaForAuthorization = proto.Clone(m.GetUseBearerSchemaForAuthorization()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	return target
}

// Clone function
func (m *DiscoveryOverride) Clone() proto.Message {
	var target *DiscoveryOverride
	if m == nil {
		return target
	}
	target = &DiscoveryOverride{}

	target.AuthEndpoint = m.GetAuthEndpoint()

	target.TokenEndpoint = m.GetTokenEndpoint()

	target.JwksUri = m.GetJwksUri()

	if m.GetScopes() != nil {
		target.Scopes = make([]string, len(m.GetScopes()))
		for idx, v := range m.GetScopes() {

			target.Scopes[idx] = v

		}
	}

	if m.GetResponseTypes() != nil {
		target.ResponseTypes = make([]string, len(m.GetResponseTypes()))
		for idx, v := range m.GetResponseTypes() {

			target.ResponseTypes[idx] = v

		}
	}

	if m.GetSubjects() != nil {
		target.Subjects = make([]string, len(m.GetSubjects()))
		for idx, v := range m.GetSubjects() {

			target.Subjects[idx] = v

		}
	}

	if m.GetIdTokenAlgs() != nil {
		target.IdTokenAlgs = make([]string, len(m.GetIdTokenAlgs()))
		for idx, v := range m.GetIdTokenAlgs() {

			target.IdTokenAlgs[idx] = v

		}
	}

	if m.GetAuthMethods() != nil {
		target.AuthMethods = make([]string, len(m.GetAuthMethods()))
		for idx, v := range m.GetAuthMethods() {

			target.AuthMethods[idx] = v

		}
	}

	if m.GetClaims() != nil {
		target.Claims = make([]string, len(m.GetClaims()))
		for idx, v := range m.GetClaims() {

			target.Claims[idx] = v

		}
	}

	target.RevocationEndpoint = m.GetRevocationEndpoint()

	target.EndSessionEndpoint = m.GetEndSessionEndpoint()

	return target
}

// Clone function
func (m *JwksOnDemandCacheRefreshPolicy) Clone() proto.Message {
	var target *JwksOnDemandCacheRefreshPolicy
	if m == nil {
		return target
	}
	target = &JwksOnDemandCacheRefreshPolicy{}

	switch m.Policy.(type) {

	case *JwksOnDemandCacheRefreshPolicy_Never:

		if h, ok := interface{}(m.GetNever()).(clone.Cloner); ok {
			target.Policy = &JwksOnDemandCacheRefreshPolicy_Never{
				Never: h.Clone().(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		} else {
			target.Policy = &JwksOnDemandCacheRefreshPolicy_Never{
				Never: proto.Clone(m.GetNever()).(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		}

	case *JwksOnDemandCacheRefreshPolicy_Always:

		if h, ok := interface{}(m.GetAlways()).(clone.Cloner); ok {
			target.Policy = &JwksOnDemandCacheRefreshPolicy_Always{
				Always: h.Clone().(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		} else {
			target.Policy = &JwksOnDemandCacheRefreshPolicy_Always{
				Always: proto.Clone(m.GetAlways()).(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		}

	case *JwksOnDemandCacheRefreshPolicy_MaxIdpReqPerPollingInterval:

		target.Policy = &JwksOnDemandCacheRefreshPolicy_MaxIdpReqPerPollingInterval{
			MaxIdpReqPerPollingInterval: m.GetMaxIdpReqPerPollingInterval(),
		}

	}

	return target
}

// Clone function
func (m *AutoMapFromMetadata) Clone() proto.Message {
	var target *AutoMapFromMetadata
	if m == nil {
		return target
	}
	target = &AutoMapFromMetadata{}

	target.Namespace = m.GetNamespace()

	return target
}

// Clone function
func (m *EndSessionProperties) Clone() proto.Message {
	var target *EndSessionProperties
	if m == nil {
		return target
	}
	target = &EndSessionProperties{}

	target.MethodType = m.GetMethodType()

	return target
}

// Clone function
func (m *ClaimToHeader) Clone() proto.Message {
	var target *ClaimToHeader
	if m == nil {
		return target
	}
	target = &ClaimToHeader{}

	target.Claim = m.GetClaim()

	target.Header = m.GetHeader()

	target.Append = m.GetAppend()

	return target
}

// Clone function
func (m *Azure) Clone() proto.Message {
	var target *Azure
	if m == nil {
		return target
	}
	target = &Azure{}

	target.ClientId = m.GetClientId()

	target.TenantId = m.GetTenantId()

	if h, ok := interface{}(m.GetClientSecret()).(clone.Cloner); ok {
		target.ClientSecret = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	} else {
		target.ClientSecret = proto.Clone(m.GetClientSecret()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	}

	if h, ok := interface{}(m.GetClaimsCachingOptions()).(clone.Cloner); ok {
		target.ClaimsCachingOptions = h.Clone().(*RedisOptions)
	} else {
		target.ClaimsCachingOptions = proto.Clone(m.GetClaimsCachingOptions()).(*RedisOptions)
	}

	return target
}

// Clone function
func (m *OidcAuthorizationCode) Clone() proto.Message {
	var target *OidcAuthorizationCode
	if m == nil {
		return target
	}
	target = &OidcAuthorizationCode{}

	target.ClientId = m.GetClientId()

	if h, ok := interface{}(m.GetClientSecretRef()).(clone.Cloner); ok {
		target.ClientSecretRef = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	} else {
		target.ClientSecretRef = proto.Clone(m.GetClientSecretRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	}

	target.IssuerUrl = m.GetIssuerUrl()

	if m.GetAuthEndpointQueryParams() != nil {
		target.AuthEndpointQueryParams = make(map[string]string, len(m.GetAuthEndpointQueryParams()))
		for k, v := range m.GetAuthEndpointQueryParams() {

			target.AuthEndpointQueryParams[k] = v

		}
	}

	if m.GetTokenEndpointQueryParams() != nil {
		target.TokenEndpointQueryParams = make(map[string]string, len(m.GetTokenEndpointQueryParams()))
		for k, v := range m.GetTokenEndpointQueryParams() {

			target.TokenEndpointQueryParams[k] = v

		}
	}

	target.AppUrl = m.GetAppUrl()

	target.CallbackPath = m.GetCallbackPath()

	target.LogoutPath = m.GetLogoutPath()

	target.AfterLogoutUrl = m.GetAfterLogoutUrl()

	if m.GetScopes() != nil {
		target.Scopes = make([]string, len(m.GetScopes()))
		for idx, v := range m.GetScopes() {

			target.Scopes[idx] = v

		}
	}

	if h, ok := interface{}(m.GetSession()).(clone.Cloner); ok {
		target.Session = h.Clone().(*UserSession)
	} else {
		target.Session = proto.Clone(m.GetSession()).(*UserSession)
	}

	if h, ok := interface{}(m.GetHeaders()).(clone.Cloner); ok {
		target.Headers = h.Clone().(*HeaderConfiguration)
	} else {
		target.Headers = proto.Clone(m.GetHeaders()).(*HeaderConfiguration)
	}

	if h, ok := interface{}(m.GetDiscoveryOverride()).(clone.Cloner); ok {
		target.DiscoveryOverride = h.Clone().(*DiscoveryOverride)
	} else {
		target.DiscoveryOverride = proto.Clone(m.GetDiscoveryOverride()).(*DiscoveryOverride)
	}

	if h, ok := interface{}(m.GetDiscoveryPollInterval()).(clone.Cloner); ok {
		target.DiscoveryPollInterval = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.DiscoveryPollInterval = proto.Clone(m.GetDiscoveryPollInterval()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	if h, ok := interface{}(m.GetJwksCacheRefreshPolicy()).(clone.Cloner); ok {
		target.JwksCacheRefreshPolicy = h.Clone().(*JwksOnDemandCacheRefreshPolicy)
	} else {
		target.JwksCacheRefreshPolicy = proto.Clone(m.GetJwksCacheRefreshPolicy()).(*JwksOnDemandCacheRefreshPolicy)
	}

	target.SessionIdHeaderName = m.GetSessionIdHeaderName()

	target.ParseCallbackPathAsRegex = m.GetParseCallbackPathAsRegex()

	if h, ok := interface{}(m.GetAutoMapFromMetadata()).(clone.Cloner); ok {
		target.AutoMapFromMetadata = h.Clone().(*AutoMapFromMetadata)
	} else {
		target.AutoMapFromMetadata = proto.Clone(m.GetAutoMapFromMetadata()).(*AutoMapFromMetadata)
	}

	if h, ok := interface{}(m.GetEndSessionProperties()).(clone.Cloner); ok {
		target.EndSessionProperties = h.Clone().(*EndSessionProperties)
	} else {
		target.EndSessionProperties = proto.Clone(m.GetEndSessionProperties()).(*EndSessionProperties)
	}

	if m.GetDynamicMetadataFromClaims() != nil {
		target.DynamicMetadataFromClaims = make(map[string]string, len(m.GetDynamicMetadataFromClaims()))
		for k, v := range m.GetDynamicMetadataFromClaims() {

			target.DynamicMetadataFromClaims[k] = v

		}
	}

	if h, ok := interface{}(m.GetDisableClientSecret()).(clone.Cloner); ok {
		target.DisableClientSecret = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.DisableClientSecret = proto.Clone(m.GetDisableClientSecret()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	if h, ok := interface{}(m.GetAccessToken()).(clone.Cloner); ok {
		target.AccessToken = h.Clone().(*OidcAuthorizationCode_AccessToken)
	} else {
		target.AccessToken = proto.Clone(m.GetAccessToken()).(*OidcAuthorizationCode_AccessToken)
	}

	if h, ok := interface{}(m.GetIdentityToken()).(clone.Cloner); ok {
		target.IdentityToken = h.Clone().(*OidcAuthorizationCode_IdentityToken)
	} else {
		target.IdentityToken = proto.Clone(m.GetIdentityToken()).(*OidcAuthorizationCode_IdentityToken)
	}

	if h, ok := interface{}(m.GetClientAuthentication()).(clone.Cloner); ok {
		target.ClientAuthentication = h.Clone().(*OidcAuthorizationCode_ClientAuthentication)
	} else {
		target.ClientAuthentication = proto.Clone(m.GetClientAuthentication()).(*OidcAuthorizationCode_ClientAuthentication)
	}

	if h, ok := interface{}(m.GetFrontChannelLogout()).(clone.Cloner); ok {
		target.FrontChannelLogout = h.Clone().(*OidcAuthorizationCode_FrontChannelLogout)
	} else {
		target.FrontChannelLogout = proto.Clone(m.GetFrontChannelLogout()).(*OidcAuthorizationCode_FrontChannelLogout)
	}

	switch m.Provider.(type) {

	case *OidcAuthorizationCode_Default_:

		if h, ok := interface{}(m.GetDefault()).(clone.Cloner); ok {
			target.Provider = &OidcAuthorizationCode_Default_{
				Default: h.Clone().(*OidcAuthorizationCode_Default),
			}
		} else {
			target.Provider = &OidcAuthorizationCode_Default_{
				Default: proto.Clone(m.GetDefault()).(*OidcAuthorizationCode_Default),
			}
		}

	case *OidcAuthorizationCode_Azure:

		if h, ok := interface{}(m.GetAzure()).(clone.Cloner); ok {
			target.Provider = &OidcAuthorizationCode_Azure{
				Azure: h.Clone().(*Azure),
			}
		} else {
			target.Provider = &OidcAuthorizationCode_Azure{
				Azure: proto.Clone(m.GetAzure()).(*Azure),
			}
		}

	}

	return target
}

// Clone function
func (m *PlainOAuth2) Clone() proto.Message {
	var target *PlainOAuth2
	if m == nil {
		return target
	}
	target = &PlainOAuth2{}

	target.ClientId = m.GetClientId()

	if h, ok := interface{}(m.GetClientSecretRef()).(clone.Cloner); ok {
		target.ClientSecretRef = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	} else {
		target.ClientSecretRef = proto.Clone(m.GetClientSecretRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	}

	if m.GetAuthEndpointQueryParams() != nil {
		target.AuthEndpointQueryParams = make(map[string]string, len(m.GetAuthEndpointQueryParams()))
		for k, v := range m.GetAuthEndpointQueryParams() {

			target.AuthEndpointQueryParams[k] = v

		}
	}

	target.AppUrl = m.GetAppUrl()

	target.CallbackPath = m.GetCallbackPath()

	if m.GetScopes() != nil {
		target.Scopes = make([]string, len(m.GetScopes()))
		for idx, v := range m.GetScopes() {

			target.Scopes[idx] = v

		}
	}

	if h, ok := interface{}(m.GetSession()).(clone.Cloner); ok {
		target.Session = h.Clone().(*UserSession)
	} else {
		target.Session = proto.Clone(m.GetSession()).(*UserSession)
	}

	target.LogoutPath = m.GetLogoutPath()

	if m.GetTokenEndpointQueryParams() != nil {
		target.TokenEndpointQueryParams = make(map[string]string, len(m.GetTokenEndpointQueryParams()))
		for k, v := range m.GetTokenEndpointQueryParams() {

			target.TokenEndpointQueryParams[k] = v

		}
	}

	target.AfterLogoutUrl = m.GetAfterLogoutUrl()

	target.AuthEndpoint = m.GetAuthEndpoint()

	target.TokenEndpoint = m.GetTokenEndpoint()

	target.RevocationEndpoint = m.GetRevocationEndpoint()

	if h, ok := interface{}(m.GetDisableClientSecret()).(clone.Cloner); ok {
		target.DisableClientSecret = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.DisableClientSecret = proto.Clone(m.GetDisableClientSecret()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	return target
}

// Clone function
func (m *JwtValidation) Clone() proto.Message {
	var target *JwtValidation
	if m == nil {
		return target
	}
	target = &JwtValidation{}

	target.Issuer = m.GetIssuer()

	switch m.JwksSourceSpecifier.(type) {

	case *JwtValidation_RemoteJwks_:

		if h, ok := interface{}(m.GetRemoteJwks()).(clone.Cloner); ok {
			target.JwksSourceSpecifier = &JwtValidation_RemoteJwks_{
				RemoteJwks: h.Clone().(*JwtValidation_RemoteJwks),
			}
		} else {
			target.JwksSourceSpecifier = &JwtValidation_RemoteJwks_{
				RemoteJwks: proto.Clone(m.GetRemoteJwks()).(*JwtValidation_RemoteJwks),
			}
		}

	case *JwtValidation_LocalJwks_:

		if h, ok := interface{}(m.GetLocalJwks()).(clone.Cloner); ok {
			target.JwksSourceSpecifier = &JwtValidation_LocalJwks_{
				LocalJwks: h.Clone().(*JwtValidation_LocalJwks),
			}
		} else {
			target.JwksSourceSpecifier = &JwtValidation_LocalJwks_{
				LocalJwks: proto.Clone(m.GetLocalJwks()).(*JwtValidation_LocalJwks),
			}
		}

	}

	return target
}

// Clone function
func (m *IntrospectionValidation) Clone() proto.Message {
	var target *IntrospectionValidation
	if m == nil {
		return target
	}
	target = &IntrospectionValidation{}

	target.IntrospectionUrl = m.GetIntrospectionUrl()

	target.ClientId = m.GetClientId()

	if h, ok := interface{}(m.GetClientSecretRef()).(clone.Cloner); ok {
		target.ClientSecretRef = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	} else {
		target.ClientSecretRef = proto.Clone(m.GetClientSecretRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	}

	target.UserIdAttributeName = m.GetUserIdAttributeName()

	if h, ok := interface{}(m.GetDisableClientSecret()).(clone.Cloner); ok {
		target.DisableClientSecret = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.DisableClientSecret = proto.Clone(m.GetDisableClientSecret()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	return target
}

// Clone function
func (m *AccessTokenValidation) Clone() proto.Message {
	var target *AccessTokenValidation
	if m == nil {
		return target
	}
	target = &AccessTokenValidation{}

	target.UserinfoUrl = m.GetUserinfoUrl()

	if h, ok := interface{}(m.GetCacheTimeout()).(clone.Cloner); ok {
		target.CacheTimeout = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.CacheTimeout = proto.Clone(m.GetCacheTimeout()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	if m.GetDynamicMetadataFromClaims() != nil {
		target.DynamicMetadataFromClaims = make(map[string]string, len(m.GetDynamicMetadataFromClaims()))
		for k, v := range m.GetDynamicMetadataFromClaims() {

			target.DynamicMetadataFromClaims[k] = v

		}
	}

	if m.GetClaimsToHeaders() != nil {
		target.ClaimsToHeaders = make([]*ClaimToHeader, len(m.GetClaimsToHeaders()))
		for idx, v := range m.GetClaimsToHeaders() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ClaimsToHeaders[idx] = h.Clone().(*ClaimToHeader)
			} else {
				target.ClaimsToHeaders[idx] = proto.Clone(v).(*ClaimToHeader)
			}

		}
	}

	if h, ok := interface{}(m.GetAzure()).(clone.Cloner); ok {
		target.Azure = h.Clone().(*Azure)
	} else {
		target.Azure = proto.Clone(m.GetAzure()).(*Azure)
	}

	switch m.ValidationType.(type) {

	case *AccessTokenValidation_IntrospectionUrl:

		target.ValidationType = &AccessTokenValidation_IntrospectionUrl{
			IntrospectionUrl: m.GetIntrospectionUrl(),
		}

	case *AccessTokenValidation_Jwt:

		if h, ok := interface{}(m.GetJwt()).(clone.Cloner); ok {
			target.ValidationType = &AccessTokenValidation_Jwt{
				Jwt: h.Clone().(*JwtValidation),
			}
		} else {
			target.ValidationType = &AccessTokenValidation_Jwt{
				Jwt: proto.Clone(m.GetJwt()).(*JwtValidation),
			}
		}

	case *AccessTokenValidation_Introspection:

		if h, ok := interface{}(m.GetIntrospection()).(clone.Cloner); ok {
			target.ValidationType = &AccessTokenValidation_Introspection{
				Introspection: h.Clone().(*IntrospectionValidation),
			}
		} else {
			target.ValidationType = &AccessTokenValidation_Introspection{
				Introspection: proto.Clone(m.GetIntrospection()).(*IntrospectionValidation),
			}
		}

	}

	switch m.ScopeValidation.(type) {

	case *AccessTokenValidation_RequiredScopes:

		if h, ok := interface{}(m.GetRequiredScopes()).(clone.Cloner); ok {
			target.ScopeValidation = &AccessTokenValidation_RequiredScopes{
				RequiredScopes: h.Clone().(*AccessTokenValidation_ScopeList),
			}
		} else {
			target.ScopeValidation = &AccessTokenValidation_RequiredScopes{
				RequiredScopes: proto.Clone(m.GetRequiredScopes()).(*AccessTokenValidation_ScopeList),
			}
		}

	}

	return target
}

// Clone function
func (m *OauthSecret) Clone() proto.Message {
	var target *OauthSecret
	if m == nil {
		return target
	}
	target = &OauthSecret{}

	target.ClientSecret = m.GetClientSecret()

	return target
}

// Clone function
func (m *ApiKeyAuth) Clone() proto.Message {
	var target *ApiKeyAuth
	if m == nil {
		return target
	}
	target = &ApiKeyAuth{}

	if m.GetLabelSelector() != nil {
		target.LabelSelector = make(map[string]string, len(m.GetLabelSelector()))
		for k, v := range m.GetLabelSelector() {

			target.LabelSelector[k] = v

		}
	}

	if m.GetApiKeySecretRefs() != nil {
		target.ApiKeySecretRefs = make([]*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef, len(m.GetApiKeySecretRefs()))
		for idx, v := range m.GetApiKeySecretRefs() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ApiKeySecretRefs[idx] = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
			} else {
				target.ApiKeySecretRefs[idx] = proto.Clone(v).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
			}

		}
	}

	target.HeaderName = m.GetHeaderName()

	if m.GetHeadersFromMetadata() != nil {
		target.HeadersFromMetadata = make(map[string]*ApiKeyAuth_SecretKey, len(m.GetHeadersFromMetadata()))
		for k, v := range m.GetHeadersFromMetadata() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.HeadersFromMetadata[k] = h.Clone().(*ApiKeyAuth_SecretKey)
			} else {
				target.HeadersFromMetadata[k] = proto.Clone(v).(*ApiKeyAuth_SecretKey)
			}

		}
	}

	if m.GetHeadersFromMetadataEntry() != nil {
		target.HeadersFromMetadataEntry = make(map[string]*ApiKeyAuth_MetadataEntry, len(m.GetHeadersFromMetadataEntry()))
		for k, v := range m.GetHeadersFromMetadataEntry() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.HeadersFromMetadataEntry[k] = h.Clone().(*ApiKeyAuth_MetadataEntry)
			} else {
				target.HeadersFromMetadataEntry[k] = proto.Clone(v).(*ApiKeyAuth_MetadataEntry)
			}

		}
	}

	target.SkipMetadataValidation = m.GetSkipMetadataValidation()

	switch m.StorageBackend.(type) {

	case *ApiKeyAuth_K8SSecretApikeyStorage:

		if h, ok := interface{}(m.GetK8SSecretApikeyStorage()).(clone.Cloner); ok {
			target.StorageBackend = &ApiKeyAuth_K8SSecretApikeyStorage{
				K8SSecretApikeyStorage: h.Clone().(*K8SSecretApiKeyStorage),
			}
		} else {
			target.StorageBackend = &ApiKeyAuth_K8SSecretApikeyStorage{
				K8SSecretApikeyStorage: proto.Clone(m.GetK8SSecretApikeyStorage()).(*K8SSecretApiKeyStorage),
			}
		}

	case *ApiKeyAuth_AerospikeApikeyStorage:

		if h, ok := interface{}(m.GetAerospikeApikeyStorage()).(clone.Cloner); ok {
			target.StorageBackend = &ApiKeyAuth_AerospikeApikeyStorage{
				AerospikeApikeyStorage: h.Clone().(*AerospikeApiKeyStorage),
			}
		} else {
			target.StorageBackend = &ApiKeyAuth_AerospikeApikeyStorage{
				AerospikeApikeyStorage: proto.Clone(m.GetAerospikeApikeyStorage()).(*AerospikeApiKeyStorage),
			}
		}

	}

	return target
}

// Clone function
func (m *K8SSecretApiKeyStorage) Clone() proto.Message {
	var target *K8SSecretApiKeyStorage
	if m == nil {
		return target
	}
	target = &K8SSecretApiKeyStorage{}

	if m.GetLabelSelector() != nil {
		target.LabelSelector = make(map[string]string, len(m.GetLabelSelector()))
		for k, v := range m.GetLabelSelector() {

			target.LabelSelector[k] = v

		}
	}

	if m.GetApiKeySecretRefs() != nil {
		target.ApiKeySecretRefs = make([]*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef, len(m.GetApiKeySecretRefs()))
		for idx, v := range m.GetApiKeySecretRefs() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ApiKeySecretRefs[idx] = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
			} else {
				target.ApiKeySecretRefs[idx] = proto.Clone(v).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
			}

		}
	}

	return target
}

// Clone function
func (m *AerospikeApiKeyStorage) Clone() proto.Message {
	var target *AerospikeApiKeyStorage
	if m == nil {
		return target
	}
	target = &AerospikeApiKeyStorage{}

	target.Hostname = m.GetHostname()

	target.Namespace = m.GetNamespace()

	target.Set = m.GetSet()

	target.Port = m.GetPort()

	target.BatchSize = m.GetBatchSize()

	if h, ok := interface{}(m.GetReadModeSc()).(clone.Cloner); ok {
		target.ReadModeSc = h.Clone().(*AerospikeApiKeyStorageReadModeSc)
	} else {
		target.ReadModeSc = proto.Clone(m.GetReadModeSc()).(*AerospikeApiKeyStorageReadModeSc)
	}

	if h, ok := interface{}(m.GetReadModeAp()).(clone.Cloner); ok {
		target.ReadModeAp = h.Clone().(*AerospikeApiKeyStorageReadModeAp)
	} else {
		target.ReadModeAp = proto.Clone(m.GetReadModeAp()).(*AerospikeApiKeyStorageReadModeAp)
	}

	target.NodeTlsName = m.GetNodeTlsName()

	target.CertPath = m.GetCertPath()

	target.KeyPath = m.GetKeyPath()

	target.AllowInsecure = m.GetAllowInsecure()

	target.RootCaPath = m.GetRootCaPath()

	target.TlsVersion = m.GetTlsVersion()

	if m.GetTlsCurveGroups() != nil {
		target.TlsCurveGroups = make([]*AerospikeApiKeyStorageTlsCurveID, len(m.GetTlsCurveGroups()))
		for idx, v := range m.GetTlsCurveGroups() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.TlsCurveGroups[idx] = h.Clone().(*AerospikeApiKeyStorageTlsCurveID)
			} else {
				target.TlsCurveGroups[idx] = proto.Clone(v).(*AerospikeApiKeyStorageTlsCurveID)
			}

		}
	}

	if m.GetLabelSelector() != nil {
		target.LabelSelector = make(map[string]string, len(m.GetLabelSelector()))
		for k, v := range m.GetLabelSelector() {

			target.LabelSelector[k] = v

		}
	}

	switch m.CommitLevel.(type) {

	case *AerospikeApiKeyStorage_CommitAll:

		target.CommitLevel = &AerospikeApiKeyStorage_CommitAll{
			CommitAll: m.GetCommitAll(),
		}

	case *AerospikeApiKeyStorage_CommitMaster:

		target.CommitLevel = &AerospikeApiKeyStorage_CommitMaster{
			CommitMaster: m.GetCommitMaster(),
		}

	}

	return target
}

// Clone function
func (m *ApiKey) Clone() proto.Message {
	var target *ApiKey
	if m == nil {
		return target
	}
	target = &ApiKey{}

	target.ApiKey = m.GetApiKey()

	if m.GetLabels() != nil {
		target.Labels = make([]string, len(m.GetLabels()))
		for idx, v := range m.GetLabels() {

			target.Labels[idx] = v

		}
	}

	if m.GetMetadata() != nil {
		target.Metadata = make(map[string]string, len(m.GetMetadata()))
		for k, v := range m.GetMetadata() {

			target.Metadata[k] = v

		}
	}

	target.Uuid = m.GetUuid()

	return target
}

// Clone function
func (m *ApiKeySecret) Clone() proto.Message {
	var target *ApiKeySecret
	if m == nil {
		return target
	}
	target = &ApiKeySecret{}

	target.ApiKey = m.GetApiKey()

	if m.GetLabels() != nil {
		target.Labels = make([]string, len(m.GetLabels()))
		for idx, v := range m.GetLabels() {

			target.Labels[idx] = v

		}
	}

	if m.GetMetadata() != nil {
		target.Metadata = make(map[string]string, len(m.GetMetadata()))
		for k, v := range m.GetMetadata() {

			target.Metadata[k] = v

		}
	}

	return target
}

// Clone function
func (m *OpaAuth) Clone() proto.Message {
	var target *OpaAuth
	if m == nil {
		return target
	}
	target = &OpaAuth{}

	if m.GetModules() != nil {
		target.Modules = make([]*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef, len(m.GetModules()))
		for idx, v := range m.GetModules() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Modules[idx] = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
			} else {
				target.Modules[idx] = proto.Clone(v).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
			}

		}
	}

	target.Query = m.GetQuery()

	if h, ok := interface{}(m.GetOptions()).(clone.Cloner); ok {
		target.Options = h.Clone().(*OpaAuthOptions)
	} else {
		target.Options = proto.Clone(m.GetOptions()).(*OpaAuthOptions)
	}

	return target
}

// Clone function
func (m *OpaAuthOptions) Clone() proto.Message {
	var target *OpaAuthOptions
	if m == nil {
		return target
	}
	target = &OpaAuthOptions{}

	target.FastInputConversion = m.GetFastInputConversion()

	target.ReturnDecisionReason = m.GetReturnDecisionReason()

	return target
}

// Clone function
func (m *OpaServerAuth) Clone() proto.Message {
	var target *OpaServerAuth
	if m == nil {
		return target
	}
	target = &OpaServerAuth{}

	target.Package = m.GetPackage()

	target.RuleName = m.GetRuleName()

	target.ServerAddr = m.GetServerAddr()

	if h, ok := interface{}(m.GetOptions()).(clone.Cloner); ok {
		target.Options = h.Clone().(*OpaAuthOptions)
	} else {
		target.Options = proto.Clone(m.GetOptions()).(*OpaAuthOptions)
	}

	return target
}

// Clone function
func (m *Ldap) Clone() proto.Message {
	var target *Ldap
	if m == nil {
		return target
	}
	target = &Ldap{}

	target.Address = m.GetAddress()

	target.UserDnTemplate = m.GetUserDnTemplate()

	target.MembershipAttributeName = m.GetMembershipAttributeName()

	if m.GetAllowedGroups() != nil {
		target.AllowedGroups = make([]string, len(m.GetAllowedGroups()))
		for idx, v := range m.GetAllowedGroups() {

			target.AllowedGroups[idx] = v

		}
	}

	if h, ok := interface{}(m.GetPool()).(clone.Cloner); ok {
		target.Pool = h.Clone().(*Ldap_ConnectionPool)
	} else {
		target.Pool = proto.Clone(m.GetPool()).(*Ldap_ConnectionPool)
	}

	target.SearchFilter = m.GetSearchFilter()

	target.DisableGroupChecking = m.GetDisableGroupChecking()

	if h, ok := interface{}(m.GetGroupLookupSettings()).(clone.Cloner); ok {
		target.GroupLookupSettings = h.Clone().(*LdapServiceAccount)
	} else {
		target.GroupLookupSettings = proto.Clone(m.GetGroupLookupSettings()).(*LdapServiceAccount)
	}

	return target
}

// Clone function
func (m *LdapServiceAccount) Clone() proto.Message {
	var target *LdapServiceAccount
	if m == nil {
		return target
	}
	target = &LdapServiceAccount{}

	if h, ok := interface{}(m.GetCredentialsSecretRef()).(clone.Cloner); ok {
		target.CredentialsSecretRef = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	} else {
		target.CredentialsSecretRef = proto.Clone(m.GetCredentialsSecretRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	}

	target.CheckGroupsWithServiceAccount = m.GetCheckGroupsWithServiceAccount()

	return target
}

// Clone function
func (m *PassThroughAuth) Clone() proto.Message {
	var target *PassThroughAuth
	if m == nil {
		return target
	}
	target = &PassThroughAuth{}

	if h, ok := interface{}(m.GetConfig()).(clone.Cloner); ok {
		target.Config = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
	} else {
		target.Config = proto.Clone(m.GetConfig()).(*github_com_golang_protobuf_ptypes_struct.Struct)
	}

	target.FailureModeAllow = m.GetFailureModeAllow()

	switch m.Protocol.(type) {

	case *PassThroughAuth_Grpc:

		if h, ok := interface{}(m.GetGrpc()).(clone.Cloner); ok {
			target.Protocol = &PassThroughAuth_Grpc{
				Grpc: h.Clone().(*PassThroughGrpc),
			}
		} else {
			target.Protocol = &PassThroughAuth_Grpc{
				Grpc: proto.Clone(m.GetGrpc()).(*PassThroughGrpc),
			}
		}

	case *PassThroughAuth_Http:

		if h, ok := interface{}(m.GetHttp()).(clone.Cloner); ok {
			target.Protocol = &PassThroughAuth_Http{
				Http: h.Clone().(*PassThroughHttp),
			}
		} else {
			target.Protocol = &PassThroughAuth_Http{
				Http: proto.Clone(m.GetHttp()).(*PassThroughHttp),
			}
		}

	}

	return target
}

// Clone function
func (m *BackoffStrategy) Clone() proto.Message {
	var target *BackoffStrategy
	if m == nil {
		return target
	}
	target = &BackoffStrategy{}

	if h, ok := interface{}(m.GetBaseInterval()).(clone.Cloner); ok {
		target.BaseInterval = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.BaseInterval = proto.Clone(m.GetBaseInterval()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	if h, ok := interface{}(m.GetMaxInterval()).(clone.Cloner); ok {
		target.MaxInterval = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.MaxInterval = proto.Clone(m.GetMaxInterval()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	return target
}

// Clone function
func (m *RetryPolicy) Clone() proto.Message {
	var target *RetryPolicy
	if m == nil {
		return target
	}
	target = &RetryPolicy{}

	if h, ok := interface{}(m.GetNumRetries()).(clone.Cloner); ok {
		target.NumRetries = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	} else {
		target.NumRetries = proto.Clone(m.GetNumRetries()).(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	}

	switch m.Strategy.(type) {

	case *RetryPolicy_RetryBackOff:

		if h, ok := interface{}(m.GetRetryBackOff()).(clone.Cloner); ok {
			target.Strategy = &RetryPolicy_RetryBackOff{
				RetryBackOff: h.Clone().(*BackoffStrategy),
			}
		} else {
			target.Strategy = &RetryPolicy_RetryBackOff{
				RetryBackOff: proto.Clone(m.GetRetryBackOff()).(*BackoffStrategy),
			}
		}

	}

	return target
}

// Clone function
func (m *PassThroughGrpc) Clone() proto.Message {
	var target *PassThroughGrpc
	if m == nil {
		return target
	}
	target = &PassThroughGrpc{}

	target.Address = m.GetAddress()

	if h, ok := interface{}(m.GetConnectionTimeout()).(clone.Cloner); ok {
		target.ConnectionTimeout = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.ConnectionTimeout = proto.Clone(m.GetConnectionTimeout()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	if h, ok := interface{}(m.GetTlsConfig()).(clone.Cloner); ok {
		target.TlsConfig = h.Clone().(*PassThroughGrpcTLSConfig)
	} else {
		target.TlsConfig = proto.Clone(m.GetTlsConfig()).(*PassThroughGrpcTLSConfig)
	}

	if h, ok := interface{}(m.GetRetryPolicy()).(clone.Cloner); ok {
		target.RetryPolicy = h.Clone().(*RetryPolicy)
	} else {
		target.RetryPolicy = proto.Clone(m.GetRetryPolicy()).(*RetryPolicy)
	}

	return target
}

// Clone function
func (m *PassThroughGrpcTLSConfig) Clone() proto.Message {
	var target *PassThroughGrpcTLSConfig
	if m == nil {
		return target
	}
	target = &PassThroughGrpcTLSConfig{}

	return target
}

// Clone function
func (m *PassThroughHttp) Clone() proto.Message {
	var target *PassThroughHttp
	if m == nil {
		return target
	}
	target = &PassThroughHttp{}

	target.Url = m.GetUrl()

	if h, ok := interface{}(m.GetRequest()).(clone.Cloner); ok {
		target.Request = h.Clone().(*PassThroughHttp_Request)
	} else {
		target.Request = proto.Clone(m.GetRequest()).(*PassThroughHttp_Request)
	}

	if h, ok := interface{}(m.GetResponse()).(clone.Cloner); ok {
		target.Response = h.Clone().(*PassThroughHttp_Response)
	} else {
		target.Response = proto.Clone(m.GetResponse()).(*PassThroughHttp_Response)
	}

	if h, ok := interface{}(m.GetConnectionTimeout()).(clone.Cloner); ok {
		target.ConnectionTimeout = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.ConnectionTimeout = proto.Clone(m.GetConnectionTimeout()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	return target
}

// Clone function
func (m *ExtAuthConfig) Clone() proto.Message {
	var target *ExtAuthConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig{}

	target.AuthConfigRefName = m.GetAuthConfigRefName()

	if m.GetConfigs() != nil {
		target.Configs = make([]*ExtAuthConfig_Config, len(m.GetConfigs()))
		for idx, v := range m.GetConfigs() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Configs[idx] = h.Clone().(*ExtAuthConfig_Config)
			} else {
				target.Configs[idx] = proto.Clone(v).(*ExtAuthConfig_Config)
			}

		}
	}

	if h, ok := interface{}(m.GetBooleanExpr()).(clone.Cloner); ok {
		target.BooleanExpr = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	} else {
		target.BooleanExpr = proto.Clone(m.GetBooleanExpr()).(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	}

	target.FailOnRedirect = m.GetFailOnRedirect()

	return target
}

// Clone function
func (m *ApiKeyCreateRequest) Clone() proto.Message {
	var target *ApiKeyCreateRequest
	if m == nil {
		return target
	}
	target = &ApiKeyCreateRequest{}

	if m.GetApiKeys() != nil {
		target.ApiKeys = make([]*ApiKey, len(m.GetApiKeys()))
		for idx, v := range m.GetApiKeys() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ApiKeys[idx] = h.Clone().(*ApiKey)
			} else {
				target.ApiKeys[idx] = proto.Clone(v).(*ApiKey)
			}

		}
	}

	if m.GetRawApiKeys() != nil {
		target.RawApiKeys = make([]string, len(m.GetRawApiKeys()))
		for idx, v := range m.GetRawApiKeys() {

			target.RawApiKeys[idx] = v

		}
	}

	return target
}

// Clone function
func (m *ApiKeyCreateResponse) Clone() proto.Message {
	var target *ApiKeyCreateResponse
	if m == nil {
		return target
	}
	target = &ApiKeyCreateResponse{}

	if m.GetApiKeys() != nil {
		target.ApiKeys = make([]*ApiKey, len(m.GetApiKeys()))
		for idx, v := range m.GetApiKeys() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ApiKeys[idx] = h.Clone().(*ApiKey)
			} else {
				target.ApiKeys[idx] = proto.Clone(v).(*ApiKey)
			}

		}
	}

	return target
}

// Clone function
func (m *ApiKeyReadRequest) Clone() proto.Message {
	var target *ApiKeyReadRequest
	if m == nil {
		return target
	}
	target = &ApiKeyReadRequest{}

	if m.GetRawApiKeys() != nil {
		target.RawApiKeys = make([]string, len(m.GetRawApiKeys()))
		for idx, v := range m.GetRawApiKeys() {

			target.RawApiKeys[idx] = v

		}
	}

	if m.GetLabels() != nil {
		target.Labels = make([]string, len(m.GetLabels()))
		for idx, v := range m.GetLabels() {

			target.Labels[idx] = v

		}
	}

	return target
}

// Clone function
func (m *ApiKeyReadResponse) Clone() proto.Message {
	var target *ApiKeyReadResponse
	if m == nil {
		return target
	}
	target = &ApiKeyReadResponse{}

	if m.GetApiKeys() != nil {
		target.ApiKeys = make([]*ApiKey, len(m.GetApiKeys()))
		for idx, v := range m.GetApiKeys() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ApiKeys[idx] = h.Clone().(*ApiKey)
			} else {
				target.ApiKeys[idx] = proto.Clone(v).(*ApiKey)
			}

		}
	}

	return target
}

// Clone function
func (m *ApiKeyUpdateRequest) Clone() proto.Message {
	var target *ApiKeyUpdateRequest
	if m == nil {
		return target
	}
	target = &ApiKeyUpdateRequest{}

	target.Upsert = m.GetUpsert()

	if m.GetApiKeys() != nil {
		target.ApiKeys = make([]*ApiKey, len(m.GetApiKeys()))
		for idx, v := range m.GetApiKeys() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ApiKeys[idx] = h.Clone().(*ApiKey)
			} else {
				target.ApiKeys[idx] = proto.Clone(v).(*ApiKey)
			}

		}
	}

	if m.GetRawApiKeys() != nil {
		target.RawApiKeys = make([]string, len(m.GetRawApiKeys()))
		for idx, v := range m.GetRawApiKeys() {

			target.RawApiKeys[idx] = v

		}
	}

	return target
}

// Clone function
func (m *ApiKeyUpdateResponse) Clone() proto.Message {
	var target *ApiKeyUpdateResponse
	if m == nil {
		return target
	}
	target = &ApiKeyUpdateResponse{}

	if m.GetApiKeys() != nil {
		target.ApiKeys = make([]*ApiKey, len(m.GetApiKeys()))
		for idx, v := range m.GetApiKeys() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ApiKeys[idx] = h.Clone().(*ApiKey)
			} else {
				target.ApiKeys[idx] = proto.Clone(v).(*ApiKey)
			}

		}
	}

	return target
}

// Clone function
func (m *ApiKeyDeleteRequest) Clone() proto.Message {
	var target *ApiKeyDeleteRequest
	if m == nil {
		return target
	}
	target = &ApiKeyDeleteRequest{}

	if m.GetRawApiKeys() != nil {
		target.RawApiKeys = make([]string, len(m.GetRawApiKeys()))
		for idx, v := range m.GetRawApiKeys() {

			target.RawApiKeys[idx] = v

		}
	}

	if m.GetLabels() != nil {
		target.Labels = make([]string, len(m.GetLabels()))
		for idx, v := range m.GetLabels() {

			target.Labels[idx] = v

		}
	}

	return target
}

// Clone function
func (m *ApiKeyDeleteResponse) Clone() proto.Message {
	var target *ApiKeyDeleteResponse
	if m == nil {
		return target
	}
	target = &ApiKeyDeleteResponse{}

	return target
}

// Clone function
func (m *AuthConfigStatus) Clone() proto.Message {
	var target *AuthConfigStatus
	if m == nil {
		return target
	}
	target = &AuthConfigStatus{}

	target.State = m.GetState()

	target.Reason = m.GetReason()

	target.ReportedBy = m.GetReportedBy()

	if m.GetSubresourceStatuses() != nil {
		target.SubresourceStatuses = make(map[string]*AuthConfigStatus, len(m.GetSubresourceStatuses()))
		for k, v := range m.GetSubresourceStatuses() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.SubresourceStatuses[k] = h.Clone().(*AuthConfigStatus)
			} else {
				target.SubresourceStatuses[k] = proto.Clone(v).(*AuthConfigStatus)
			}

		}
	}

	if h, ok := interface{}(m.GetDetails()).(clone.Cloner); ok {
		target.Details = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
	} else {
		target.Details = proto.Clone(m.GetDetails()).(*github_com_golang_protobuf_ptypes_struct.Struct)
	}

	return target
}

// Clone function
func (m *AuthConfigNamespacedStatuses) Clone() proto.Message {
	var target *AuthConfigNamespacedStatuses
	if m == nil {
		return target
	}
	target = &AuthConfigNamespacedStatuses{}

	if m.GetStatuses() != nil {
		target.Statuses = make(map[string]*AuthConfigStatus, len(m.GetStatuses()))
		for k, v := range m.GetStatuses() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Statuses[k] = h.Clone().(*AuthConfigStatus)
			} else {
				target.Statuses[k] = proto.Clone(v).(*AuthConfigStatus)
			}

		}
	}

	return target
}

// Clone function
func (m *AuthConfigSpec_Config) Clone() proto.Message {
	var target *AuthConfigSpec_Config
	if m == nil {
		return target
	}
	target = &AuthConfigSpec_Config{}

	if h, ok := interface{}(m.GetName()).(clone.Cloner); ok {
		target.Name = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	} else {
		target.Name = proto.Clone(m.GetName()).(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	}

	switch m.AuthConfig.(type) {

	case *AuthConfigSpec_Config_BasicAuth:

		if h, ok := interface{}(m.GetBasicAuth()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_BasicAuth{
				BasicAuth: h.Clone().(*BasicAuth),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_BasicAuth{
				BasicAuth: proto.Clone(m.GetBasicAuth()).(*BasicAuth),
			}
		}

	case *AuthConfigSpec_Config_Oauth:

		if h, ok := interface{}(m.GetOauth()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_Oauth{
				Oauth: h.Clone().(*OAuth),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_Oauth{
				Oauth: proto.Clone(m.GetOauth()).(*OAuth),
			}
		}

	case *AuthConfigSpec_Config_Oauth2:

		if h, ok := interface{}(m.GetOauth2()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_Oauth2{
				Oauth2: h.Clone().(*OAuth2),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_Oauth2{
				Oauth2: proto.Clone(m.GetOauth2()).(*OAuth2),
			}
		}

	case *AuthConfigSpec_Config_ApiKeyAuth:

		if h, ok := interface{}(m.GetApiKeyAuth()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_ApiKeyAuth{
				ApiKeyAuth: h.Clone().(*ApiKeyAuth),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_ApiKeyAuth{
				ApiKeyAuth: proto.Clone(m.GetApiKeyAuth()).(*ApiKeyAuth),
			}
		}

	case *AuthConfigSpec_Config_PluginAuth:

		if h, ok := interface{}(m.GetPluginAuth()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_PluginAuth{
				PluginAuth: h.Clone().(*AuthPlugin),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_PluginAuth{
				PluginAuth: proto.Clone(m.GetPluginAuth()).(*AuthPlugin),
			}
		}

	case *AuthConfigSpec_Config_OpaAuth:

		if h, ok := interface{}(m.GetOpaAuth()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_OpaAuth{
				OpaAuth: h.Clone().(*OpaAuth),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_OpaAuth{
				OpaAuth: proto.Clone(m.GetOpaAuth()).(*OpaAuth),
			}
		}

	case *AuthConfigSpec_Config_Ldap:

		if h, ok := interface{}(m.GetLdap()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_Ldap{
				Ldap: h.Clone().(*Ldap),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_Ldap{
				Ldap: proto.Clone(m.GetLdap()).(*Ldap),
			}
		}

	case *AuthConfigSpec_Config_Jwt:

		if h, ok := interface{}(m.GetJwt()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_Jwt{
				Jwt: h.Clone().(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_Jwt{
				Jwt: proto.Clone(m.GetJwt()).(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		}

	case *AuthConfigSpec_Config_PassThroughAuth:

		if h, ok := interface{}(m.GetPassThroughAuth()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_PassThroughAuth{
				PassThroughAuth: h.Clone().(*PassThroughAuth),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_PassThroughAuth{
				PassThroughAuth: proto.Clone(m.GetPassThroughAuth()).(*PassThroughAuth),
			}
		}

	case *AuthConfigSpec_Config_HmacAuth:

		if h, ok := interface{}(m.GetHmacAuth()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_HmacAuth{
				HmacAuth: h.Clone().(*HmacAuth),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_HmacAuth{
				HmacAuth: proto.Clone(m.GetHmacAuth()).(*HmacAuth),
			}
		}

	case *AuthConfigSpec_Config_OpaServerAuth:

		if h, ok := interface{}(m.GetOpaServerAuth()).(clone.Cloner); ok {
			target.AuthConfig = &AuthConfigSpec_Config_OpaServerAuth{
				OpaServerAuth: h.Clone().(*OpaServerAuth),
			}
		} else {
			target.AuthConfig = &AuthConfigSpec_Config_OpaServerAuth{
				OpaServerAuth: proto.Clone(m.GetOpaServerAuth()).(*OpaServerAuth),
			}
		}

	}

	return target
}

// Clone function
func (m *HttpService_Request) Clone() proto.Message {
	var target *HttpService_Request
	if m == nil {
		return target
	}
	target = &HttpService_Request{}

	if m.GetAllowedHeaders() != nil {
		target.AllowedHeaders = make([]string, len(m.GetAllowedHeaders()))
		for idx, v := range m.GetAllowedHeaders() {

			target.AllowedHeaders[idx] = v

		}
	}

	if m.GetHeadersToAdd() != nil {
		target.HeadersToAdd = make(map[string]string, len(m.GetHeadersToAdd()))
		for k, v := range m.GetHeadersToAdd() {

			target.HeadersToAdd[k] = v

		}
	}

	if m.GetAllowedHeadersRegex() != nil {
		target.AllowedHeadersRegex = make([]string, len(m.GetAllowedHeadersRegex()))
		for idx, v := range m.GetAllowedHeadersRegex() {

			target.AllowedHeadersRegex[idx] = v

		}
	}

	return target
}

// Clone function
func (m *HttpService_Response) Clone() proto.Message {
	var target *HttpService_Response
	if m == nil {
		return target
	}
	target = &HttpService_Response{}

	if m.GetAllowedUpstreamHeaders() != nil {
		target.AllowedUpstreamHeaders = make([]string, len(m.GetAllowedUpstreamHeaders()))
		for idx, v := range m.GetAllowedUpstreamHeaders() {

			target.AllowedUpstreamHeaders[idx] = v

		}
	}

	if m.GetAllowedClientHeaders() != nil {
		target.AllowedClientHeaders = make([]string, len(m.GetAllowedClientHeaders()))
		for idx, v := range m.GetAllowedClientHeaders() {

			target.AllowedClientHeaders[idx] = v

		}
	}

	if m.GetAllowedUpstreamHeadersToAppend() != nil {
		target.AllowedUpstreamHeadersToAppend = make([]string, len(m.GetAllowedUpstreamHeadersToAppend()))
		for idx, v := range m.GetAllowedUpstreamHeadersToAppend() {

			target.AllowedUpstreamHeadersToAppend[idx] = v

		}
	}

	return target
}

// Clone function
func (m *BasicAuth_Apr) Clone() proto.Message {
	var target *BasicAuth_Apr
	if m == nil {
		return target
	}
	target = &BasicAuth_Apr{}

	if m.GetUsers() != nil {
		target.Users = make(map[string]*BasicAuth_Apr_SaltedHashedPassword, len(m.GetUsers()))
		for k, v := range m.GetUsers() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Users[k] = h.Clone().(*BasicAuth_Apr_SaltedHashedPassword)
			} else {
				target.Users[k] = proto.Clone(v).(*BasicAuth_Apr_SaltedHashedPassword)
			}

		}
	}

	return target
}

// Clone function
func (m *BasicAuth_EncryptionType) Clone() proto.Message {
	var target *BasicAuth_EncryptionType
	if m == nil {
		return target
	}
	target = &BasicAuth_EncryptionType{}

	switch m.Algorithm.(type) {

	case *BasicAuth_EncryptionType_Apr_:

		if h, ok := interface{}(m.GetApr()).(clone.Cloner); ok {
			target.Algorithm = &BasicAuth_EncryptionType_Apr_{
				Apr: h.Clone().(*BasicAuth_EncryptionType_Apr),
			}
		} else {
			target.Algorithm = &BasicAuth_EncryptionType_Apr_{
				Apr: proto.Clone(m.GetApr()).(*BasicAuth_EncryptionType_Apr),
			}
		}

	case *BasicAuth_EncryptionType_Sha1_:

		if h, ok := interface{}(m.GetSha1()).(clone.Cloner); ok {
			target.Algorithm = &BasicAuth_EncryptionType_Sha1_{
				Sha1: h.Clone().(*BasicAuth_EncryptionType_Sha1),
			}
		} else {
			target.Algorithm = &BasicAuth_EncryptionType_Sha1_{
				Sha1: proto.Clone(m.GetSha1()).(*BasicAuth_EncryptionType_Sha1),
			}
		}

	}

	return target
}

// Clone function
func (m *BasicAuth_User) Clone() proto.Message {
	var target *BasicAuth_User
	if m == nil {
		return target
	}
	target = &BasicAuth_User{}

	target.Salt = m.GetSalt()

	target.HashedPassword = m.GetHashedPassword()

	return target
}

// Clone function
func (m *BasicAuth_UserList) Clone() proto.Message {
	var target *BasicAuth_UserList
	if m == nil {
		return target
	}
	target = &BasicAuth_UserList{}

	if m.GetUsers() != nil {
		target.Users = make(map[string]*BasicAuth_User, len(m.GetUsers()))
		for k, v := range m.GetUsers() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Users[k] = h.Clone().(*BasicAuth_User)
			} else {
				target.Users[k] = proto.Clone(v).(*BasicAuth_User)
			}

		}
	}

	return target
}

// Clone function
func (m *BasicAuth_Apr_SaltedHashedPassword) Clone() proto.Message {
	var target *BasicAuth_Apr_SaltedHashedPassword
	if m == nil {
		return target
	}
	target = &BasicAuth_Apr_SaltedHashedPassword{}

	target.Salt = m.GetSalt()

	target.HashedPassword = m.GetHashedPassword()

	return target
}

// Clone function
func (m *BasicAuth_EncryptionType_Sha1) Clone() proto.Message {
	var target *BasicAuth_EncryptionType_Sha1
	if m == nil {
		return target
	}
	target = &BasicAuth_EncryptionType_Sha1{}

	return target
}

// Clone function
func (m *BasicAuth_EncryptionType_Apr) Clone() proto.Message {
	var target *BasicAuth_EncryptionType_Apr
	if m == nil {
		return target
	}
	target = &BasicAuth_EncryptionType_Apr{}

	return target
}

// Clone function
func (m *UserSession_InternalSession) Clone() proto.Message {
	var target *UserSession_InternalSession
	if m == nil {
		return target
	}
	target = &UserSession_InternalSession{}

	if h, ok := interface{}(m.GetAllowRefreshing()).(clone.Cloner); ok {
		target.AllowRefreshing = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.AllowRefreshing = proto.Clone(m.GetAllowRefreshing()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	target.KeyPrefix = m.GetKeyPrefix()

	target.TargetDomain = m.GetTargetDomain()

	return target
}

// Clone function
func (m *UserSession_RedisSession) Clone() proto.Message {
	var target *UserSession_RedisSession
	if m == nil {
		return target
	}
	target = &UserSession_RedisSession{}

	if h, ok := interface{}(m.GetOptions()).(clone.Cloner); ok {
		target.Options = h.Clone().(*RedisOptions)
	} else {
		target.Options = proto.Clone(m.GetOptions()).(*RedisOptions)
	}

	target.KeyPrefix = m.GetKeyPrefix()

	target.CookieName = m.GetCookieName()

	if h, ok := interface{}(m.GetAllowRefreshing()).(clone.Cloner); ok {
		target.AllowRefreshing = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.AllowRefreshing = proto.Clone(m.GetAllowRefreshing()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	if h, ok := interface{}(m.GetPreExpiryBuffer()).(clone.Cloner); ok {
		target.PreExpiryBuffer = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.PreExpiryBuffer = proto.Clone(m.GetPreExpiryBuffer()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	target.TargetDomain = m.GetTargetDomain()

	target.HeaderName = m.GetHeaderName()

	return target
}

// Clone function
func (m *UserSession_CookieOptions) Clone() proto.Message {
	var target *UserSession_CookieOptions
	if m == nil {
		return target
	}
	target = &UserSession_CookieOptions{}

	if h, ok := interface{}(m.GetMaxAge()).(clone.Cloner); ok {
		target.MaxAge = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	} else {
		target.MaxAge = proto.Clone(m.GetMaxAge()).(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	}

	target.NotSecure = m.GetNotSecure()

	if h, ok := interface{}(m.GetHttpOnly()).(clone.Cloner); ok {
		target.HttpOnly = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.HttpOnly = proto.Clone(m.GetHttpOnly()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	if h, ok := interface{}(m.GetPath()).(clone.Cloner); ok {
		target.Path = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	} else {
		target.Path = proto.Clone(m.GetPath()).(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	}

	target.SameSite = m.GetSameSite()

	target.Domain = m.GetDomain()

	return target
}

// Clone function
func (m *UserSession_CipherConfig) Clone() proto.Message {
	var target *UserSession_CipherConfig
	if m == nil {
		return target
	}
	target = &UserSession_CipherConfig{}

	switch m.Key.(type) {

	case *UserSession_CipherConfig_KeyRef:

		if h, ok := interface{}(m.GetKeyRef()).(clone.Cloner); ok {
			target.Key = &UserSession_CipherConfig_KeyRef{
				KeyRef: h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef),
			}
		} else {
			target.Key = &UserSession_CipherConfig_KeyRef{
				KeyRef: proto.Clone(m.GetKeyRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef),
			}
		}

	}

	return target
}

// Clone function
func (m *OidcAuthorizationCode_AccessToken) Clone() proto.Message {
	var target *OidcAuthorizationCode_AccessToken
	if m == nil {
		return target
	}
	target = &OidcAuthorizationCode_AccessToken{}

	if m.GetClaimsToHeaders() != nil {
		target.ClaimsToHeaders = make([]*ClaimToHeader, len(m.GetClaimsToHeaders()))
		for idx, v := range m.GetClaimsToHeaders() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ClaimsToHeaders[idx] = h.Clone().(*ClaimToHeader)
			} else {
				target.ClaimsToHeaders[idx] = proto.Clone(v).(*ClaimToHeader)
			}

		}
	}

	return target
}

// Clone function
func (m *OidcAuthorizationCode_IdentityToken) Clone() proto.Message {
	var target *OidcAuthorizationCode_IdentityToken
	if m == nil {
		return target
	}
	target = &OidcAuthorizationCode_IdentityToken{}

	if m.GetClaimsToHeaders() != nil {
		target.ClaimsToHeaders = make([]*ClaimToHeader, len(m.GetClaimsToHeaders()))
		for idx, v := range m.GetClaimsToHeaders() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ClaimsToHeaders[idx] = h.Clone().(*ClaimToHeader)
			} else {
				target.ClaimsToHeaders[idx] = proto.Clone(v).(*ClaimToHeader)
			}

		}
	}

	return target
}

// Clone function
func (m *OidcAuthorizationCode_ClientAuthentication) Clone() proto.Message {
	var target *OidcAuthorizationCode_ClientAuthentication
	if m == nil {
		return target
	}
	target = &OidcAuthorizationCode_ClientAuthentication{}

	switch m.ClientAuthenticationConfig.(type) {

	case *OidcAuthorizationCode_ClientAuthentication_ClientSecret_:

		if h, ok := interface{}(m.GetClientSecret()).(clone.Cloner); ok {
			target.ClientAuthenticationConfig = &OidcAuthorizationCode_ClientAuthentication_ClientSecret_{
				ClientSecret: h.Clone().(*OidcAuthorizationCode_ClientAuthentication_ClientSecret),
			}
		} else {
			target.ClientAuthenticationConfig = &OidcAuthorizationCode_ClientAuthentication_ClientSecret_{
				ClientSecret: proto.Clone(m.GetClientSecret()).(*OidcAuthorizationCode_ClientAuthentication_ClientSecret),
			}
		}

	case *OidcAuthorizationCode_ClientAuthentication_PrivateKeyJwt_:

		if h, ok := interface{}(m.GetPrivateKeyJwt()).(clone.Cloner); ok {
			target.ClientAuthenticationConfig = &OidcAuthorizationCode_ClientAuthentication_PrivateKeyJwt_{
				PrivateKeyJwt: h.Clone().(*OidcAuthorizationCode_ClientAuthentication_PrivateKeyJwt),
			}
		} else {
			target.ClientAuthenticationConfig = &OidcAuthorizationCode_ClientAuthentication_PrivateKeyJwt_{
				PrivateKeyJwt: proto.Clone(m.GetPrivateKeyJwt()).(*OidcAuthorizationCode_ClientAuthentication_PrivateKeyJwt),
			}
		}

	}

	return target
}

// Clone function
func (m *OidcAuthorizationCode_Default) Clone() proto.Message {
	var target *OidcAuthorizationCode_Default
	if m == nil {
		return target
	}
	target = &OidcAuthorizationCode_Default{}

	return target
}

// Clone function
func (m *OidcAuthorizationCode_FrontChannelLogout) Clone() proto.Message {
	var target *OidcAuthorizationCode_FrontChannelLogout
	if m == nil {
		return target
	}
	target = &OidcAuthorizationCode_FrontChannelLogout{}

	target.Path = m.GetPath()

	return target
}

// Clone function
func (m *OidcAuthorizationCode_ClientAuthentication_ClientSecret) Clone() proto.Message {
	var target *OidcAuthorizationCode_ClientAuthentication_ClientSecret
	if m == nil {
		return target
	}
	target = &OidcAuthorizationCode_ClientAuthentication_ClientSecret{}

	if h, ok := interface{}(m.GetClientSecretRef()).(clone.Cloner); ok {
		target.ClientSecretRef = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	} else {
		target.ClientSecretRef = proto.Clone(m.GetClientSecretRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	}

	if h, ok := interface{}(m.GetDisableClientSecret()).(clone.Cloner); ok {
		target.DisableClientSecret = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	} else {
		target.DisableClientSecret = proto.Clone(m.GetDisableClientSecret()).(*github_com_golang_protobuf_ptypes_wrappers.BoolValue)
	}

	return target
}

// Clone function
func (m *OidcAuthorizationCode_ClientAuthentication_PrivateKeyJwt) Clone() proto.Message {
	var target *OidcAuthorizationCode_ClientAuthentication_PrivateKeyJwt
	if m == nil {
		return target
	}
	target = &OidcAuthorizationCode_ClientAuthentication_PrivateKeyJwt{}

	if h, ok := interface{}(m.GetSigningKeyRef()).(clone.Cloner); ok {
		target.SigningKeyRef = h.Clone().(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	} else {
		target.SigningKeyRef = proto.Clone(m.GetSigningKeyRef()).(*github_com_solo_io_solo_kit_pkg_api_v1_resources_core.ResourceRef)
	}

	if h, ok := interface{}(m.GetValidFor()).(clone.Cloner); ok {
		target.ValidFor = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.ValidFor = proto.Clone(m.GetValidFor()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	return target
}

// Clone function
func (m *JwtValidation_RemoteJwks) Clone() proto.Message {
	var target *JwtValidation_RemoteJwks
	if m == nil {
		return target
	}
	target = &JwtValidation_RemoteJwks{}

	target.Url = m.GetUrl()

	if h, ok := interface{}(m.GetRefreshInterval()).(clone.Cloner); ok {
		target.RefreshInterval = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.RefreshInterval = proto.Clone(m.GetRefreshInterval()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	return target
}

// Clone function
func (m *JwtValidation_LocalJwks) Clone() proto.Message {
	var target *JwtValidation_LocalJwks
	if m == nil {
		return target
	}
	target = &JwtValidation_LocalJwks{}

	target.InlineString = m.GetInlineString()

	return target
}

// Clone function
func (m *AccessTokenValidation_ScopeList) Clone() proto.Message {
	var target *AccessTokenValidation_ScopeList
	if m == nil {
		return target
	}
	target = &AccessTokenValidation_ScopeList{}

	if m.GetScope() != nil {
		target.Scope = make([]string, len(m.GetScope()))
		for idx, v := range m.GetScope() {

			target.Scope[idx] = v

		}
	}

	return target
}

// Clone function
func (m *ApiKeyAuth_SecretKey) Clone() proto.Message {
	var target *ApiKeyAuth_SecretKey
	if m == nil {
		return target
	}
	target = &ApiKeyAuth_SecretKey{}

	target.Name = m.GetName()

	target.Required = m.GetRequired()

	return target
}

// Clone function
func (m *ApiKeyAuth_MetadataEntry) Clone() proto.Message {
	var target *ApiKeyAuth_MetadataEntry
	if m == nil {
		return target
	}
	target = &ApiKeyAuth_MetadataEntry{}

	target.Name = m.GetName()

	target.Required = m.GetRequired()

	return target
}

// Clone function
func (m *AerospikeApiKeyStorageReadModeSc) Clone() proto.Message {
	var target *AerospikeApiKeyStorageReadModeSc
	if m == nil {
		return target
	}
	target = &AerospikeApiKeyStorageReadModeSc{}

	switch m.ReadModeSc.(type) {

	case *AerospikeApiKeyStorageReadModeSc_ReadModeScSession:

		target.ReadModeSc = &AerospikeApiKeyStorageReadModeSc_ReadModeScSession{
			ReadModeScSession: m.GetReadModeScSession(),
		}

	case *AerospikeApiKeyStorageReadModeSc_ReadModeScLinearize:

		target.ReadModeSc = &AerospikeApiKeyStorageReadModeSc_ReadModeScLinearize{
			ReadModeScLinearize: m.GetReadModeScLinearize(),
		}

	case *AerospikeApiKeyStorageReadModeSc_ReadModeScReplica:

		target.ReadModeSc = &AerospikeApiKeyStorageReadModeSc_ReadModeScReplica{
			ReadModeScReplica: m.GetReadModeScReplica(),
		}

	case *AerospikeApiKeyStorageReadModeSc_ReadModeScAllowUnavailable:

		target.ReadModeSc = &AerospikeApiKeyStorageReadModeSc_ReadModeScAllowUnavailable{
			ReadModeScAllowUnavailable: m.GetReadModeScAllowUnavailable(),
		}

	}

	return target
}

// Clone function
func (m *AerospikeApiKeyStorageReadModeAp) Clone() proto.Message {
	var target *AerospikeApiKeyStorageReadModeAp
	if m == nil {
		return target
	}
	target = &AerospikeApiKeyStorageReadModeAp{}

	switch m.ReadModeAp.(type) {

	case *AerospikeApiKeyStorageReadModeAp_ReadModeApOne:

		target.ReadModeAp = &AerospikeApiKeyStorageReadModeAp_ReadModeApOne{
			ReadModeApOne: m.GetReadModeApOne(),
		}

	case *AerospikeApiKeyStorageReadModeAp_ReadModeApAll:

		target.ReadModeAp = &AerospikeApiKeyStorageReadModeAp_ReadModeApAll{
			ReadModeApAll: m.GetReadModeApAll(),
		}

	}

	return target
}

// Clone function
func (m *AerospikeApiKeyStorageTlsCurveID) Clone() proto.Message {
	var target *AerospikeApiKeyStorageTlsCurveID
	if m == nil {
		return target
	}
	target = &AerospikeApiKeyStorageTlsCurveID{}

	switch m.CurveId.(type) {

	case *AerospikeApiKeyStorageTlsCurveID_CurveP256:

		target.CurveId = &AerospikeApiKeyStorageTlsCurveID_CurveP256{
			CurveP256: m.GetCurveP256(),
		}

	case *AerospikeApiKeyStorageTlsCurveID_CurveP384:

		target.CurveId = &AerospikeApiKeyStorageTlsCurveID_CurveP384{
			CurveP384: m.GetCurveP384(),
		}

	case *AerospikeApiKeyStorageTlsCurveID_CurveP521:

		target.CurveId = &AerospikeApiKeyStorageTlsCurveID_CurveP521{
			CurveP521: m.GetCurveP521(),
		}

	case *AerospikeApiKeyStorageTlsCurveID_X_25519:

		target.CurveId = &AerospikeApiKeyStorageTlsCurveID_X_25519{
			X_25519: m.GetX_25519(),
		}

	}

	return target
}

// Clone function
func (m *Ldap_ConnectionPool) Clone() proto.Message {
	var target *Ldap_ConnectionPool
	if m == nil {
		return target
	}
	target = &Ldap_ConnectionPool{}

	if h, ok := interface{}(m.GetMaxSize()).(clone.Cloner); ok {
		target.MaxSize = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	} else {
		target.MaxSize = proto.Clone(m.GetMaxSize()).(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	}

	if h, ok := interface{}(m.GetInitialSize()).(clone.Cloner); ok {
		target.InitialSize = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	} else {
		target.InitialSize = proto.Clone(m.GetInitialSize()).(*github_com_golang_protobuf_ptypes_wrappers.UInt32Value)
	}

	return target
}

// Clone function
func (m *PassThroughHttp_Request) Clone() proto.Message {
	var target *PassThroughHttp_Request
	if m == nil {
		return target
	}
	target = &PassThroughHttp_Request{}

	if m.GetAllowedHeaders() != nil {
		target.AllowedHeaders = make([]string, len(m.GetAllowedHeaders()))
		for idx, v := range m.GetAllowedHeaders() {

			target.AllowedHeaders[idx] = v

		}
	}

	if m.GetHeadersToAdd() != nil {
		target.HeadersToAdd = make(map[string]string, len(m.GetHeadersToAdd()))
		for k, v := range m.GetHeadersToAdd() {

			target.HeadersToAdd[k] = v

		}
	}

	target.PassThroughState = m.GetPassThroughState()

	target.PassThroughFilterMetadata = m.GetPassThroughFilterMetadata()

	target.PassThroughBody = m.GetPassThroughBody()

	return target
}

// Clone function
func (m *PassThroughHttp_Response) Clone() proto.Message {
	var target *PassThroughHttp_Response
	if m == nil {
		return target
	}
	target = &PassThroughHttp_Response{}

	if m.GetAllowedUpstreamHeaders() != nil {
		target.AllowedUpstreamHeaders = make([]string, len(m.GetAllowedUpstreamHeaders()))
		for idx, v := range m.GetAllowedUpstreamHeaders() {

			target.AllowedUpstreamHeaders[idx] = v

		}
	}

	if m.GetAllowedClientHeadersOnDenied() != nil {
		target.AllowedClientHeadersOnDenied = make([]string, len(m.GetAllowedClientHeadersOnDenied()))
		for idx, v := range m.GetAllowedClientHeadersOnDenied() {

			target.AllowedClientHeadersOnDenied[idx] = v

		}
	}

	target.ReadStateFromResponse = m.GetReadStateFromResponse()

	if m.GetAllowedUpstreamHeadersToOverwrite() != nil {
		target.AllowedUpstreamHeadersToOverwrite = make([]string, len(m.GetAllowedUpstreamHeadersToOverwrite()))
		for idx, v := range m.GetAllowedUpstreamHeadersToOverwrite() {

			target.AllowedUpstreamHeadersToOverwrite[idx] = v

		}
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_BasicAuthInternal) Clone() proto.Message {
	var target *ExtAuthConfig_BasicAuthInternal
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_BasicAuthInternal{}

	target.Realm = m.GetRealm()

	if h, ok := interface{}(m.GetEncryption()).(clone.Cloner); ok {
		target.Encryption = h.Clone().(*ExtAuthConfig_BasicAuthInternal_EncryptionType)
	} else {
		target.Encryption = proto.Clone(m.GetEncryption()).(*ExtAuthConfig_BasicAuthInternal_EncryptionType)
	}

	switch m.UserSource.(type) {

	case *ExtAuthConfig_BasicAuthInternal_UserList_:

		if h, ok := interface{}(m.GetUserList()).(clone.Cloner); ok {
			target.UserSource = &ExtAuthConfig_BasicAuthInternal_UserList_{
				UserList: h.Clone().(*ExtAuthConfig_BasicAuthInternal_UserList),
			}
		} else {
			target.UserSource = &ExtAuthConfig_BasicAuthInternal_UserList_{
				UserList: proto.Clone(m.GetUserList()).(*ExtAuthConfig_BasicAuthInternal_UserList),
			}
		}

	}

	return target
}

// Clone function
func (m *ExtAuthConfig_OAuthConfig) Clone() proto.Message {
	var target *ExtAuthConfig_OAuthConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OAuthConfig{}

	target.ClientId = m.GetClientId()

	target.ClientSecret = m.GetClientSecret()

	target.IssuerUrl = m.GetIssuerUrl()

	if m.GetAuthEndpointQueryParams() != nil {
		target.AuthEndpointQueryParams = make(map[string]string, len(m.GetAuthEndpointQueryParams()))
		for k, v := range m.GetAuthEndpointQueryParams() {

			target.AuthEndpointQueryParams[k] = v

		}
	}

	target.AppUrl = m.GetAppUrl()

	target.CallbackPath = m.GetCallbackPath()

	if m.GetScopes() != nil {
		target.Scopes = make([]string, len(m.GetScopes()))
		for idx, v := range m.GetScopes() {

			target.Scopes[idx] = v

		}
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_UserSessionConfig) Clone() proto.Message {
	var target *ExtAuthConfig_UserSessionConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_UserSessionConfig{}

	target.FailOnFetchFailure = m.GetFailOnFetchFailure()

	if h, ok := interface{}(m.GetCookieOptions()).(clone.Cloner); ok {
		target.CookieOptions = h.Clone().(*UserSession_CookieOptions)
	} else {
		target.CookieOptions = proto.Clone(m.GetCookieOptions()).(*UserSession_CookieOptions)
	}

	if h, ok := interface{}(m.GetCipherConfig()).(clone.Cloner); ok {
		target.CipherConfig = h.Clone().(*ExtAuthConfig_UserSessionConfig_CipherConfig)
	} else {
		target.CipherConfig = proto.Clone(m.GetCipherConfig()).(*ExtAuthConfig_UserSessionConfig_CipherConfig)
	}

	switch m.Session.(type) {

	case *ExtAuthConfig_UserSessionConfig_Cookie:

		if h, ok := interface{}(m.GetCookie()).(clone.Cloner); ok {
			target.Session = &ExtAuthConfig_UserSessionConfig_Cookie{
				Cookie: h.Clone().(*UserSession_InternalSession),
			}
		} else {
			target.Session = &ExtAuthConfig_UserSessionConfig_Cookie{
				Cookie: proto.Clone(m.GetCookie()).(*UserSession_InternalSession),
			}
		}

	case *ExtAuthConfig_UserSessionConfig_Redis:

		if h, ok := interface{}(m.GetRedis()).(clone.Cloner); ok {
			target.Session = &ExtAuthConfig_UserSessionConfig_Redis{
				Redis: h.Clone().(*UserSession_RedisSession),
			}
		} else {
			target.Session = &ExtAuthConfig_UserSessionConfig_Redis{
				Redis: proto.Clone(m.GetRedis()).(*UserSession_RedisSession),
			}
		}

	}

	return target
}

// Clone function
func (m *ExtAuthConfig_OidcAuthorizationCodeConfig) Clone() proto.Message {
	var target *ExtAuthConfig_OidcAuthorizationCodeConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OidcAuthorizationCodeConfig{}

	target.ClientId = m.GetClientId()

	target.ClientSecret = m.GetClientSecret()

	target.IssuerUrl = m.GetIssuerUrl()

	if m.GetAuthEndpointQueryParams() != nil {
		target.AuthEndpointQueryParams = make(map[string]string, len(m.GetAuthEndpointQueryParams()))
		for k, v := range m.GetAuthEndpointQueryParams() {

			target.AuthEndpointQueryParams[k] = v

		}
	}

	if m.GetTokenEndpointQueryParams() != nil {
		target.TokenEndpointQueryParams = make(map[string]string, len(m.GetTokenEndpointQueryParams()))
		for k, v := range m.GetTokenEndpointQueryParams() {

			target.TokenEndpointQueryParams[k] = v

		}
	}

	target.AppUrl = m.GetAppUrl()

	target.CallbackPath = m.GetCallbackPath()

	target.LogoutPath = m.GetLogoutPath()

	target.AfterLogoutUrl = m.GetAfterLogoutUrl()

	if m.GetScopes() != nil {
		target.Scopes = make([]string, len(m.GetScopes()))
		for idx, v := range m.GetScopes() {

			target.Scopes[idx] = v

		}
	}

	if h, ok := interface{}(m.GetSession()).(clone.Cloner); ok {
		target.Session = h.Clone().(*UserSession)
	} else {
		target.Session = proto.Clone(m.GetSession()).(*UserSession)
	}

	if h, ok := interface{}(m.GetHeaders()).(clone.Cloner); ok {
		target.Headers = h.Clone().(*HeaderConfiguration)
	} else {
		target.Headers = proto.Clone(m.GetHeaders()).(*HeaderConfiguration)
	}

	if h, ok := interface{}(m.GetDiscoveryOverride()).(clone.Cloner); ok {
		target.DiscoveryOverride = h.Clone().(*DiscoveryOverride)
	} else {
		target.DiscoveryOverride = proto.Clone(m.GetDiscoveryOverride()).(*DiscoveryOverride)
	}

	if h, ok := interface{}(m.GetDiscoveryPollInterval()).(clone.Cloner); ok {
		target.DiscoveryPollInterval = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.DiscoveryPollInterval = proto.Clone(m.GetDiscoveryPollInterval()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	if h, ok := interface{}(m.GetJwksCacheRefreshPolicy()).(clone.Cloner); ok {
		target.JwksCacheRefreshPolicy = h.Clone().(*JwksOnDemandCacheRefreshPolicy)
	} else {
		target.JwksCacheRefreshPolicy = proto.Clone(m.GetJwksCacheRefreshPolicy()).(*JwksOnDemandCacheRefreshPolicy)
	}

	target.SessionIdHeaderName = m.GetSessionIdHeaderName()

	target.ParseCallbackPathAsRegex = m.GetParseCallbackPathAsRegex()

	if h, ok := interface{}(m.GetAutoMapFromMetadata()).(clone.Cloner); ok {
		target.AutoMapFromMetadata = h.Clone().(*AutoMapFromMetadata)
	} else {
		target.AutoMapFromMetadata = proto.Clone(m.GetAutoMapFromMetadata()).(*AutoMapFromMetadata)
	}

	if h, ok := interface{}(m.GetEndSessionProperties()).(clone.Cloner); ok {
		target.EndSessionProperties = h.Clone().(*EndSessionProperties)
	} else {
		target.EndSessionProperties = proto.Clone(m.GetEndSessionProperties()).(*EndSessionProperties)
	}

	if h, ok := interface{}(m.GetUserSession()).(clone.Cloner); ok {
		target.UserSession = h.Clone().(*ExtAuthConfig_UserSessionConfig)
	} else {
		target.UserSession = proto.Clone(m.GetUserSession()).(*ExtAuthConfig_UserSessionConfig)
	}

	if h, ok := interface{}(m.GetPkJwtClientAuthenticationConfig()).(clone.Cloner); ok {
		target.PkJwtClientAuthenticationConfig = h.Clone().(*ExtAuthConfig_OidcAuthorizationCodeConfig_PkJwtClientAuthenticationConfig)
	} else {
		target.PkJwtClientAuthenticationConfig = proto.Clone(m.GetPkJwtClientAuthenticationConfig()).(*ExtAuthConfig_OidcAuthorizationCodeConfig_PkJwtClientAuthenticationConfig)
	}

	if h, ok := interface{}(m.GetAccessToken()).(clone.Cloner); ok {
		target.AccessToken = h.Clone().(*ExtAuthConfig_OidcAuthorizationCodeConfig_AccessToken)
	} else {
		target.AccessToken = proto.Clone(m.GetAccessToken()).(*ExtAuthConfig_OidcAuthorizationCodeConfig_AccessToken)
	}

	if h, ok := interface{}(m.GetIdentityToken()).(clone.Cloner); ok {
		target.IdentityToken = h.Clone().(*ExtAuthConfig_OidcAuthorizationCodeConfig_IdentityToken)
	} else {
		target.IdentityToken = proto.Clone(m.GetIdentityToken()).(*ExtAuthConfig_OidcAuthorizationCodeConfig_IdentityToken)
	}

	if h, ok := interface{}(m.GetFrontChannelLogout()).(clone.Cloner); ok {
		target.FrontChannelLogout = h.Clone().(*ExtAuthConfig_OidcAuthorizationCodeConfig_FrontChannelLogout)
	} else {
		target.FrontChannelLogout = proto.Clone(m.GetFrontChannelLogout()).(*ExtAuthConfig_OidcAuthorizationCodeConfig_FrontChannelLogout)
	}

	switch m.Provider.(type) {

	case *ExtAuthConfig_OidcAuthorizationCodeConfig_Default_:

		if h, ok := interface{}(m.GetDefault()).(clone.Cloner); ok {
			target.Provider = &ExtAuthConfig_OidcAuthorizationCodeConfig_Default_{
				Default: h.Clone().(*ExtAuthConfig_OidcAuthorizationCodeConfig_Default),
			}
		} else {
			target.Provider = &ExtAuthConfig_OidcAuthorizationCodeConfig_Default_{
				Default: proto.Clone(m.GetDefault()).(*ExtAuthConfig_OidcAuthorizationCodeConfig_Default),
			}
		}

	case *ExtAuthConfig_OidcAuthorizationCodeConfig_Azure_:

		if h, ok := interface{}(m.GetAzure()).(clone.Cloner); ok {
			target.Provider = &ExtAuthConfig_OidcAuthorizationCodeConfig_Azure_{
				Azure: h.Clone().(*ExtAuthConfig_OidcAuthorizationCodeConfig_Azure),
			}
		} else {
			target.Provider = &ExtAuthConfig_OidcAuthorizationCodeConfig_Azure_{
				Azure: proto.Clone(m.GetAzure()).(*ExtAuthConfig_OidcAuthorizationCodeConfig_Azure),
			}
		}

	}

	return target
}

// Clone function
func (m *ExtAuthConfig_AccessTokenValidationConfig) Clone() proto.Message {
	var target *ExtAuthConfig_AccessTokenValidationConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_AccessTokenValidationConfig{}

	target.UserinfoUrl = m.GetUserinfoUrl()

	if h, ok := interface{}(m.GetCacheTimeout()).(clone.Cloner); ok {
		target.CacheTimeout = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.CacheTimeout = proto.Clone(m.GetCacheTimeout()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	switch m.ValidationType.(type) {

	case *ExtAuthConfig_AccessTokenValidationConfig_IntrospectionUrl:

		target.ValidationType = &ExtAuthConfig_AccessTokenValidationConfig_IntrospectionUrl{
			IntrospectionUrl: m.GetIntrospectionUrl(),
		}

	case *ExtAuthConfig_AccessTokenValidationConfig_Jwt:

		if h, ok := interface{}(m.GetJwt()).(clone.Cloner); ok {
			target.ValidationType = &ExtAuthConfig_AccessTokenValidationConfig_Jwt{
				Jwt: h.Clone().(*ExtAuthConfig_AccessTokenValidationConfig_JwtValidation),
			}
		} else {
			target.ValidationType = &ExtAuthConfig_AccessTokenValidationConfig_Jwt{
				Jwt: proto.Clone(m.GetJwt()).(*ExtAuthConfig_AccessTokenValidationConfig_JwtValidation),
			}
		}

	case *ExtAuthConfig_AccessTokenValidationConfig_Introspection:

		if h, ok := interface{}(m.GetIntrospection()).(clone.Cloner); ok {
			target.ValidationType = &ExtAuthConfig_AccessTokenValidationConfig_Introspection{
				Introspection: h.Clone().(*ExtAuthConfig_AccessTokenValidationConfig_IntrospectionValidation),
			}
		} else {
			target.ValidationType = &ExtAuthConfig_AccessTokenValidationConfig_Introspection{
				Introspection: proto.Clone(m.GetIntrospection()).(*ExtAuthConfig_AccessTokenValidationConfig_IntrospectionValidation),
			}
		}

	}

	switch m.ScopeValidation.(type) {

	case *ExtAuthConfig_AccessTokenValidationConfig_RequiredScopes:

		if h, ok := interface{}(m.GetRequiredScopes()).(clone.Cloner); ok {
			target.ScopeValidation = &ExtAuthConfig_AccessTokenValidationConfig_RequiredScopes{
				RequiredScopes: h.Clone().(*ExtAuthConfig_AccessTokenValidationConfig_ScopeList),
			}
		} else {
			target.ScopeValidation = &ExtAuthConfig_AccessTokenValidationConfig_RequiredScopes{
				RequiredScopes: proto.Clone(m.GetRequiredScopes()).(*ExtAuthConfig_AccessTokenValidationConfig_ScopeList),
			}
		}

	}

	return target
}

// Clone function
func (m *ExtAuthConfig_PlainOAuth2Config) Clone() proto.Message {
	var target *ExtAuthConfig_PlainOAuth2Config
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_PlainOAuth2Config{}

	target.ClientId = m.GetClientId()

	target.ClientSecret = m.GetClientSecret()

	if m.GetAuthEndpointQueryParams() != nil {
		target.AuthEndpointQueryParams = make(map[string]string, len(m.GetAuthEndpointQueryParams()))
		for k, v := range m.GetAuthEndpointQueryParams() {

			target.AuthEndpointQueryParams[k] = v

		}
	}

	target.AppUrl = m.GetAppUrl()

	target.CallbackPath = m.GetCallbackPath()

	if m.GetScopes() != nil {
		target.Scopes = make([]string, len(m.GetScopes()))
		for idx, v := range m.GetScopes() {

			target.Scopes[idx] = v

		}
	}

	if h, ok := interface{}(m.GetSession()).(clone.Cloner); ok {
		target.Session = h.Clone().(*UserSession)
	} else {
		target.Session = proto.Clone(m.GetSession()).(*UserSession)
	}

	target.LogoutPath = m.GetLogoutPath()

	if m.GetTokenEndpointQueryParams() != nil {
		target.TokenEndpointQueryParams = make(map[string]string, len(m.GetTokenEndpointQueryParams()))
		for k, v := range m.GetTokenEndpointQueryParams() {

			target.TokenEndpointQueryParams[k] = v

		}
	}

	target.AfterLogoutUrl = m.GetAfterLogoutUrl()

	target.AuthEndpoint = m.GetAuthEndpoint()

	target.TokenEndpoint = m.GetTokenEndpoint()

	target.RevocationEndpoint = m.GetRevocationEndpoint()

	if h, ok := interface{}(m.GetUserSession()).(clone.Cloner); ok {
		target.UserSession = h.Clone().(*ExtAuthConfig_UserSessionConfig)
	} else {
		target.UserSession = proto.Clone(m.GetUserSession()).(*ExtAuthConfig_UserSessionConfig)
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_OAuth2Config) Clone() proto.Message {
	var target *ExtAuthConfig_OAuth2Config
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OAuth2Config{}

	switch m.OauthType.(type) {

	case *ExtAuthConfig_OAuth2Config_OidcAuthorizationCode:

		if h, ok := interface{}(m.GetOidcAuthorizationCode()).(clone.Cloner); ok {
			target.OauthType = &ExtAuthConfig_OAuth2Config_OidcAuthorizationCode{
				OidcAuthorizationCode: h.Clone().(*ExtAuthConfig_OidcAuthorizationCodeConfig),
			}
		} else {
			target.OauthType = &ExtAuthConfig_OAuth2Config_OidcAuthorizationCode{
				OidcAuthorizationCode: proto.Clone(m.GetOidcAuthorizationCode()).(*ExtAuthConfig_OidcAuthorizationCodeConfig),
			}
		}

	case *ExtAuthConfig_OAuth2Config_AccessTokenValidationConfig:

		if h, ok := interface{}(m.GetAccessTokenValidationConfig()).(clone.Cloner); ok {
			target.OauthType = &ExtAuthConfig_OAuth2Config_AccessTokenValidationConfig{
				AccessTokenValidationConfig: h.Clone().(*ExtAuthConfig_AccessTokenValidationConfig),
			}
		} else {
			target.OauthType = &ExtAuthConfig_OAuth2Config_AccessTokenValidationConfig{
				AccessTokenValidationConfig: proto.Clone(m.GetAccessTokenValidationConfig()).(*ExtAuthConfig_AccessTokenValidationConfig),
			}
		}

	case *ExtAuthConfig_OAuth2Config_Oauth2Config:

		if h, ok := interface{}(m.GetOauth2Config()).(clone.Cloner); ok {
			target.OauthType = &ExtAuthConfig_OAuth2Config_Oauth2Config{
				Oauth2Config: h.Clone().(*ExtAuthConfig_PlainOAuth2Config),
			}
		} else {
			target.OauthType = &ExtAuthConfig_OAuth2Config_Oauth2Config{
				Oauth2Config: proto.Clone(m.GetOauth2Config()).(*ExtAuthConfig_PlainOAuth2Config),
			}
		}

	}

	return target
}

// Clone function
func (m *ExtAuthConfig_ApiKeyAuthConfig) Clone() proto.Message {
	var target *ExtAuthConfig_ApiKeyAuthConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_ApiKeyAuthConfig{}

	if m.GetValidApiKeys() != nil {
		target.ValidApiKeys = make(map[string]*ExtAuthConfig_ApiKeyAuthConfig_KeyMetadata, len(m.GetValidApiKeys()))
		for k, v := range m.GetValidApiKeys() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ValidApiKeys[k] = h.Clone().(*ExtAuthConfig_ApiKeyAuthConfig_KeyMetadata)
			} else {
				target.ValidApiKeys[k] = proto.Clone(v).(*ExtAuthConfig_ApiKeyAuthConfig_KeyMetadata)
			}

		}
	}

	target.HeaderName = m.GetHeaderName()

	if m.GetHeadersFromKeyMetadata() != nil {
		target.HeadersFromKeyMetadata = make(map[string]string, len(m.GetHeadersFromKeyMetadata()))
		for k, v := range m.GetHeadersFromKeyMetadata() {

			target.HeadersFromKeyMetadata[k] = v

		}
	}

	target.SkipMetadataValidation = m.GetSkipMetadataValidation()

	switch m.StorageBackend.(type) {

	case *ExtAuthConfig_ApiKeyAuthConfig_K8SSecretApikeyStorage:

		if h, ok := interface{}(m.GetK8SSecretApikeyStorage()).(clone.Cloner); ok {
			target.StorageBackend = &ExtAuthConfig_ApiKeyAuthConfig_K8SSecretApikeyStorage{
				K8SSecretApikeyStorage: h.Clone().(*K8SSecretApiKeyStorage),
			}
		} else {
			target.StorageBackend = &ExtAuthConfig_ApiKeyAuthConfig_K8SSecretApikeyStorage{
				K8SSecretApikeyStorage: proto.Clone(m.GetK8SSecretApikeyStorage()).(*K8SSecretApiKeyStorage),
			}
		}

	case *ExtAuthConfig_ApiKeyAuthConfig_AerospikeApikeyStorage:

		if h, ok := interface{}(m.GetAerospikeApikeyStorage()).(clone.Cloner); ok {
			target.StorageBackend = &ExtAuthConfig_ApiKeyAuthConfig_AerospikeApikeyStorage{
				AerospikeApikeyStorage: h.Clone().(*AerospikeApiKeyStorage),
			}
		} else {
			target.StorageBackend = &ExtAuthConfig_ApiKeyAuthConfig_AerospikeApikeyStorage{
				AerospikeApikeyStorage: proto.Clone(m.GetAerospikeApikeyStorage()).(*AerospikeApiKeyStorage),
			}
		}

	}

	return target
}

// Clone function
func (m *ExtAuthConfig_OpaAuthConfig) Clone() proto.Message {
	var target *ExtAuthConfig_OpaAuthConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OpaAuthConfig{}

	if m.GetModules() != nil {
		target.Modules = make(map[string]string, len(m.GetModules()))
		for k, v := range m.GetModules() {

			target.Modules[k] = v

		}
	}

	target.Query = m.GetQuery()

	if h, ok := interface{}(m.GetOptions()).(clone.Cloner); ok {
		target.Options = h.Clone().(*OpaAuthOptions)
	} else {
		target.Options = proto.Clone(m.GetOptions()).(*OpaAuthOptions)
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_OpaServerAuthConfig) Clone() proto.Message {
	var target *ExtAuthConfig_OpaServerAuthConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OpaServerAuthConfig{}

	target.Package = m.GetPackage()

	target.RuleName = m.GetRuleName()

	target.ServerAddr = m.GetServerAddr()

	if h, ok := interface{}(m.GetOptions()).(clone.Cloner); ok {
		target.Options = h.Clone().(*OpaAuthOptions)
	} else {
		target.Options = proto.Clone(m.GetOptions()).(*OpaAuthOptions)
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_LdapConfig) Clone() proto.Message {
	var target *ExtAuthConfig_LdapConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_LdapConfig{}

	target.Address = m.GetAddress()

	target.UserDnTemplate = m.GetUserDnTemplate()

	target.MembershipAttributeName = m.GetMembershipAttributeName()

	if m.GetAllowedGroups() != nil {
		target.AllowedGroups = make([]string, len(m.GetAllowedGroups()))
		for idx, v := range m.GetAllowedGroups() {

			target.AllowedGroups[idx] = v

		}
	}

	if h, ok := interface{}(m.GetPool()).(clone.Cloner); ok {
		target.Pool = h.Clone().(*Ldap_ConnectionPool)
	} else {
		target.Pool = proto.Clone(m.GetPool()).(*Ldap_ConnectionPool)
	}

	target.SearchFilter = m.GetSearchFilter()

	target.DisableGroupChecking = m.GetDisableGroupChecking()

	if h, ok := interface{}(m.GetGroupLookupSettings()).(clone.Cloner); ok {
		target.GroupLookupSettings = h.Clone().(*ExtAuthConfig_LdapServiceAccountConfig)
	} else {
		target.GroupLookupSettings = proto.Clone(m.GetGroupLookupSettings()).(*ExtAuthConfig_LdapServiceAccountConfig)
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_LdapServiceAccountConfig) Clone() proto.Message {
	var target *ExtAuthConfig_LdapServiceAccountConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_LdapServiceAccountConfig{}

	target.Username = m.GetUsername()

	target.Password = m.GetPassword()

	target.CheckGroupsWithServiceAccount = m.GetCheckGroupsWithServiceAccount()

	return target
}

// Clone function
func (m *ExtAuthConfig_HmacAuthConfig) Clone() proto.Message {
	var target *ExtAuthConfig_HmacAuthConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_HmacAuthConfig{}

	switch m.SecretStorage.(type) {

	case *ExtAuthConfig_HmacAuthConfig_SecretList:

		if h, ok := interface{}(m.GetSecretList()).(clone.Cloner); ok {
			target.SecretStorage = &ExtAuthConfig_HmacAuthConfig_SecretList{
				SecretList: h.Clone().(*ExtAuthConfig_InMemorySecretList),
			}
		} else {
			target.SecretStorage = &ExtAuthConfig_HmacAuthConfig_SecretList{
				SecretList: proto.Clone(m.GetSecretList()).(*ExtAuthConfig_InMemorySecretList),
			}
		}

	}

	switch m.ImplementationType.(type) {

	case *ExtAuthConfig_HmacAuthConfig_ParametersInHeaders:

		if h, ok := interface{}(m.GetParametersInHeaders()).(clone.Cloner); ok {
			target.ImplementationType = &ExtAuthConfig_HmacAuthConfig_ParametersInHeaders{
				ParametersInHeaders: h.Clone().(*HmacParametersInHeaders),
			}
		} else {
			target.ImplementationType = &ExtAuthConfig_HmacAuthConfig_ParametersInHeaders{
				ParametersInHeaders: proto.Clone(m.GetParametersInHeaders()).(*HmacParametersInHeaders),
			}
		}

	}

	return target
}

// Clone function
func (m *ExtAuthConfig_InMemorySecretList) Clone() proto.Message {
	var target *ExtAuthConfig_InMemorySecretList
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_InMemorySecretList{}

	if m.GetSecretList() != nil {
		target.SecretList = make(map[string]string, len(m.GetSecretList()))
		for k, v := range m.GetSecretList() {

			target.SecretList[k] = v

		}
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_Config) Clone() proto.Message {
	var target *ExtAuthConfig_Config
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_Config{}

	if h, ok := interface{}(m.GetName()).(clone.Cloner); ok {
		target.Name = h.Clone().(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	} else {
		target.Name = proto.Clone(m.GetName()).(*github_com_golang_protobuf_ptypes_wrappers.StringValue)
	}

	switch m.AuthConfig.(type) {

	case *ExtAuthConfig_Config_Oauth:

		if h, ok := interface{}(m.GetOauth()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_Oauth{
				Oauth: h.Clone().(*ExtAuthConfig_OAuthConfig),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_Oauth{
				Oauth: proto.Clone(m.GetOauth()).(*ExtAuthConfig_OAuthConfig),
			}
		}

	case *ExtAuthConfig_Config_Oauth2:

		if h, ok := interface{}(m.GetOauth2()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_Oauth2{
				Oauth2: h.Clone().(*ExtAuthConfig_OAuth2Config),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_Oauth2{
				Oauth2: proto.Clone(m.GetOauth2()).(*ExtAuthConfig_OAuth2Config),
			}
		}

	case *ExtAuthConfig_Config_BasicAuth:

		if h, ok := interface{}(m.GetBasicAuth()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_BasicAuth{
				BasicAuth: h.Clone().(*BasicAuth),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_BasicAuth{
				BasicAuth: proto.Clone(m.GetBasicAuth()).(*BasicAuth),
			}
		}

	case *ExtAuthConfig_Config_BasicAuthInternal:

		if h, ok := interface{}(m.GetBasicAuthInternal()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_BasicAuthInternal{
				BasicAuthInternal: h.Clone().(*ExtAuthConfig_BasicAuthInternal),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_BasicAuthInternal{
				BasicAuthInternal: proto.Clone(m.GetBasicAuthInternal()).(*ExtAuthConfig_BasicAuthInternal),
			}
		}

	case *ExtAuthConfig_Config_ApiKeyAuth:

		if h, ok := interface{}(m.GetApiKeyAuth()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_ApiKeyAuth{
				ApiKeyAuth: h.Clone().(*ExtAuthConfig_ApiKeyAuthConfig),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_ApiKeyAuth{
				ApiKeyAuth: proto.Clone(m.GetApiKeyAuth()).(*ExtAuthConfig_ApiKeyAuthConfig),
			}
		}

	case *ExtAuthConfig_Config_PluginAuth:

		if h, ok := interface{}(m.GetPluginAuth()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_PluginAuth{
				PluginAuth: h.Clone().(*AuthPlugin),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_PluginAuth{
				PluginAuth: proto.Clone(m.GetPluginAuth()).(*AuthPlugin),
			}
		}

	case *ExtAuthConfig_Config_OpaAuth:

		if h, ok := interface{}(m.GetOpaAuth()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_OpaAuth{
				OpaAuth: h.Clone().(*ExtAuthConfig_OpaAuthConfig),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_OpaAuth{
				OpaAuth: proto.Clone(m.GetOpaAuth()).(*ExtAuthConfig_OpaAuthConfig),
			}
		}

	case *ExtAuthConfig_Config_Ldap:

		if h, ok := interface{}(m.GetLdap()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_Ldap{
				Ldap: h.Clone().(*Ldap),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_Ldap{
				Ldap: proto.Clone(m.GetLdap()).(*Ldap),
			}
		}

	case *ExtAuthConfig_Config_LdapInternal:

		if h, ok := interface{}(m.GetLdapInternal()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_LdapInternal{
				LdapInternal: h.Clone().(*ExtAuthConfig_LdapConfig),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_LdapInternal{
				LdapInternal: proto.Clone(m.GetLdapInternal()).(*ExtAuthConfig_LdapConfig),
			}
		}

	case *ExtAuthConfig_Config_Jwt:

		if h, ok := interface{}(m.GetJwt()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_Jwt{
				Jwt: h.Clone().(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_Jwt{
				Jwt: proto.Clone(m.GetJwt()).(*github_com_golang_protobuf_ptypes_empty.Empty),
			}
		}

	case *ExtAuthConfig_Config_PassThroughAuth:

		if h, ok := interface{}(m.GetPassThroughAuth()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_PassThroughAuth{
				PassThroughAuth: h.Clone().(*PassThroughAuth),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_PassThroughAuth{
				PassThroughAuth: proto.Clone(m.GetPassThroughAuth()).(*PassThroughAuth),
			}
		}

	case *ExtAuthConfig_Config_HmacAuth:

		if h, ok := interface{}(m.GetHmacAuth()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_HmacAuth{
				HmacAuth: h.Clone().(*ExtAuthConfig_HmacAuthConfig),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_HmacAuth{
				HmacAuth: proto.Clone(m.GetHmacAuth()).(*ExtAuthConfig_HmacAuthConfig),
			}
		}

	case *ExtAuthConfig_Config_OpaServerAuth:

		if h, ok := interface{}(m.GetOpaServerAuth()).(clone.Cloner); ok {
			target.AuthConfig = &ExtAuthConfig_Config_OpaServerAuth{
				OpaServerAuth: h.Clone().(*ExtAuthConfig_OpaServerAuthConfig),
			}
		} else {
			target.AuthConfig = &ExtAuthConfig_Config_OpaServerAuth{
				OpaServerAuth: proto.Clone(m.GetOpaServerAuth()).(*ExtAuthConfig_OpaServerAuthConfig),
			}
		}

	}

	return target
}

// Clone function
func (m *ExtAuthConfig_BasicAuthInternal_EncryptionType) Clone() proto.Message {
	var target *ExtAuthConfig_BasicAuthInternal_EncryptionType
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_BasicAuthInternal_EncryptionType{}

	switch m.Algorithm.(type) {

	case *ExtAuthConfig_BasicAuthInternal_EncryptionType_Apr_:

		if h, ok := interface{}(m.GetApr()).(clone.Cloner); ok {
			target.Algorithm = &ExtAuthConfig_BasicAuthInternal_EncryptionType_Apr_{
				Apr: h.Clone().(*ExtAuthConfig_BasicAuthInternal_EncryptionType_Apr),
			}
		} else {
			target.Algorithm = &ExtAuthConfig_BasicAuthInternal_EncryptionType_Apr_{
				Apr: proto.Clone(m.GetApr()).(*ExtAuthConfig_BasicAuthInternal_EncryptionType_Apr),
			}
		}

	case *ExtAuthConfig_BasicAuthInternal_EncryptionType_Sha1_:

		if h, ok := interface{}(m.GetSha1()).(clone.Cloner); ok {
			target.Algorithm = &ExtAuthConfig_BasicAuthInternal_EncryptionType_Sha1_{
				Sha1: h.Clone().(*ExtAuthConfig_BasicAuthInternal_EncryptionType_Sha1),
			}
		} else {
			target.Algorithm = &ExtAuthConfig_BasicAuthInternal_EncryptionType_Sha1_{
				Sha1: proto.Clone(m.GetSha1()).(*ExtAuthConfig_BasicAuthInternal_EncryptionType_Sha1),
			}
		}

	}

	return target
}

// Clone function
func (m *ExtAuthConfig_BasicAuthInternal_User) Clone() proto.Message {
	var target *ExtAuthConfig_BasicAuthInternal_User
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_BasicAuthInternal_User{}

	target.Salt = m.GetSalt()

	target.HashedPassword = m.GetHashedPassword()

	return target
}

// Clone function
func (m *ExtAuthConfig_BasicAuthInternal_UserList) Clone() proto.Message {
	var target *ExtAuthConfig_BasicAuthInternal_UserList
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_BasicAuthInternal_UserList{}

	if m.GetUsers() != nil {
		target.Users = make(map[string]*ExtAuthConfig_BasicAuthInternal_User, len(m.GetUsers()))
		for k, v := range m.GetUsers() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Users[k] = h.Clone().(*ExtAuthConfig_BasicAuthInternal_User)
			} else {
				target.Users[k] = proto.Clone(v).(*ExtAuthConfig_BasicAuthInternal_User)
			}

		}
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_BasicAuthInternal_EncryptionType_Sha1) Clone() proto.Message {
	var target *ExtAuthConfig_BasicAuthInternal_EncryptionType_Sha1
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_BasicAuthInternal_EncryptionType_Sha1{}

	return target
}

// Clone function
func (m *ExtAuthConfig_BasicAuthInternal_EncryptionType_Apr) Clone() proto.Message {
	var target *ExtAuthConfig_BasicAuthInternal_EncryptionType_Apr
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_BasicAuthInternal_EncryptionType_Apr{}

	return target
}

// Clone function
func (m *ExtAuthConfig_UserSessionConfig_CipherConfig) Clone() proto.Message {
	var target *ExtAuthConfig_UserSessionConfig_CipherConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_UserSessionConfig_CipherConfig{}

	target.Key = m.GetKey()

	return target
}

// Clone function
func (m *ExtAuthConfig_OidcAuthorizationCodeConfig_PkJwtClientAuthenticationConfig) Clone() proto.Message {
	var target *ExtAuthConfig_OidcAuthorizationCodeConfig_PkJwtClientAuthenticationConfig
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OidcAuthorizationCodeConfig_PkJwtClientAuthenticationConfig{}

	target.SigningKey = m.GetSigningKey()

	if h, ok := interface{}(m.GetValidFor()).(clone.Cloner); ok {
		target.ValidFor = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.ValidFor = proto.Clone(m.GetValidFor()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_OidcAuthorizationCodeConfig_ClaimToHeader) Clone() proto.Message {
	var target *ExtAuthConfig_OidcAuthorizationCodeConfig_ClaimToHeader
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OidcAuthorizationCodeConfig_ClaimToHeader{}

	target.Claim = m.GetClaim()

	target.Header = m.GetHeader()

	target.Append = m.GetAppend()

	return target
}

// Clone function
func (m *ExtAuthConfig_OidcAuthorizationCodeConfig_AccessToken) Clone() proto.Message {
	var target *ExtAuthConfig_OidcAuthorizationCodeConfig_AccessToken
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OidcAuthorizationCodeConfig_AccessToken{}

	if m.GetClaimsToHeaders() != nil {
		target.ClaimsToHeaders = make([]*ExtAuthConfig_OidcAuthorizationCodeConfig_ClaimToHeader, len(m.GetClaimsToHeaders()))
		for idx, v := range m.GetClaimsToHeaders() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ClaimsToHeaders[idx] = h.Clone().(*ExtAuthConfig_OidcAuthorizationCodeConfig_ClaimToHeader)
			} else {
				target.ClaimsToHeaders[idx] = proto.Clone(v).(*ExtAuthConfig_OidcAuthorizationCodeConfig_ClaimToHeader)
			}

		}
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_OidcAuthorizationCodeConfig_IdentityToken) Clone() proto.Message {
	var target *ExtAuthConfig_OidcAuthorizationCodeConfig_IdentityToken
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OidcAuthorizationCodeConfig_IdentityToken{}

	if m.GetClaimsToHeaders() != nil {
		target.ClaimsToHeaders = make([]*ExtAuthConfig_OidcAuthorizationCodeConfig_ClaimToHeader, len(m.GetClaimsToHeaders()))
		for idx, v := range m.GetClaimsToHeaders() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.ClaimsToHeaders[idx] = h.Clone().(*ExtAuthConfig_OidcAuthorizationCodeConfig_ClaimToHeader)
			} else {
				target.ClaimsToHeaders[idx] = proto.Clone(v).(*ExtAuthConfig_OidcAuthorizationCodeConfig_ClaimToHeader)
			}

		}
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_OidcAuthorizationCodeConfig_Default) Clone() proto.Message {
	var target *ExtAuthConfig_OidcAuthorizationCodeConfig_Default
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OidcAuthorizationCodeConfig_Default{}

	return target
}

// Clone function
func (m *ExtAuthConfig_OidcAuthorizationCodeConfig_Azure) Clone() proto.Message {
	var target *ExtAuthConfig_OidcAuthorizationCodeConfig_Azure
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OidcAuthorizationCodeConfig_Azure{}

	target.ClientId = m.GetClientId()

	target.TenantId = m.GetTenantId()

	target.ClientSecret = m.GetClientSecret()

	if h, ok := interface{}(m.GetClaimsCachingOptions()).(clone.Cloner); ok {
		target.ClaimsCachingOptions = h.Clone().(*RedisOptions)
	} else {
		target.ClaimsCachingOptions = proto.Clone(m.GetClaimsCachingOptions()).(*RedisOptions)
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_OidcAuthorizationCodeConfig_FrontChannelLogout) Clone() proto.Message {
	var target *ExtAuthConfig_OidcAuthorizationCodeConfig_FrontChannelLogout
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_OidcAuthorizationCodeConfig_FrontChannelLogout{}

	target.Path = m.GetPath()

	return target
}

// Clone function
func (m *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation) Clone() proto.Message {
	var target *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_AccessTokenValidationConfig_JwtValidation{}

	target.Issuer = m.GetIssuer()

	switch m.JwksSourceSpecifier.(type) {

	case *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks_:

		if h, ok := interface{}(m.GetRemoteJwks()).(clone.Cloner); ok {
			target.JwksSourceSpecifier = &ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks_{
				RemoteJwks: h.Clone().(*ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks),
			}
		} else {
			target.JwksSourceSpecifier = &ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks_{
				RemoteJwks: proto.Clone(m.GetRemoteJwks()).(*ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks),
			}
		}

	case *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks_:

		if h, ok := interface{}(m.GetLocalJwks()).(clone.Cloner); ok {
			target.JwksSourceSpecifier = &ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks_{
				LocalJwks: h.Clone().(*ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks),
			}
		} else {
			target.JwksSourceSpecifier = &ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks_{
				LocalJwks: proto.Clone(m.GetLocalJwks()).(*ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks),
			}
		}

	}

	return target
}

// Clone function
func (m *ExtAuthConfig_AccessTokenValidationConfig_IntrospectionValidation) Clone() proto.Message {
	var target *ExtAuthConfig_AccessTokenValidationConfig_IntrospectionValidation
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_AccessTokenValidationConfig_IntrospectionValidation{}

	target.IntrospectionUrl = m.GetIntrospectionUrl()

	target.ClientId = m.GetClientId()

	target.ClientSecret = m.GetClientSecret()

	target.UserIdAttributeName = m.GetUserIdAttributeName()

	return target
}

// Clone function
func (m *ExtAuthConfig_AccessTokenValidationConfig_ScopeList) Clone() proto.Message {
	var target *ExtAuthConfig_AccessTokenValidationConfig_ScopeList
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_AccessTokenValidationConfig_ScopeList{}

	if m.GetScope() != nil {
		target.Scope = make([]string, len(m.GetScope()))
		for idx, v := range m.GetScope() {

			target.Scope[idx] = v

		}
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks) Clone() proto.Message {
	var target *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_RemoteJwks{}

	target.Url = m.GetUrl()

	if h, ok := interface{}(m.GetRefreshInterval()).(clone.Cloner); ok {
		target.RefreshInterval = h.Clone().(*github_com_golang_protobuf_ptypes_duration.Duration)
	} else {
		target.RefreshInterval = proto.Clone(m.GetRefreshInterval()).(*github_com_golang_protobuf_ptypes_duration.Duration)
	}

	return target
}

// Clone function
func (m *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks) Clone() proto.Message {
	var target *ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_AccessTokenValidationConfig_JwtValidation_LocalJwks{}

	target.InlineString = m.GetInlineString()

	return target
}

// Clone function
func (m *ExtAuthConfig_ApiKeyAuthConfig_KeyMetadata) Clone() proto.Message {
	var target *ExtAuthConfig_ApiKeyAuthConfig_KeyMetadata
	if m == nil {
		return target
	}
	target = &ExtAuthConfig_ApiKeyAuthConfig_KeyMetadata{}

	target.Username = m.GetUsername()

	if m.GetMetadata() != nil {
		target.Metadata = make(map[string]string, len(m.GetMetadata()))
		for k, v := range m.GetMetadata() {

			target.Metadata[k] = v

		}
	}

	return target
}
