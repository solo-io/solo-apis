// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./reconcilers.go -destination mocks/reconcilers.go

// Definitions for the Kubernetes Controllers
package controller

import (
	"context"

	trafficcontrol_solo_io_v2 "github.com/solo-io/solo-apis/pkg/api/trafficcontrol.solo.io/v2"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the MirrorPolicy Resource.
// implemented by the user
type MirrorPolicyReconciler interface {
	ReconcileMirrorPolicy(obj *trafficcontrol_solo_io_v2.MirrorPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the MirrorPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MirrorPolicyDeletionReconciler interface {
	ReconcileMirrorPolicyDeletion(req reconcile.Request) error
}

type MirrorPolicyReconcilerFuncs struct {
	OnReconcileMirrorPolicy         func(obj *trafficcontrol_solo_io_v2.MirrorPolicy) (reconcile.Result, error)
	OnReconcileMirrorPolicyDeletion func(req reconcile.Request) error
}

func (f *MirrorPolicyReconcilerFuncs) ReconcileMirrorPolicy(obj *trafficcontrol_solo_io_v2.MirrorPolicy) (reconcile.Result, error) {
	if f.OnReconcileMirrorPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileMirrorPolicy(obj)
}

func (f *MirrorPolicyReconcilerFuncs) ReconcileMirrorPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileMirrorPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileMirrorPolicyDeletion(req)
}

// Reconcile and finalize the MirrorPolicy Resource
// implemented by the user
type MirrorPolicyFinalizer interface {
	MirrorPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	MirrorPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeMirrorPolicy(obj *trafficcontrol_solo_io_v2.MirrorPolicy) error
}

type MirrorPolicyReconcileLoop interface {
	RunMirrorPolicyReconciler(ctx context.Context, rec MirrorPolicyReconciler, predicates ...predicate.Predicate) error
}

type mirrorPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewMirrorPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) MirrorPolicyReconcileLoop {
	return &mirrorPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &trafficcontrol_solo_io_v2.MirrorPolicy{}, options),
	}
}

func (c *mirrorPolicyReconcileLoop) RunMirrorPolicyReconciler(ctx context.Context, reconciler MirrorPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericMirrorPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(MirrorPolicyFinalizer); ok {
		reconcilerWrapper = genericMirrorPolicyFinalizer{
			genericMirrorPolicyReconciler: genericReconciler,
			finalizingReconciler:          finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericMirrorPolicyHandler implements a generic reconcile.Reconciler
type genericMirrorPolicyReconciler struct {
	reconciler MirrorPolicyReconciler
}

func (r genericMirrorPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*trafficcontrol_solo_io_v2.MirrorPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: MirrorPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileMirrorPolicy(obj)
}

func (r genericMirrorPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(MirrorPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileMirrorPolicyDeletion(request)
	}
	return nil
}

// genericMirrorPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericMirrorPolicyFinalizer struct {
	genericMirrorPolicyReconciler
	finalizingReconciler MirrorPolicyFinalizer
}

func (r genericMirrorPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.MirrorPolicyFinalizerName()
}

func (r genericMirrorPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*trafficcontrol_solo_io_v2.MirrorPolicy)
	if !ok {
		return errors.Errorf("internal error: MirrorPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeMirrorPolicy(obj)
}

// Reconcile Upsert events for the RateLimitPolicy Resource.
// implemented by the user
type RateLimitPolicyReconciler interface {
	ReconcileRateLimitPolicy(obj *trafficcontrol_solo_io_v2.RateLimitPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the RateLimitPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type RateLimitPolicyDeletionReconciler interface {
	ReconcileRateLimitPolicyDeletion(req reconcile.Request) error
}

type RateLimitPolicyReconcilerFuncs struct {
	OnReconcileRateLimitPolicy         func(obj *trafficcontrol_solo_io_v2.RateLimitPolicy) (reconcile.Result, error)
	OnReconcileRateLimitPolicyDeletion func(req reconcile.Request) error
}

func (f *RateLimitPolicyReconcilerFuncs) ReconcileRateLimitPolicy(obj *trafficcontrol_solo_io_v2.RateLimitPolicy) (reconcile.Result, error) {
	if f.OnReconcileRateLimitPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileRateLimitPolicy(obj)
}

func (f *RateLimitPolicyReconcilerFuncs) ReconcileRateLimitPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileRateLimitPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileRateLimitPolicyDeletion(req)
}

// Reconcile and finalize the RateLimitPolicy Resource
// implemented by the user
type RateLimitPolicyFinalizer interface {
	RateLimitPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	RateLimitPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeRateLimitPolicy(obj *trafficcontrol_solo_io_v2.RateLimitPolicy) error
}

type RateLimitPolicyReconcileLoop interface {
	RunRateLimitPolicyReconciler(ctx context.Context, rec RateLimitPolicyReconciler, predicates ...predicate.Predicate) error
}

type rateLimitPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewRateLimitPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) RateLimitPolicyReconcileLoop {
	return &rateLimitPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &trafficcontrol_solo_io_v2.RateLimitPolicy{}, options),
	}
}

func (c *rateLimitPolicyReconcileLoop) RunRateLimitPolicyReconciler(ctx context.Context, reconciler RateLimitPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericRateLimitPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(RateLimitPolicyFinalizer); ok {
		reconcilerWrapper = genericRateLimitPolicyFinalizer{
			genericRateLimitPolicyReconciler: genericReconciler,
			finalizingReconciler:             finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericRateLimitPolicyHandler implements a generic reconcile.Reconciler
type genericRateLimitPolicyReconciler struct {
	reconciler RateLimitPolicyReconciler
}

func (r genericRateLimitPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*trafficcontrol_solo_io_v2.RateLimitPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: RateLimitPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileRateLimitPolicy(obj)
}

func (r genericRateLimitPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(RateLimitPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileRateLimitPolicyDeletion(request)
	}
	return nil
}

// genericRateLimitPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericRateLimitPolicyFinalizer struct {
	genericRateLimitPolicyReconciler
	finalizingReconciler RateLimitPolicyFinalizer
}

func (r genericRateLimitPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.RateLimitPolicyFinalizerName()
}

func (r genericRateLimitPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*trafficcontrol_solo_io_v2.RateLimitPolicy)
	if !ok {
		return errors.Errorf("internal error: RateLimitPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeRateLimitPolicy(obj)
}

// Reconcile Upsert events for the RateLimitClientConfig Resource.
// implemented by the user
type RateLimitClientConfigReconciler interface {
	ReconcileRateLimitClientConfig(obj *trafficcontrol_solo_io_v2.RateLimitClientConfig) (reconcile.Result, error)
}

// Reconcile deletion events for the RateLimitClientConfig Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type RateLimitClientConfigDeletionReconciler interface {
	ReconcileRateLimitClientConfigDeletion(req reconcile.Request) error
}

type RateLimitClientConfigReconcilerFuncs struct {
	OnReconcileRateLimitClientConfig         func(obj *trafficcontrol_solo_io_v2.RateLimitClientConfig) (reconcile.Result, error)
	OnReconcileRateLimitClientConfigDeletion func(req reconcile.Request) error
}

func (f *RateLimitClientConfigReconcilerFuncs) ReconcileRateLimitClientConfig(obj *trafficcontrol_solo_io_v2.RateLimitClientConfig) (reconcile.Result, error) {
	if f.OnReconcileRateLimitClientConfig == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileRateLimitClientConfig(obj)
}

func (f *RateLimitClientConfigReconcilerFuncs) ReconcileRateLimitClientConfigDeletion(req reconcile.Request) error {
	if f.OnReconcileRateLimitClientConfigDeletion == nil {
		return nil
	}
	return f.OnReconcileRateLimitClientConfigDeletion(req)
}

// Reconcile and finalize the RateLimitClientConfig Resource
// implemented by the user
type RateLimitClientConfigFinalizer interface {
	RateLimitClientConfigReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	RateLimitClientConfigFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeRateLimitClientConfig(obj *trafficcontrol_solo_io_v2.RateLimitClientConfig) error
}

type RateLimitClientConfigReconcileLoop interface {
	RunRateLimitClientConfigReconciler(ctx context.Context, rec RateLimitClientConfigReconciler, predicates ...predicate.Predicate) error
}

type rateLimitClientConfigReconcileLoop struct {
	loop reconcile.Loop
}

func NewRateLimitClientConfigReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) RateLimitClientConfigReconcileLoop {
	return &rateLimitClientConfigReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &trafficcontrol_solo_io_v2.RateLimitClientConfig{}, options),
	}
}

func (c *rateLimitClientConfigReconcileLoop) RunRateLimitClientConfigReconciler(ctx context.Context, reconciler RateLimitClientConfigReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericRateLimitClientConfigReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(RateLimitClientConfigFinalizer); ok {
		reconcilerWrapper = genericRateLimitClientConfigFinalizer{
			genericRateLimitClientConfigReconciler: genericReconciler,
			finalizingReconciler:                   finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericRateLimitClientConfigHandler implements a generic reconcile.Reconciler
type genericRateLimitClientConfigReconciler struct {
	reconciler RateLimitClientConfigReconciler
}

func (r genericRateLimitClientConfigReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*trafficcontrol_solo_io_v2.RateLimitClientConfig)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: RateLimitClientConfig handler received event for %T", object)
	}
	return r.reconciler.ReconcileRateLimitClientConfig(obj)
}

func (r genericRateLimitClientConfigReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(RateLimitClientConfigDeletionReconciler); ok {
		return deletionReconciler.ReconcileRateLimitClientConfigDeletion(request)
	}
	return nil
}

// genericRateLimitClientConfigFinalizer implements a generic reconcile.FinalizingReconciler
type genericRateLimitClientConfigFinalizer struct {
	genericRateLimitClientConfigReconciler
	finalizingReconciler RateLimitClientConfigFinalizer
}

func (r genericRateLimitClientConfigFinalizer) FinalizerName() string {
	return r.finalizingReconciler.RateLimitClientConfigFinalizerName()
}

func (r genericRateLimitClientConfigFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*trafficcontrol_solo_io_v2.RateLimitClientConfig)
	if !ok {
		return errors.Errorf("internal error: RateLimitClientConfig handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeRateLimitClientConfig(obj)
}

// Reconcile Upsert events for the HeaderManipulationPolicy Resource.
// implemented by the user
type HeaderManipulationPolicyReconciler interface {
	ReconcileHeaderManipulationPolicy(obj *trafficcontrol_solo_io_v2.HeaderManipulationPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the HeaderManipulationPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type HeaderManipulationPolicyDeletionReconciler interface {
	ReconcileHeaderManipulationPolicyDeletion(req reconcile.Request) error
}

type HeaderManipulationPolicyReconcilerFuncs struct {
	OnReconcileHeaderManipulationPolicy         func(obj *trafficcontrol_solo_io_v2.HeaderManipulationPolicy) (reconcile.Result, error)
	OnReconcileHeaderManipulationPolicyDeletion func(req reconcile.Request) error
}

func (f *HeaderManipulationPolicyReconcilerFuncs) ReconcileHeaderManipulationPolicy(obj *trafficcontrol_solo_io_v2.HeaderManipulationPolicy) (reconcile.Result, error) {
	if f.OnReconcileHeaderManipulationPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileHeaderManipulationPolicy(obj)
}

func (f *HeaderManipulationPolicyReconcilerFuncs) ReconcileHeaderManipulationPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileHeaderManipulationPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileHeaderManipulationPolicyDeletion(req)
}

// Reconcile and finalize the HeaderManipulationPolicy Resource
// implemented by the user
type HeaderManipulationPolicyFinalizer interface {
	HeaderManipulationPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	HeaderManipulationPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeHeaderManipulationPolicy(obj *trafficcontrol_solo_io_v2.HeaderManipulationPolicy) error
}

type HeaderManipulationPolicyReconcileLoop interface {
	RunHeaderManipulationPolicyReconciler(ctx context.Context, rec HeaderManipulationPolicyReconciler, predicates ...predicate.Predicate) error
}

type headerManipulationPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewHeaderManipulationPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) HeaderManipulationPolicyReconcileLoop {
	return &headerManipulationPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &trafficcontrol_solo_io_v2.HeaderManipulationPolicy{}, options),
	}
}

func (c *headerManipulationPolicyReconcileLoop) RunHeaderManipulationPolicyReconciler(ctx context.Context, reconciler HeaderManipulationPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericHeaderManipulationPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(HeaderManipulationPolicyFinalizer); ok {
		reconcilerWrapper = genericHeaderManipulationPolicyFinalizer{
			genericHeaderManipulationPolicyReconciler: genericReconciler,
			finalizingReconciler:                      finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericHeaderManipulationPolicyHandler implements a generic reconcile.Reconciler
type genericHeaderManipulationPolicyReconciler struct {
	reconciler HeaderManipulationPolicyReconciler
}

func (r genericHeaderManipulationPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*trafficcontrol_solo_io_v2.HeaderManipulationPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: HeaderManipulationPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileHeaderManipulationPolicy(obj)
}

func (r genericHeaderManipulationPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(HeaderManipulationPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileHeaderManipulationPolicyDeletion(request)
	}
	return nil
}

// genericHeaderManipulationPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericHeaderManipulationPolicyFinalizer struct {
	genericHeaderManipulationPolicyReconciler
	finalizingReconciler HeaderManipulationPolicyFinalizer
}

func (r genericHeaderManipulationPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.HeaderManipulationPolicyFinalizerName()
}

func (r genericHeaderManipulationPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*trafficcontrol_solo_io_v2.HeaderManipulationPolicy)
	if !ok {
		return errors.Errorf("internal error: HeaderManipulationPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeHeaderManipulationPolicy(obj)
}

// Reconcile Upsert events for the TransformationPolicy Resource.
// implemented by the user
type TransformationPolicyReconciler interface {
	ReconcileTransformationPolicy(obj *trafficcontrol_solo_io_v2.TransformationPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the TransformationPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type TransformationPolicyDeletionReconciler interface {
	ReconcileTransformationPolicyDeletion(req reconcile.Request) error
}

type TransformationPolicyReconcilerFuncs struct {
	OnReconcileTransformationPolicy         func(obj *trafficcontrol_solo_io_v2.TransformationPolicy) (reconcile.Result, error)
	OnReconcileTransformationPolicyDeletion func(req reconcile.Request) error
}

func (f *TransformationPolicyReconcilerFuncs) ReconcileTransformationPolicy(obj *trafficcontrol_solo_io_v2.TransformationPolicy) (reconcile.Result, error) {
	if f.OnReconcileTransformationPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileTransformationPolicy(obj)
}

func (f *TransformationPolicyReconcilerFuncs) ReconcileTransformationPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileTransformationPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileTransformationPolicyDeletion(req)
}

// Reconcile and finalize the TransformationPolicy Resource
// implemented by the user
type TransformationPolicyFinalizer interface {
	TransformationPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	TransformationPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeTransformationPolicy(obj *trafficcontrol_solo_io_v2.TransformationPolicy) error
}

type TransformationPolicyReconcileLoop interface {
	RunTransformationPolicyReconciler(ctx context.Context, rec TransformationPolicyReconciler, predicates ...predicate.Predicate) error
}

type transformationPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewTransformationPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) TransformationPolicyReconcileLoop {
	return &transformationPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &trafficcontrol_solo_io_v2.TransformationPolicy{}, options),
	}
}

func (c *transformationPolicyReconcileLoop) RunTransformationPolicyReconciler(ctx context.Context, reconciler TransformationPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericTransformationPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(TransformationPolicyFinalizer); ok {
		reconcilerWrapper = genericTransformationPolicyFinalizer{
			genericTransformationPolicyReconciler: genericReconciler,
			finalizingReconciler:                  finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericTransformationPolicyHandler implements a generic reconcile.Reconciler
type genericTransformationPolicyReconciler struct {
	reconciler TransformationPolicyReconciler
}

func (r genericTransformationPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*trafficcontrol_solo_io_v2.TransformationPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: TransformationPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileTransformationPolicy(obj)
}

func (r genericTransformationPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(TransformationPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileTransformationPolicyDeletion(request)
	}
	return nil
}

// genericTransformationPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericTransformationPolicyFinalizer struct {
	genericTransformationPolicyReconciler
	finalizingReconciler TransformationPolicyFinalizer
}

func (r genericTransformationPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.TransformationPolicyFinalizerName()
}

func (r genericTransformationPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*trafficcontrol_solo_io_v2.TransformationPolicy)
	if !ok {
		return errors.Errorf("internal error: TransformationPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeTransformationPolicy(obj)
}

// Reconcile Upsert events for the ProxyProtocolPolicy Resource.
// implemented by the user
type ProxyProtocolPolicyReconciler interface {
	ReconcileProxyProtocolPolicy(obj *trafficcontrol_solo_io_v2.ProxyProtocolPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the ProxyProtocolPolicy Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type ProxyProtocolPolicyDeletionReconciler interface {
	ReconcileProxyProtocolPolicyDeletion(req reconcile.Request) error
}

type ProxyProtocolPolicyReconcilerFuncs struct {
	OnReconcileProxyProtocolPolicy         func(obj *trafficcontrol_solo_io_v2.ProxyProtocolPolicy) (reconcile.Result, error)
	OnReconcileProxyProtocolPolicyDeletion func(req reconcile.Request) error
}

func (f *ProxyProtocolPolicyReconcilerFuncs) ReconcileProxyProtocolPolicy(obj *trafficcontrol_solo_io_v2.ProxyProtocolPolicy) (reconcile.Result, error) {
	if f.OnReconcileProxyProtocolPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileProxyProtocolPolicy(obj)
}

func (f *ProxyProtocolPolicyReconcilerFuncs) ReconcileProxyProtocolPolicyDeletion(req reconcile.Request) error {
	if f.OnReconcileProxyProtocolPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileProxyProtocolPolicyDeletion(req)
}

// Reconcile and finalize the ProxyProtocolPolicy Resource
// implemented by the user
type ProxyProtocolPolicyFinalizer interface {
	ProxyProtocolPolicyReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	ProxyProtocolPolicyFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeProxyProtocolPolicy(obj *trafficcontrol_solo_io_v2.ProxyProtocolPolicy) error
}

type ProxyProtocolPolicyReconcileLoop interface {
	RunProxyProtocolPolicyReconciler(ctx context.Context, rec ProxyProtocolPolicyReconciler, predicates ...predicate.Predicate) error
}

type proxyProtocolPolicyReconcileLoop struct {
	loop reconcile.Loop
}

func NewProxyProtocolPolicyReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) ProxyProtocolPolicyReconcileLoop {
	return &proxyProtocolPolicyReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &trafficcontrol_solo_io_v2.ProxyProtocolPolicy{}, options),
	}
}

func (c *proxyProtocolPolicyReconcileLoop) RunProxyProtocolPolicyReconciler(ctx context.Context, reconciler ProxyProtocolPolicyReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericProxyProtocolPolicyReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(ProxyProtocolPolicyFinalizer); ok {
		reconcilerWrapper = genericProxyProtocolPolicyFinalizer{
			genericProxyProtocolPolicyReconciler: genericReconciler,
			finalizingReconciler:                 finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericProxyProtocolPolicyHandler implements a generic reconcile.Reconciler
type genericProxyProtocolPolicyReconciler struct {
	reconciler ProxyProtocolPolicyReconciler
}

func (r genericProxyProtocolPolicyReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*trafficcontrol_solo_io_v2.ProxyProtocolPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ProxyProtocolPolicy handler received event for %T", object)
	}
	return r.reconciler.ReconcileProxyProtocolPolicy(obj)
}

func (r genericProxyProtocolPolicyReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(ProxyProtocolPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileProxyProtocolPolicyDeletion(request)
	}
	return nil
}

// genericProxyProtocolPolicyFinalizer implements a generic reconcile.FinalizingReconciler
type genericProxyProtocolPolicyFinalizer struct {
	genericProxyProtocolPolicyReconciler
	finalizingReconciler ProxyProtocolPolicyFinalizer
}

func (r genericProxyProtocolPolicyFinalizer) FinalizerName() string {
	return r.finalizingReconciler.ProxyProtocolPolicyFinalizerName()
}

func (r genericProxyProtocolPolicyFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*trafficcontrol_solo_io_v2.ProxyProtocolPolicy)
	if !ok {
		return errors.Errorf("internal error: ProxyProtocolPolicy handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeProxyProtocolPolicy(obj)
}
