// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./sets.go -destination mocks/sets.go

package v2sets

import (
	resilience_solo_io_v2 "github.com/solo-io/solo-apis/pkg/api/resilience.solo.io/v2"

	"github.com/rotisserie/eris"
	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"k8s.io/apimachinery/pkg/util/sets"
)

type FailoverPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*resilience_solo_io_v2.FailoverPolicy) bool) []*resilience_solo_io_v2.FailoverPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*resilience_solo_io_v2.FailoverPolicy) bool) []*resilience_solo_io_v2.FailoverPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_solo_io_v2.FailoverPolicy
	// Insert a resource into the set.
	Insert(failoverPolicy ...*resilience_solo_io_v2.FailoverPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(failoverPolicySet FailoverPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(failoverPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(failoverPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set FailoverPolicySet) FailoverPolicySet
	// Return the difference with the provided set
	Difference(set FailoverPolicySet) FailoverPolicySet
	// Return the intersection with the provided set
	Intersection(set FailoverPolicySet) FailoverPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_solo_io_v2.FailoverPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another FailoverPolicySet
	Delta(newSet FailoverPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current FailoverPolicySet
	Clone() FailoverPolicySet
}

func makeGenericFailoverPolicySet(failoverPolicyList []*resilience_solo_io_v2.FailoverPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range failoverPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type failoverPolicySet struct {
	set sksets.ResourceSet
}

func NewFailoverPolicySet(failoverPolicyList ...*resilience_solo_io_v2.FailoverPolicy) FailoverPolicySet {
	return &failoverPolicySet{set: makeGenericFailoverPolicySet(failoverPolicyList)}
}

func NewFailoverPolicySetFromList(failoverPolicyList *resilience_solo_io_v2.FailoverPolicyList) FailoverPolicySet {
	list := make([]*resilience_solo_io_v2.FailoverPolicy, 0, len(failoverPolicyList.Items))
	for idx := range failoverPolicyList.Items {
		list = append(list, &failoverPolicyList.Items[idx])
	}
	return &failoverPolicySet{set: makeGenericFailoverPolicySet(list)}
}

func (s *failoverPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *failoverPolicySet) List(filterResource ...func(*resilience_solo_io_v2.FailoverPolicy) bool) []*resilience_solo_io_v2.FailoverPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_solo_io_v2.FailoverPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	failoverPolicyList := make([]*resilience_solo_io_v2.FailoverPolicy, 0, len(objs))
	for _, obj := range objs {
		failoverPolicyList = append(failoverPolicyList, obj.(*resilience_solo_io_v2.FailoverPolicy))
	}
	return failoverPolicyList
}

func (s *failoverPolicySet) UnsortedList(filterResource ...func(*resilience_solo_io_v2.FailoverPolicy) bool) []*resilience_solo_io_v2.FailoverPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_solo_io_v2.FailoverPolicy))
		})
	}

	var failoverPolicyList []*resilience_solo_io_v2.FailoverPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		failoverPolicyList = append(failoverPolicyList, obj.(*resilience_solo_io_v2.FailoverPolicy))
	}
	return failoverPolicyList
}

func (s *failoverPolicySet) Map() map[string]*resilience_solo_io_v2.FailoverPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_solo_io_v2.FailoverPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_solo_io_v2.FailoverPolicy)
	}
	return newMap
}

func (s *failoverPolicySet) Insert(
	failoverPolicyList ...*resilience_solo_io_v2.FailoverPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range failoverPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *failoverPolicySet) Has(failoverPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(failoverPolicy)
}

func (s *failoverPolicySet) Equal(
	failoverPolicySet FailoverPolicySet,
) bool {
	if s == nil {
		return failoverPolicySet == nil
	}
	return s.Generic().Equal(failoverPolicySet.Generic())
}

func (s *failoverPolicySet) Delete(FailoverPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(FailoverPolicy)
}

func (s *failoverPolicySet) Union(set FailoverPolicySet) FailoverPolicySet {
	if s == nil {
		return set
	}
	return NewFailoverPolicySet(append(s.List(), set.List()...)...)
}

func (s *failoverPolicySet) Difference(set FailoverPolicySet) FailoverPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &failoverPolicySet{set: newSet}
}

func (s *failoverPolicySet) Intersection(set FailoverPolicySet) FailoverPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var failoverPolicyList []*resilience_solo_io_v2.FailoverPolicy
	for _, obj := range newSet.List() {
		failoverPolicyList = append(failoverPolicyList, obj.(*resilience_solo_io_v2.FailoverPolicy))
	}
	return NewFailoverPolicySet(failoverPolicyList...)
}

func (s *failoverPolicySet) Find(id ezkube.ResourceId) (*resilience_solo_io_v2.FailoverPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find FailoverPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_solo_io_v2.FailoverPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_solo_io_v2.FailoverPolicy), nil
}

func (s *failoverPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *failoverPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *failoverPolicySet) Delta(newSet FailoverPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *failoverPolicySet) Clone() FailoverPolicySet {
	if s == nil {
		return nil
	}
	return &failoverPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type OutlierDetectionPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*resilience_solo_io_v2.OutlierDetectionPolicy) bool) []*resilience_solo_io_v2.OutlierDetectionPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*resilience_solo_io_v2.OutlierDetectionPolicy) bool) []*resilience_solo_io_v2.OutlierDetectionPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_solo_io_v2.OutlierDetectionPolicy
	// Insert a resource into the set.
	Insert(outlierDetectionPolicy ...*resilience_solo_io_v2.OutlierDetectionPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(outlierDetectionPolicySet OutlierDetectionPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(outlierDetectionPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(outlierDetectionPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set OutlierDetectionPolicySet) OutlierDetectionPolicySet
	// Return the difference with the provided set
	Difference(set OutlierDetectionPolicySet) OutlierDetectionPolicySet
	// Return the intersection with the provided set
	Intersection(set OutlierDetectionPolicySet) OutlierDetectionPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_solo_io_v2.OutlierDetectionPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another OutlierDetectionPolicySet
	Delta(newSet OutlierDetectionPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current OutlierDetectionPolicySet
	Clone() OutlierDetectionPolicySet
}

func makeGenericOutlierDetectionPolicySet(outlierDetectionPolicyList []*resilience_solo_io_v2.OutlierDetectionPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range outlierDetectionPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type outlierDetectionPolicySet struct {
	set sksets.ResourceSet
}

func NewOutlierDetectionPolicySet(outlierDetectionPolicyList ...*resilience_solo_io_v2.OutlierDetectionPolicy) OutlierDetectionPolicySet {
	return &outlierDetectionPolicySet{set: makeGenericOutlierDetectionPolicySet(outlierDetectionPolicyList)}
}

func NewOutlierDetectionPolicySetFromList(outlierDetectionPolicyList *resilience_solo_io_v2.OutlierDetectionPolicyList) OutlierDetectionPolicySet {
	list := make([]*resilience_solo_io_v2.OutlierDetectionPolicy, 0, len(outlierDetectionPolicyList.Items))
	for idx := range outlierDetectionPolicyList.Items {
		list = append(list, &outlierDetectionPolicyList.Items[idx])
	}
	return &outlierDetectionPolicySet{set: makeGenericOutlierDetectionPolicySet(list)}
}

func (s *outlierDetectionPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *outlierDetectionPolicySet) List(filterResource ...func(*resilience_solo_io_v2.OutlierDetectionPolicy) bool) []*resilience_solo_io_v2.OutlierDetectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_solo_io_v2.OutlierDetectionPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	outlierDetectionPolicyList := make([]*resilience_solo_io_v2.OutlierDetectionPolicy, 0, len(objs))
	for _, obj := range objs {
		outlierDetectionPolicyList = append(outlierDetectionPolicyList, obj.(*resilience_solo_io_v2.OutlierDetectionPolicy))
	}
	return outlierDetectionPolicyList
}

func (s *outlierDetectionPolicySet) UnsortedList(filterResource ...func(*resilience_solo_io_v2.OutlierDetectionPolicy) bool) []*resilience_solo_io_v2.OutlierDetectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_solo_io_v2.OutlierDetectionPolicy))
		})
	}

	var outlierDetectionPolicyList []*resilience_solo_io_v2.OutlierDetectionPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		outlierDetectionPolicyList = append(outlierDetectionPolicyList, obj.(*resilience_solo_io_v2.OutlierDetectionPolicy))
	}
	return outlierDetectionPolicyList
}

func (s *outlierDetectionPolicySet) Map() map[string]*resilience_solo_io_v2.OutlierDetectionPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_solo_io_v2.OutlierDetectionPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_solo_io_v2.OutlierDetectionPolicy)
	}
	return newMap
}

func (s *outlierDetectionPolicySet) Insert(
	outlierDetectionPolicyList ...*resilience_solo_io_v2.OutlierDetectionPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range outlierDetectionPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *outlierDetectionPolicySet) Has(outlierDetectionPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(outlierDetectionPolicy)
}

func (s *outlierDetectionPolicySet) Equal(
	outlierDetectionPolicySet OutlierDetectionPolicySet,
) bool {
	if s == nil {
		return outlierDetectionPolicySet == nil
	}
	return s.Generic().Equal(outlierDetectionPolicySet.Generic())
}

func (s *outlierDetectionPolicySet) Delete(OutlierDetectionPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(OutlierDetectionPolicy)
}

func (s *outlierDetectionPolicySet) Union(set OutlierDetectionPolicySet) OutlierDetectionPolicySet {
	if s == nil {
		return set
	}
	return NewOutlierDetectionPolicySet(append(s.List(), set.List()...)...)
}

func (s *outlierDetectionPolicySet) Difference(set OutlierDetectionPolicySet) OutlierDetectionPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &outlierDetectionPolicySet{set: newSet}
}

func (s *outlierDetectionPolicySet) Intersection(set OutlierDetectionPolicySet) OutlierDetectionPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var outlierDetectionPolicyList []*resilience_solo_io_v2.OutlierDetectionPolicy
	for _, obj := range newSet.List() {
		outlierDetectionPolicyList = append(outlierDetectionPolicyList, obj.(*resilience_solo_io_v2.OutlierDetectionPolicy))
	}
	return NewOutlierDetectionPolicySet(outlierDetectionPolicyList...)
}

func (s *outlierDetectionPolicySet) Find(id ezkube.ResourceId) (*resilience_solo_io_v2.OutlierDetectionPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find OutlierDetectionPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_solo_io_v2.OutlierDetectionPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_solo_io_v2.OutlierDetectionPolicy), nil
}

func (s *outlierDetectionPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *outlierDetectionPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *outlierDetectionPolicySet) Delta(newSet OutlierDetectionPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *outlierDetectionPolicySet) Clone() OutlierDetectionPolicySet {
	if s == nil {
		return nil
	}
	return &outlierDetectionPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type FaultInjectionPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*resilience_solo_io_v2.FaultInjectionPolicy) bool) []*resilience_solo_io_v2.FaultInjectionPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*resilience_solo_io_v2.FaultInjectionPolicy) bool) []*resilience_solo_io_v2.FaultInjectionPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_solo_io_v2.FaultInjectionPolicy
	// Insert a resource into the set.
	Insert(faultInjectionPolicy ...*resilience_solo_io_v2.FaultInjectionPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(faultInjectionPolicySet FaultInjectionPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(faultInjectionPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(faultInjectionPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set FaultInjectionPolicySet) FaultInjectionPolicySet
	// Return the difference with the provided set
	Difference(set FaultInjectionPolicySet) FaultInjectionPolicySet
	// Return the intersection with the provided set
	Intersection(set FaultInjectionPolicySet) FaultInjectionPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_solo_io_v2.FaultInjectionPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another FaultInjectionPolicySet
	Delta(newSet FaultInjectionPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current FaultInjectionPolicySet
	Clone() FaultInjectionPolicySet
}

func makeGenericFaultInjectionPolicySet(faultInjectionPolicyList []*resilience_solo_io_v2.FaultInjectionPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range faultInjectionPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type faultInjectionPolicySet struct {
	set sksets.ResourceSet
}

func NewFaultInjectionPolicySet(faultInjectionPolicyList ...*resilience_solo_io_v2.FaultInjectionPolicy) FaultInjectionPolicySet {
	return &faultInjectionPolicySet{set: makeGenericFaultInjectionPolicySet(faultInjectionPolicyList)}
}

func NewFaultInjectionPolicySetFromList(faultInjectionPolicyList *resilience_solo_io_v2.FaultInjectionPolicyList) FaultInjectionPolicySet {
	list := make([]*resilience_solo_io_v2.FaultInjectionPolicy, 0, len(faultInjectionPolicyList.Items))
	for idx := range faultInjectionPolicyList.Items {
		list = append(list, &faultInjectionPolicyList.Items[idx])
	}
	return &faultInjectionPolicySet{set: makeGenericFaultInjectionPolicySet(list)}
}

func (s *faultInjectionPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *faultInjectionPolicySet) List(filterResource ...func(*resilience_solo_io_v2.FaultInjectionPolicy) bool) []*resilience_solo_io_v2.FaultInjectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_solo_io_v2.FaultInjectionPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	faultInjectionPolicyList := make([]*resilience_solo_io_v2.FaultInjectionPolicy, 0, len(objs))
	for _, obj := range objs {
		faultInjectionPolicyList = append(faultInjectionPolicyList, obj.(*resilience_solo_io_v2.FaultInjectionPolicy))
	}
	return faultInjectionPolicyList
}

func (s *faultInjectionPolicySet) UnsortedList(filterResource ...func(*resilience_solo_io_v2.FaultInjectionPolicy) bool) []*resilience_solo_io_v2.FaultInjectionPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_solo_io_v2.FaultInjectionPolicy))
		})
	}

	var faultInjectionPolicyList []*resilience_solo_io_v2.FaultInjectionPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		faultInjectionPolicyList = append(faultInjectionPolicyList, obj.(*resilience_solo_io_v2.FaultInjectionPolicy))
	}
	return faultInjectionPolicyList
}

func (s *faultInjectionPolicySet) Map() map[string]*resilience_solo_io_v2.FaultInjectionPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_solo_io_v2.FaultInjectionPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_solo_io_v2.FaultInjectionPolicy)
	}
	return newMap
}

func (s *faultInjectionPolicySet) Insert(
	faultInjectionPolicyList ...*resilience_solo_io_v2.FaultInjectionPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range faultInjectionPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *faultInjectionPolicySet) Has(faultInjectionPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(faultInjectionPolicy)
}

func (s *faultInjectionPolicySet) Equal(
	faultInjectionPolicySet FaultInjectionPolicySet,
) bool {
	if s == nil {
		return faultInjectionPolicySet == nil
	}
	return s.Generic().Equal(faultInjectionPolicySet.Generic())
}

func (s *faultInjectionPolicySet) Delete(FaultInjectionPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(FaultInjectionPolicy)
}

func (s *faultInjectionPolicySet) Union(set FaultInjectionPolicySet) FaultInjectionPolicySet {
	if s == nil {
		return set
	}
	return NewFaultInjectionPolicySet(append(s.List(), set.List()...)...)
}

func (s *faultInjectionPolicySet) Difference(set FaultInjectionPolicySet) FaultInjectionPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &faultInjectionPolicySet{set: newSet}
}

func (s *faultInjectionPolicySet) Intersection(set FaultInjectionPolicySet) FaultInjectionPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var faultInjectionPolicyList []*resilience_solo_io_v2.FaultInjectionPolicy
	for _, obj := range newSet.List() {
		faultInjectionPolicyList = append(faultInjectionPolicyList, obj.(*resilience_solo_io_v2.FaultInjectionPolicy))
	}
	return NewFaultInjectionPolicySet(faultInjectionPolicyList...)
}

func (s *faultInjectionPolicySet) Find(id ezkube.ResourceId) (*resilience_solo_io_v2.FaultInjectionPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find FaultInjectionPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_solo_io_v2.FaultInjectionPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_solo_io_v2.FaultInjectionPolicy), nil
}

func (s *faultInjectionPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *faultInjectionPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *faultInjectionPolicySet) Delta(newSet FaultInjectionPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *faultInjectionPolicySet) Clone() FaultInjectionPolicySet {
	if s == nil {
		return nil
	}
	return &faultInjectionPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type RetryTimeoutPolicySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*resilience_solo_io_v2.RetryTimeoutPolicy) bool) []*resilience_solo_io_v2.RetryTimeoutPolicy
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*resilience_solo_io_v2.RetryTimeoutPolicy) bool) []*resilience_solo_io_v2.RetryTimeoutPolicy
	// Return the Set as a map of key to resource.
	Map() map[string]*resilience_solo_io_v2.RetryTimeoutPolicy
	// Insert a resource into the set.
	Insert(retryTimeoutPolicy ...*resilience_solo_io_v2.RetryTimeoutPolicy)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(retryTimeoutPolicySet RetryTimeoutPolicySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(retryTimeoutPolicy ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(retryTimeoutPolicy ezkube.ResourceId)
	// Return the union with the provided set
	Union(set RetryTimeoutPolicySet) RetryTimeoutPolicySet
	// Return the difference with the provided set
	Difference(set RetryTimeoutPolicySet) RetryTimeoutPolicySet
	// Return the intersection with the provided set
	Intersection(set RetryTimeoutPolicySet) RetryTimeoutPolicySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*resilience_solo_io_v2.RetryTimeoutPolicy, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another RetryTimeoutPolicySet
	Delta(newSet RetryTimeoutPolicySet) sksets.ResourceDelta
	// Create a deep copy of the current RetryTimeoutPolicySet
	Clone() RetryTimeoutPolicySet
}

func makeGenericRetryTimeoutPolicySet(retryTimeoutPolicyList []*resilience_solo_io_v2.RetryTimeoutPolicy) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range retryTimeoutPolicyList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type retryTimeoutPolicySet struct {
	set sksets.ResourceSet
}

func NewRetryTimeoutPolicySet(retryTimeoutPolicyList ...*resilience_solo_io_v2.RetryTimeoutPolicy) RetryTimeoutPolicySet {
	return &retryTimeoutPolicySet{set: makeGenericRetryTimeoutPolicySet(retryTimeoutPolicyList)}
}

func NewRetryTimeoutPolicySetFromList(retryTimeoutPolicyList *resilience_solo_io_v2.RetryTimeoutPolicyList) RetryTimeoutPolicySet {
	list := make([]*resilience_solo_io_v2.RetryTimeoutPolicy, 0, len(retryTimeoutPolicyList.Items))
	for idx := range retryTimeoutPolicyList.Items {
		list = append(list, &retryTimeoutPolicyList.Items[idx])
	}
	return &retryTimeoutPolicySet{set: makeGenericRetryTimeoutPolicySet(list)}
}

func (s *retryTimeoutPolicySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *retryTimeoutPolicySet) List(filterResource ...func(*resilience_solo_io_v2.RetryTimeoutPolicy) bool) []*resilience_solo_io_v2.RetryTimeoutPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_solo_io_v2.RetryTimeoutPolicy))
		})
	}

	objs := s.Generic().List(genericFilters...)
	retryTimeoutPolicyList := make([]*resilience_solo_io_v2.RetryTimeoutPolicy, 0, len(objs))
	for _, obj := range objs {
		retryTimeoutPolicyList = append(retryTimeoutPolicyList, obj.(*resilience_solo_io_v2.RetryTimeoutPolicy))
	}
	return retryTimeoutPolicyList
}

func (s *retryTimeoutPolicySet) UnsortedList(filterResource ...func(*resilience_solo_io_v2.RetryTimeoutPolicy) bool) []*resilience_solo_io_v2.RetryTimeoutPolicy {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*resilience_solo_io_v2.RetryTimeoutPolicy))
		})
	}

	var retryTimeoutPolicyList []*resilience_solo_io_v2.RetryTimeoutPolicy
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		retryTimeoutPolicyList = append(retryTimeoutPolicyList, obj.(*resilience_solo_io_v2.RetryTimeoutPolicy))
	}
	return retryTimeoutPolicyList
}

func (s *retryTimeoutPolicySet) Map() map[string]*resilience_solo_io_v2.RetryTimeoutPolicy {
	if s == nil {
		return nil
	}

	newMap := map[string]*resilience_solo_io_v2.RetryTimeoutPolicy{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*resilience_solo_io_v2.RetryTimeoutPolicy)
	}
	return newMap
}

func (s *retryTimeoutPolicySet) Insert(
	retryTimeoutPolicyList ...*resilience_solo_io_v2.RetryTimeoutPolicy,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range retryTimeoutPolicyList {
		s.Generic().Insert(obj)
	}
}

func (s *retryTimeoutPolicySet) Has(retryTimeoutPolicy ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(retryTimeoutPolicy)
}

func (s *retryTimeoutPolicySet) Equal(
	retryTimeoutPolicySet RetryTimeoutPolicySet,
) bool {
	if s == nil {
		return retryTimeoutPolicySet == nil
	}
	return s.Generic().Equal(retryTimeoutPolicySet.Generic())
}

func (s *retryTimeoutPolicySet) Delete(RetryTimeoutPolicy ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(RetryTimeoutPolicy)
}

func (s *retryTimeoutPolicySet) Union(set RetryTimeoutPolicySet) RetryTimeoutPolicySet {
	if s == nil {
		return set
	}
	return NewRetryTimeoutPolicySet(append(s.List(), set.List()...)...)
}

func (s *retryTimeoutPolicySet) Difference(set RetryTimeoutPolicySet) RetryTimeoutPolicySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &retryTimeoutPolicySet{set: newSet}
}

func (s *retryTimeoutPolicySet) Intersection(set RetryTimeoutPolicySet) RetryTimeoutPolicySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var retryTimeoutPolicyList []*resilience_solo_io_v2.RetryTimeoutPolicy
	for _, obj := range newSet.List() {
		retryTimeoutPolicyList = append(retryTimeoutPolicyList, obj.(*resilience_solo_io_v2.RetryTimeoutPolicy))
	}
	return NewRetryTimeoutPolicySet(retryTimeoutPolicyList...)
}

func (s *retryTimeoutPolicySet) Find(id ezkube.ResourceId) (*resilience_solo_io_v2.RetryTimeoutPolicy, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find RetryTimeoutPolicy %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&resilience_solo_io_v2.RetryTimeoutPolicy{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*resilience_solo_io_v2.RetryTimeoutPolicy), nil
}

func (s *retryTimeoutPolicySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *retryTimeoutPolicySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *retryTimeoutPolicySet) Delta(newSet RetryTimeoutPolicySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *retryTimeoutPolicySet) Clone() RetryTimeoutPolicySet {
	if s == nil {
		return nil
	}
	return &retryTimeoutPolicySet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}
