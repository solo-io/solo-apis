// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./reconcilers.go -destination mocks/reconcilers.go

// Definitions for the Kubernetes Controllers
package controller



import (
	"context"

    gateway_solo_io_v1 "github.com/solo-io/solo-apis/pkg/api/gateway.solo.io/v1"

    "github.com/pkg/errors"
    "github.com/solo-io/skv2/pkg/ezkube"
    "github.com/solo-io/skv2/pkg/reconcile"
    "sigs.k8s.io/controller-runtime/pkg/manager"
    "sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the Gateway Resource.
// implemented by the user
type GatewayReconciler interface {
    ReconcileGateway(obj *gateway_solo_io_v1.Gateway) (reconcile.Result, error)
}

// Reconcile deletion events for the Gateway Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type GatewayDeletionReconciler interface {
    ReconcileGatewayDeletion(req reconcile.Request) error
}

type GatewayReconcilerFuncs struct {
    OnReconcileGateway func(obj *gateway_solo_io_v1.Gateway) (reconcile.Result, error)
    OnReconcileGatewayDeletion func(req reconcile.Request) error
}

func (f *GatewayReconcilerFuncs) ReconcileGateway(obj *gateway_solo_io_v1.Gateway) (reconcile.Result, error) {
    if f.OnReconcileGateway == nil {
        return reconcile.Result{}, nil
    }
    return f.OnReconcileGateway(obj)
}

func (f *GatewayReconcilerFuncs) ReconcileGatewayDeletion(req reconcile.Request) error {
    if f.OnReconcileGatewayDeletion == nil {
        return nil
    }
    return f.OnReconcileGatewayDeletion(req)
}

// Reconcile and finalize the Gateway Resource
// implemented by the user
type GatewayFinalizer interface {
    GatewayReconciler

    // name of the finalizer used by this handler.
    // finalizer names should be unique for a single task
    GatewayFinalizerName() string

    // finalize the object before it is deleted.
    // Watchers created with a finalizing handler will a
    FinalizeGateway(obj *gateway_solo_io_v1.Gateway) error
}

type GatewayReconcileLoop interface {
    RunGatewayReconciler(ctx context.Context, rec GatewayReconciler, predicates ...predicate.Predicate) error
}

type gatewayReconcileLoop struct {
    loop reconcile.Loop
}

func NewGatewayReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) GatewayReconcileLoop {
    return &gatewayReconcileLoop{
    	// empty cluster indicates this reconciler is built for the local cluster
        loop: reconcile.NewLoop(name, "", mgr, &gateway_solo_io_v1.Gateway{}, options),
    }
}

func (c *gatewayReconcileLoop) RunGatewayReconciler(ctx context.Context, reconciler GatewayReconciler, predicates ...predicate.Predicate) error {
    genericReconciler := genericGatewayReconciler{
        reconciler: reconciler,
    }

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(GatewayFinalizer); ok {
        reconcilerWrapper = genericGatewayFinalizer{
            genericGatewayReconciler: genericReconciler,
            finalizingReconciler: finalizingReconciler,
        }
    } else {
        reconcilerWrapper = genericReconciler
    }
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericGatewayHandler implements a generic reconcile.Reconciler
type genericGatewayReconciler struct {
    reconciler GatewayReconciler
}

func (r genericGatewayReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
    obj, ok := object.(*gateway_solo_io_v1.Gateway)
    if !ok {
        return reconcile.Result{}, errors.Errorf("internal error: Gateway handler received event for %T", object)
    }
    return r.reconciler.ReconcileGateway(obj)
}

func (r genericGatewayReconciler) ReconcileDeletion(request reconcile.Request) error {
    if deletionReconciler, ok := r.reconciler.(GatewayDeletionReconciler); ok {
        return deletionReconciler.ReconcileGatewayDeletion(request)
    }
    return nil
}

// genericGatewayFinalizer implements a generic reconcile.FinalizingReconciler
type genericGatewayFinalizer struct {
    genericGatewayReconciler
    finalizingReconciler GatewayFinalizer
}


func (r genericGatewayFinalizer) FinalizerName() string {
    return r.finalizingReconciler.GatewayFinalizerName()
}

func (r genericGatewayFinalizer) Finalize(object ezkube.Object) error {
    obj, ok := object.(*gateway_solo_io_v1.Gateway)
    if !ok {
        return errors.Errorf("internal error: Gateway handler received event for %T", object)
    }
    return r.finalizingReconciler.FinalizeGateway(obj)
}

// Reconcile Upsert events for the RouteTable Resource.
// implemented by the user
type RouteTableReconciler interface {
    ReconcileRouteTable(obj *gateway_solo_io_v1.RouteTable) (reconcile.Result, error)
}

// Reconcile deletion events for the RouteTable Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type RouteTableDeletionReconciler interface {
    ReconcileRouteTableDeletion(req reconcile.Request) error
}

type RouteTableReconcilerFuncs struct {
    OnReconcileRouteTable func(obj *gateway_solo_io_v1.RouteTable) (reconcile.Result, error)
    OnReconcileRouteTableDeletion func(req reconcile.Request) error
}

func (f *RouteTableReconcilerFuncs) ReconcileRouteTable(obj *gateway_solo_io_v1.RouteTable) (reconcile.Result, error) {
    if f.OnReconcileRouteTable == nil {
        return reconcile.Result{}, nil
    }
    return f.OnReconcileRouteTable(obj)
}

func (f *RouteTableReconcilerFuncs) ReconcileRouteTableDeletion(req reconcile.Request) error {
    if f.OnReconcileRouteTableDeletion == nil {
        return nil
    }
    return f.OnReconcileRouteTableDeletion(req)
}

// Reconcile and finalize the RouteTable Resource
// implemented by the user
type RouteTableFinalizer interface {
    RouteTableReconciler

    // name of the finalizer used by this handler.
    // finalizer names should be unique for a single task
    RouteTableFinalizerName() string

    // finalize the object before it is deleted.
    // Watchers created with a finalizing handler will a
    FinalizeRouteTable(obj *gateway_solo_io_v1.RouteTable) error
}

type RouteTableReconcileLoop interface {
    RunRouteTableReconciler(ctx context.Context, rec RouteTableReconciler, predicates ...predicate.Predicate) error
}

type routeTableReconcileLoop struct {
    loop reconcile.Loop
}

func NewRouteTableReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) RouteTableReconcileLoop {
    return &routeTableReconcileLoop{
    	// empty cluster indicates this reconciler is built for the local cluster
        loop: reconcile.NewLoop(name, "", mgr, &gateway_solo_io_v1.RouteTable{}, options),
    }
}

func (c *routeTableReconcileLoop) RunRouteTableReconciler(ctx context.Context, reconciler RouteTableReconciler, predicates ...predicate.Predicate) error {
    genericReconciler := genericRouteTableReconciler{
        reconciler: reconciler,
    }

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(RouteTableFinalizer); ok {
        reconcilerWrapper = genericRouteTableFinalizer{
            genericRouteTableReconciler: genericReconciler,
            finalizingReconciler: finalizingReconciler,
        }
    } else {
        reconcilerWrapper = genericReconciler
    }
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericRouteTableHandler implements a generic reconcile.Reconciler
type genericRouteTableReconciler struct {
    reconciler RouteTableReconciler
}

func (r genericRouteTableReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
    obj, ok := object.(*gateway_solo_io_v1.RouteTable)
    if !ok {
        return reconcile.Result{}, errors.Errorf("internal error: RouteTable handler received event for %T", object)
    }
    return r.reconciler.ReconcileRouteTable(obj)
}

func (r genericRouteTableReconciler) ReconcileDeletion(request reconcile.Request) error {
    if deletionReconciler, ok := r.reconciler.(RouteTableDeletionReconciler); ok {
        return deletionReconciler.ReconcileRouteTableDeletion(request)
    }
    return nil
}

// genericRouteTableFinalizer implements a generic reconcile.FinalizingReconciler
type genericRouteTableFinalizer struct {
    genericRouteTableReconciler
    finalizingReconciler RouteTableFinalizer
}


func (r genericRouteTableFinalizer) FinalizerName() string {
    return r.finalizingReconciler.RouteTableFinalizerName()
}

func (r genericRouteTableFinalizer) Finalize(object ezkube.Object) error {
    obj, ok := object.(*gateway_solo_io_v1.RouteTable)
    if !ok {
        return errors.Errorf("internal error: RouteTable handler received event for %T", object)
    }
    return r.finalizingReconciler.FinalizeRouteTable(obj)
}

// Reconcile Upsert events for the VirtualService Resource.
// implemented by the user
type VirtualServiceReconciler interface {
    ReconcileVirtualService(obj *gateway_solo_io_v1.VirtualService) (reconcile.Result, error)
}

// Reconcile deletion events for the VirtualService Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type VirtualServiceDeletionReconciler interface {
    ReconcileVirtualServiceDeletion(req reconcile.Request) error
}

type VirtualServiceReconcilerFuncs struct {
    OnReconcileVirtualService func(obj *gateway_solo_io_v1.VirtualService) (reconcile.Result, error)
    OnReconcileVirtualServiceDeletion func(req reconcile.Request) error
}

func (f *VirtualServiceReconcilerFuncs) ReconcileVirtualService(obj *gateway_solo_io_v1.VirtualService) (reconcile.Result, error) {
    if f.OnReconcileVirtualService == nil {
        return reconcile.Result{}, nil
    }
    return f.OnReconcileVirtualService(obj)
}

func (f *VirtualServiceReconcilerFuncs) ReconcileVirtualServiceDeletion(req reconcile.Request) error {
    if f.OnReconcileVirtualServiceDeletion == nil {
        return nil
    }
    return f.OnReconcileVirtualServiceDeletion(req)
}

// Reconcile and finalize the VirtualService Resource
// implemented by the user
type VirtualServiceFinalizer interface {
    VirtualServiceReconciler

    // name of the finalizer used by this handler.
    // finalizer names should be unique for a single task
    VirtualServiceFinalizerName() string

    // finalize the object before it is deleted.
    // Watchers created with a finalizing handler will a
    FinalizeVirtualService(obj *gateway_solo_io_v1.VirtualService) error
}

type VirtualServiceReconcileLoop interface {
    RunVirtualServiceReconciler(ctx context.Context, rec VirtualServiceReconciler, predicates ...predicate.Predicate) error
}

type virtualServiceReconcileLoop struct {
    loop reconcile.Loop
}

func NewVirtualServiceReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) VirtualServiceReconcileLoop {
    return &virtualServiceReconcileLoop{
    	// empty cluster indicates this reconciler is built for the local cluster
        loop: reconcile.NewLoop(name, "", mgr, &gateway_solo_io_v1.VirtualService{}, options),
    }
}

func (c *virtualServiceReconcileLoop) RunVirtualServiceReconciler(ctx context.Context, reconciler VirtualServiceReconciler, predicates ...predicate.Predicate) error {
    genericReconciler := genericVirtualServiceReconciler{
        reconciler: reconciler,
    }

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(VirtualServiceFinalizer); ok {
        reconcilerWrapper = genericVirtualServiceFinalizer{
            genericVirtualServiceReconciler: genericReconciler,
            finalizingReconciler: finalizingReconciler,
        }
    } else {
        reconcilerWrapper = genericReconciler
    }
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericVirtualServiceHandler implements a generic reconcile.Reconciler
type genericVirtualServiceReconciler struct {
    reconciler VirtualServiceReconciler
}

func (r genericVirtualServiceReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
    obj, ok := object.(*gateway_solo_io_v1.VirtualService)
    if !ok {
        return reconcile.Result{}, errors.Errorf("internal error: VirtualService handler received event for %T", object)
    }
    return r.reconciler.ReconcileVirtualService(obj)
}

func (r genericVirtualServiceReconciler) ReconcileDeletion(request reconcile.Request) error {
    if deletionReconciler, ok := r.reconciler.(VirtualServiceDeletionReconciler); ok {
        return deletionReconciler.ReconcileVirtualServiceDeletion(request)
    }
    return nil
}

// genericVirtualServiceFinalizer implements a generic reconcile.FinalizingReconciler
type genericVirtualServiceFinalizer struct {
    genericVirtualServiceReconciler
    finalizingReconciler VirtualServiceFinalizer
}


func (r genericVirtualServiceFinalizer) FinalizerName() string {
    return r.finalizingReconciler.VirtualServiceFinalizerName()
}

func (r genericVirtualServiceFinalizer) Finalize(object ezkube.Object) error {
    obj, ok := object.(*gateway_solo_io_v1.VirtualService)
    if !ok {
        return errors.Errorf("internal error: VirtualService handler received event for %T", object)
    }
    return r.finalizingReconciler.FinalizeVirtualService(obj)
}

// Reconcile Upsert events for the VirtualHostOption Resource.
// implemented by the user
type VirtualHostOptionReconciler interface {
    ReconcileVirtualHostOption(obj *gateway_solo_io_v1.VirtualHostOption) (reconcile.Result, error)
}

// Reconcile deletion events for the VirtualHostOption Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type VirtualHostOptionDeletionReconciler interface {
    ReconcileVirtualHostOptionDeletion(req reconcile.Request) error
}

type VirtualHostOptionReconcilerFuncs struct {
    OnReconcileVirtualHostOption func(obj *gateway_solo_io_v1.VirtualHostOption) (reconcile.Result, error)
    OnReconcileVirtualHostOptionDeletion func(req reconcile.Request) error
}

func (f *VirtualHostOptionReconcilerFuncs) ReconcileVirtualHostOption(obj *gateway_solo_io_v1.VirtualHostOption) (reconcile.Result, error) {
    if f.OnReconcileVirtualHostOption == nil {
        return reconcile.Result{}, nil
    }
    return f.OnReconcileVirtualHostOption(obj)
}

func (f *VirtualHostOptionReconcilerFuncs) ReconcileVirtualHostOptionDeletion(req reconcile.Request) error {
    if f.OnReconcileVirtualHostOptionDeletion == nil {
        return nil
    }
    return f.OnReconcileVirtualHostOptionDeletion(req)
}

// Reconcile and finalize the VirtualHostOption Resource
// implemented by the user
type VirtualHostOptionFinalizer interface {
    VirtualHostOptionReconciler

    // name of the finalizer used by this handler.
    // finalizer names should be unique for a single task
    VirtualHostOptionFinalizerName() string

    // finalize the object before it is deleted.
    // Watchers created with a finalizing handler will a
    FinalizeVirtualHostOption(obj *gateway_solo_io_v1.VirtualHostOption) error
}

type VirtualHostOptionReconcileLoop interface {
    RunVirtualHostOptionReconciler(ctx context.Context, rec VirtualHostOptionReconciler, predicates ...predicate.Predicate) error
}

type virtualHostOptionReconcileLoop struct {
    loop reconcile.Loop
}

func NewVirtualHostOptionReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) VirtualHostOptionReconcileLoop {
    return &virtualHostOptionReconcileLoop{
    	// empty cluster indicates this reconciler is built for the local cluster
        loop: reconcile.NewLoop(name, "", mgr, &gateway_solo_io_v1.VirtualHostOption{}, options),
    }
}

func (c *virtualHostOptionReconcileLoop) RunVirtualHostOptionReconciler(ctx context.Context, reconciler VirtualHostOptionReconciler, predicates ...predicate.Predicate) error {
    genericReconciler := genericVirtualHostOptionReconciler{
        reconciler: reconciler,
    }

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(VirtualHostOptionFinalizer); ok {
        reconcilerWrapper = genericVirtualHostOptionFinalizer{
            genericVirtualHostOptionReconciler: genericReconciler,
            finalizingReconciler: finalizingReconciler,
        }
    } else {
        reconcilerWrapper = genericReconciler
    }
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericVirtualHostOptionHandler implements a generic reconcile.Reconciler
type genericVirtualHostOptionReconciler struct {
    reconciler VirtualHostOptionReconciler
}

func (r genericVirtualHostOptionReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
    obj, ok := object.(*gateway_solo_io_v1.VirtualHostOption)
    if !ok {
        return reconcile.Result{}, errors.Errorf("internal error: VirtualHostOption handler received event for %T", object)
    }
    return r.reconciler.ReconcileVirtualHostOption(obj)
}

func (r genericVirtualHostOptionReconciler) ReconcileDeletion(request reconcile.Request) error {
    if deletionReconciler, ok := r.reconciler.(VirtualHostOptionDeletionReconciler); ok {
        return deletionReconciler.ReconcileVirtualHostOptionDeletion(request)
    }
    return nil
}

// genericVirtualHostOptionFinalizer implements a generic reconcile.FinalizingReconciler
type genericVirtualHostOptionFinalizer struct {
    genericVirtualHostOptionReconciler
    finalizingReconciler VirtualHostOptionFinalizer
}


func (r genericVirtualHostOptionFinalizer) FinalizerName() string {
    return r.finalizingReconciler.VirtualHostOptionFinalizerName()
}

func (r genericVirtualHostOptionFinalizer) Finalize(object ezkube.Object) error {
    obj, ok := object.(*gateway_solo_io_v1.VirtualHostOption)
    if !ok {
        return errors.Errorf("internal error: VirtualHostOption handler received event for %T", object)
    }
    return r.finalizingReconciler.FinalizeVirtualHostOption(obj)
}

// Reconcile Upsert events for the RouteOption Resource.
// implemented by the user
type RouteOptionReconciler interface {
    ReconcileRouteOption(obj *gateway_solo_io_v1.RouteOption) (reconcile.Result, error)
}

// Reconcile deletion events for the RouteOption Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type RouteOptionDeletionReconciler interface {
    ReconcileRouteOptionDeletion(req reconcile.Request) error
}

type RouteOptionReconcilerFuncs struct {
    OnReconcileRouteOption func(obj *gateway_solo_io_v1.RouteOption) (reconcile.Result, error)
    OnReconcileRouteOptionDeletion func(req reconcile.Request) error
}

func (f *RouteOptionReconcilerFuncs) ReconcileRouteOption(obj *gateway_solo_io_v1.RouteOption) (reconcile.Result, error) {
    if f.OnReconcileRouteOption == nil {
        return reconcile.Result{}, nil
    }
    return f.OnReconcileRouteOption(obj)
}

func (f *RouteOptionReconcilerFuncs) ReconcileRouteOptionDeletion(req reconcile.Request) error {
    if f.OnReconcileRouteOptionDeletion == nil {
        return nil
    }
    return f.OnReconcileRouteOptionDeletion(req)
}

// Reconcile and finalize the RouteOption Resource
// implemented by the user
type RouteOptionFinalizer interface {
    RouteOptionReconciler

    // name of the finalizer used by this handler.
    // finalizer names should be unique for a single task
    RouteOptionFinalizerName() string

    // finalize the object before it is deleted.
    // Watchers created with a finalizing handler will a
    FinalizeRouteOption(obj *gateway_solo_io_v1.RouteOption) error
}

type RouteOptionReconcileLoop interface {
    RunRouteOptionReconciler(ctx context.Context, rec RouteOptionReconciler, predicates ...predicate.Predicate) error
}

type routeOptionReconcileLoop struct {
    loop reconcile.Loop
}

func NewRouteOptionReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) RouteOptionReconcileLoop {
    return &routeOptionReconcileLoop{
    	// empty cluster indicates this reconciler is built for the local cluster
        loop: reconcile.NewLoop(name, "", mgr, &gateway_solo_io_v1.RouteOption{}, options),
    }
}

func (c *routeOptionReconcileLoop) RunRouteOptionReconciler(ctx context.Context, reconciler RouteOptionReconciler, predicates ...predicate.Predicate) error {
    genericReconciler := genericRouteOptionReconciler{
        reconciler: reconciler,
    }

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(RouteOptionFinalizer); ok {
        reconcilerWrapper = genericRouteOptionFinalizer{
            genericRouteOptionReconciler: genericReconciler,
            finalizingReconciler: finalizingReconciler,
        }
    } else {
        reconcilerWrapper = genericReconciler
    }
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericRouteOptionHandler implements a generic reconcile.Reconciler
type genericRouteOptionReconciler struct {
    reconciler RouteOptionReconciler
}

func (r genericRouteOptionReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
    obj, ok := object.(*gateway_solo_io_v1.RouteOption)
    if !ok {
        return reconcile.Result{}, errors.Errorf("internal error: RouteOption handler received event for %T", object)
    }
    return r.reconciler.ReconcileRouteOption(obj)
}

func (r genericRouteOptionReconciler) ReconcileDeletion(request reconcile.Request) error {
    if deletionReconciler, ok := r.reconciler.(RouteOptionDeletionReconciler); ok {
        return deletionReconciler.ReconcileRouteOptionDeletion(request)
    }
    return nil
}

// genericRouteOptionFinalizer implements a generic reconcile.FinalizingReconciler
type genericRouteOptionFinalizer struct {
    genericRouteOptionReconciler
    finalizingReconciler RouteOptionFinalizer
}


func (r genericRouteOptionFinalizer) FinalizerName() string {
    return r.finalizingReconciler.RouteOptionFinalizerName()
}

func (r genericRouteOptionFinalizer) Finalize(object ezkube.Object) error {
    obj, ok := object.(*gateway_solo_io_v1.RouteOption)
    if !ok {
        return errors.Errorf("internal error: RouteOption handler received event for %T", object)
    }
    return r.finalizingReconciler.FinalizeRouteOption(obj)
}
