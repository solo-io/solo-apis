// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/solo-io/solo-apis/api/rate-limiter/v1alpha1/ratelimit.proto

package v1alpha1

import (
	bytes "bytes"
	fmt "fmt"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "github.com/solo-io/protoc-gen-ext/extproto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RateLimitConfigStatus_State int32

const (
	RateLimitConfigStatus_PENDING  RateLimitConfigStatus_State = 0
	RateLimitConfigStatus_ACCEPTED RateLimitConfigStatus_State = 1
	RateLimitConfigStatus_REJECTED RateLimitConfigStatus_State = 2
)

var RateLimitConfigStatus_State_name = map[int32]string{
	0: "PENDING",
	1: "ACCEPTED",
	2: "REJECTED",
}

var RateLimitConfigStatus_State_value = map[string]int32{
	"PENDING":  0,
	"ACCEPTED": 1,
	"REJECTED": 2,
}

func (x RateLimitConfigStatus_State) String() string {
	return proto.EnumName(RateLimitConfigStatus_State_name, int32(x))
}

func (RateLimitConfigStatus_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{1, 0}
}

type RateLimit_Unit int32

const (
	RateLimit_UNKNOWN RateLimit_Unit = 0
	RateLimit_SECOND  RateLimit_Unit = 1
	RateLimit_MINUTE  RateLimit_Unit = 2
	RateLimit_HOUR    RateLimit_Unit = 3
	RateLimit_DAY     RateLimit_Unit = 4
)

var RateLimit_Unit_name = map[int32]string{
	0: "UNKNOWN",
	1: "SECOND",
	2: "MINUTE",
	3: "HOUR",
	4: "DAY",
}

var RateLimit_Unit_value = map[string]int32{
	"UNKNOWN": 0,
	"SECOND":  1,
	"MINUTE":  2,
	"HOUR":    3,
	"DAY":     4,
}

func (x RateLimit_Unit) String() string {
	return proto.EnumName(RateLimit_Unit_name, int32(x))
}

func (RateLimit_Unit) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{4, 0}
}

// A `RateLimitConfig` describes a rate limit policy.
type RateLimitConfigSpec struct {
	// Each `RateLimitConfig` is an instance of one specific configuration type.
	// Currently, only raw configuration is supported, but going forward we are planning on adding
	// more high-level configuration formats to support specific use cases.
	//
	// Types that are valid to be assigned to ConfigType:
	//	*RateLimitConfigSpec_Raw_
	ConfigType           isRateLimitConfigSpec_ConfigType `protobuf_oneof:"config_type"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *RateLimitConfigSpec) Reset()         { *m = RateLimitConfigSpec{} }
func (m *RateLimitConfigSpec) String() string { return proto.CompactTextString(m) }
func (*RateLimitConfigSpec) ProtoMessage()    {}
func (*RateLimitConfigSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{0}
}
func (m *RateLimitConfigSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RateLimitConfigSpec.Unmarshal(m, b)
}
func (m *RateLimitConfigSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RateLimitConfigSpec.Marshal(b, m, deterministic)
}
func (m *RateLimitConfigSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitConfigSpec.Merge(m, src)
}
func (m *RateLimitConfigSpec) XXX_Size() int {
	return xxx_messageInfo_RateLimitConfigSpec.Size(m)
}
func (m *RateLimitConfigSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitConfigSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitConfigSpec proto.InternalMessageInfo

type isRateLimitConfigSpec_ConfigType interface {
	isRateLimitConfigSpec_ConfigType()
	Equal(interface{}) bool
}

type RateLimitConfigSpec_Raw_ struct {
	Raw *RateLimitConfigSpec_Raw `protobuf:"bytes,1,opt,name=raw,proto3,oneof" json:"raw,omitempty"`
}

func (*RateLimitConfigSpec_Raw_) isRateLimitConfigSpec_ConfigType() {}

func (m *RateLimitConfigSpec) GetConfigType() isRateLimitConfigSpec_ConfigType {
	if m != nil {
		return m.ConfigType
	}
	return nil
}

func (m *RateLimitConfigSpec) GetRaw() *RateLimitConfigSpec_Raw {
	if x, ok := m.GetConfigType().(*RateLimitConfigSpec_Raw_); ok {
		return x.Raw
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RateLimitConfigSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RateLimitConfigSpec_Raw_)(nil),
	}
}

// This object allows users to specify rate limit policies using the raw configuration formats
// used by the server and the client (Envoy). When using this configuration type, it is up to
// the user to ensure that server and client configurations match to implement the desired behavior.
// The server (and the client libraries that are shipped with it) will ensure that there are no
// collisions between raw configurations defined on separate `RateLimitConfig` resources.
type RateLimitConfigSpec_Raw struct {
	// The descriptors that will be applied to the server.
	Descriptors []*Descriptor `protobuf:"bytes,1,rep,name=descriptors,proto3" json:"descriptors,omitempty"`
	// Actions specify how the client (Envoy) will compose the descriptors that
	// will be sent to the server to make a rate limiting decision.
	RateLimits           []*RateLimitActions `protobuf:"bytes,2,rep,name=rate_limits,json=rateLimits,proto3" json:"rate_limits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RateLimitConfigSpec_Raw) Reset()         { *m = RateLimitConfigSpec_Raw{} }
func (m *RateLimitConfigSpec_Raw) String() string { return proto.CompactTextString(m) }
func (*RateLimitConfigSpec_Raw) ProtoMessage()    {}
func (*RateLimitConfigSpec_Raw) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{0, 0}
}
func (m *RateLimitConfigSpec_Raw) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RateLimitConfigSpec_Raw.Unmarshal(m, b)
}
func (m *RateLimitConfigSpec_Raw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RateLimitConfigSpec_Raw.Marshal(b, m, deterministic)
}
func (m *RateLimitConfigSpec_Raw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitConfigSpec_Raw.Merge(m, src)
}
func (m *RateLimitConfigSpec_Raw) XXX_Size() int {
	return xxx_messageInfo_RateLimitConfigSpec_Raw.Size(m)
}
func (m *RateLimitConfigSpec_Raw) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitConfigSpec_Raw.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitConfigSpec_Raw proto.InternalMessageInfo

func (m *RateLimitConfigSpec_Raw) GetDescriptors() []*Descriptor {
	if m != nil {
		return m.Descriptors
	}
	return nil
}

func (m *RateLimitConfigSpec_Raw) GetRateLimits() []*RateLimitActions {
	if m != nil {
		return m.RateLimits
	}
	return nil
}

// The current status of the `RateLimitConfig`.
type RateLimitConfigStatus struct {
	// The current state of the `RateLimitConfig`.
	State RateLimitConfigStatus_State `protobuf:"varint,1,opt,name=state,proto3,enum=ratelimit.api.solo.io.RateLimitConfigStatus_State" json:"state,omitempty"`
	// A human-readable string explaining the status.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// The observed generation of the resource.
	// When this matches the metadata.generation of the resource, it indicates the status is up-to-date.
	ObservedGeneration   int64    `protobuf:"varint,3,opt,name=observed_generation,json=observedGeneration,proto3" json:"observed_generation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RateLimitConfigStatus) Reset()         { *m = RateLimitConfigStatus{} }
func (m *RateLimitConfigStatus) String() string { return proto.CompactTextString(m) }
func (*RateLimitConfigStatus) ProtoMessage()    {}
func (*RateLimitConfigStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{1}
}
func (m *RateLimitConfigStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RateLimitConfigStatus.Unmarshal(m, b)
}
func (m *RateLimitConfigStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RateLimitConfigStatus.Marshal(b, m, deterministic)
}
func (m *RateLimitConfigStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitConfigStatus.Merge(m, src)
}
func (m *RateLimitConfigStatus) XXX_Size() int {
	return xxx_messageInfo_RateLimitConfigStatus.Size(m)
}
func (m *RateLimitConfigStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitConfigStatus.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitConfigStatus proto.InternalMessageInfo

func (m *RateLimitConfigStatus) GetState() RateLimitConfigStatus_State {
	if m != nil {
		return m.State
	}
	return RateLimitConfigStatus_PENDING
}

func (m *RateLimitConfigStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *RateLimitConfigStatus) GetObservedGeneration() int64 {
	if m != nil {
		return m.ObservedGeneration
	}
	return 0
}

// A descriptor is a list of key/value pairs that the rate limit server uses to select
// the correct rate limit to use when limiting. Descriptors are case-sensitive.
//
// Each configuration contains a top level descriptor list and potentially multiple nested lists beneath that.
// The format is:
//
// ```yaml
// descriptors:
//   - key: <rule key: required>
//     value: <rule value: optional>
//     rate_limit: (optional block)
//       unit: <see below: required>
//       requests_per_unit: <see below: required>
//     descriptors: (optional block)
//       - ... (nested repetition of above)
// ```
//
// Each descriptor in a descriptor list must have a key. It can also optionally have a value to enable
// a more specific match. The `rate_limit` block is optional and, if present, sets up an actual rate limit rule.
// If the rate limit is not present and there are no nested descriptors, then the descriptor is effectively whitelisted.
// Otherwise, nested descriptors allow more complex matching and rate limiting scenarios.
type Descriptor struct {
	// The key of the descriptor. Ths field is required.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Optional value for the descriptor. If omitted, the server will create a rate limit for
	// each value that is provided for this descriptor in rate limit requests.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Optional rate limit rule for the descriptor.
	RateLimit *RateLimit `protobuf:"bytes,3,opt,name=rate_limit,json=rateLimit,proto3" json:"rate_limit,omitempty"`
	// Nested descriptors.
	Descriptors []*Descriptor `protobuf:"bytes,4,rep,name=descriptors,proto3" json:"descriptors,omitempty"`
	// Each top-level Descriptor defines a new Rate Limit "rule". When a request comes in, rate limit
	// actions are applied to the request to generate descriptor tuples that are sent to the rate limit
	// server. If any rule is triggered then the entire request returns HTTP 429 Too Many Requests.
	//
	// Typically, rule priority is signalled by nesting descriptors, as the most specific rule match for
	// the descriptor tuple generated by the rate limit actions is used. In rare cases this is too restrictive;
	// instead you can set rule priority by setting weights on your descriptors.
	//
	// All rules with the highest weight are processed, if any of these rules trigger rate limiting then the
	// entire request will return a 429. Rules that are not considered for rate limiting are ignored in the
	// rate limit server, and their request count is not incremented in the rate limit server cache.
	//
	// Defaults to 0; thus all rules are evaluated by default.
	Weight uint32 `protobuf:"varint,5,opt,name=weight,proto3" json:"weight,omitempty"`
	// A boolean override for rule priority via weighted rules. Any rule with `alwaysApply` set to `true` will
	// always be considered for rate limiting, regardless of the rule's weight. The rule with the highest weight
	// will still be considered. (this can be a rule that also has `alwaysApply` set to `true`)
	//
	// Defaults to false.
	AlwaysApply          bool     `protobuf:"varint,6,opt,name=always_apply,json=alwaysApply,proto3" json:"always_apply,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Descriptor) Reset()         { *m = Descriptor{} }
func (m *Descriptor) String() string { return proto.CompactTextString(m) }
func (*Descriptor) ProtoMessage()    {}
func (*Descriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{2}
}
func (m *Descriptor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Descriptor.Unmarshal(m, b)
}
func (m *Descriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Descriptor.Marshal(b, m, deterministic)
}
func (m *Descriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Descriptor.Merge(m, src)
}
func (m *Descriptor) XXX_Size() int {
	return xxx_messageInfo_Descriptor.Size(m)
}
func (m *Descriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_Descriptor.DiscardUnknown(m)
}

var xxx_messageInfo_Descriptor proto.InternalMessageInfo

func (m *Descriptor) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Descriptor) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Descriptor) GetRateLimit() *RateLimit {
	if m != nil {
		return m.RateLimit
	}
	return nil
}

func (m *Descriptor) GetDescriptors() []*Descriptor {
	if m != nil {
		return m.Descriptors
	}
	return nil
}

func (m *Descriptor) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *Descriptor) GetAlwaysApply() bool {
	if m != nil {
		return m.AlwaysApply
	}
	return false
}

// Each action in the list maps part of the request (or its context) to a descriptor. The tuple of descriptors
// generated by the provided actions is sent to the rate limit server and matched against rate limit rules.
// Order matters on the provided actions, e.g. the following actions:
// - actions:
//   - requestHeaders:
//      descriptorKey: account_id
//      headerName: x-account-id
//   - requestHeaders:
//      descriptorKey: plan
//      headerName: x-plan
// define an ordered descriptor tuple like so: ('account_id', '<x-account-id value>'), ('plan', '<x-plan value>')
//
// While the current form matches, the same tuple in reverse order would not match the following descriptor:
//
// descriptors:
// - key: account_id
//   descriptors:
//   - key: plan
//     value: BASIC
//     rateLimit:
//       requestsPerUnit: 1
//       unit: MINUTE
//  - key: plan
//    value: PLUS
//    rateLimit:
//      requestsPerUnit: 20
//      unit: MINUTE
type RateLimitActions struct {
	Actions              []*Action `protobuf:"bytes,1,rep,name=actions,proto3" json:"actions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RateLimitActions) Reset()         { *m = RateLimitActions{} }
func (m *RateLimitActions) String() string { return proto.CompactTextString(m) }
func (*RateLimitActions) ProtoMessage()    {}
func (*RateLimitActions) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{3}
}
func (m *RateLimitActions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RateLimitActions.Unmarshal(m, b)
}
func (m *RateLimitActions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RateLimitActions.Marshal(b, m, deterministic)
}
func (m *RateLimitActions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitActions.Merge(m, src)
}
func (m *RateLimitActions) XXX_Size() int {
	return xxx_messageInfo_RateLimitActions.Size(m)
}
func (m *RateLimitActions) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitActions.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitActions proto.InternalMessageInfo

func (m *RateLimitActions) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

// A `RateLimit` specifies the actual rate limit that will be used when there is a match.
type RateLimit struct {
	Unit                 RateLimit_Unit `protobuf:"varint,1,opt,name=unit,proto3,enum=ratelimit.api.solo.io.RateLimit_Unit" json:"unit,omitempty"`
	RequestsPerUnit      uint32         `protobuf:"varint,2,opt,name=requests_per_unit,json=requestsPerUnit,proto3" json:"requests_per_unit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *RateLimit) Reset()         { *m = RateLimit{} }
func (m *RateLimit) String() string { return proto.CompactTextString(m) }
func (*RateLimit) ProtoMessage()    {}
func (*RateLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{4}
}
func (m *RateLimit) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RateLimit.Unmarshal(m, b)
}
func (m *RateLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RateLimit.Marshal(b, m, deterministic)
}
func (m *RateLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit.Merge(m, src)
}
func (m *RateLimit) XXX_Size() int {
	return xxx_messageInfo_RateLimit.Size(m)
}
func (m *RateLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit proto.InternalMessageInfo

func (m *RateLimit) GetUnit() RateLimit_Unit {
	if m != nil {
		return m.Unit
	}
	return RateLimit_UNKNOWN
}

func (m *RateLimit) GetRequestsPerUnit() uint32 {
	if m != nil {
		return m.RequestsPerUnit
	}
	return 0
}

// Copied directly from envoy
// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-msg-config-route-v3-ratelimit-action
type Action struct {
	// Types that are valid to be assigned to ActionSpecifier:
	//	*Action_SourceCluster_
	//	*Action_DestinationCluster_
	//	*Action_RequestHeaders_
	//	*Action_RemoteAddress_
	//	*Action_GenericKey_
	//	*Action_HeaderValueMatch_
	ActionSpecifier      isAction_ActionSpecifier `protobuf_oneof:"action_specifier"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Action) Reset()         { *m = Action{} }
func (m *Action) String() string { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()    {}
func (*Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{5}
}
func (m *Action) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action.Unmarshal(m, b)
}
func (m *Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action.Marshal(b, m, deterministic)
}
func (m *Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action.Merge(m, src)
}
func (m *Action) XXX_Size() int {
	return xxx_messageInfo_Action.Size(m)
}
func (m *Action) XXX_DiscardUnknown() {
	xxx_messageInfo_Action.DiscardUnknown(m)
}

var xxx_messageInfo_Action proto.InternalMessageInfo

type isAction_ActionSpecifier interface {
	isAction_ActionSpecifier()
	Equal(interface{}) bool
}

type Action_SourceCluster_ struct {
	SourceCluster *Action_SourceCluster `protobuf:"bytes,1,opt,name=source_cluster,json=sourceCluster,proto3,oneof" json:"source_cluster,omitempty"`
}
type Action_DestinationCluster_ struct {
	DestinationCluster *Action_DestinationCluster `protobuf:"bytes,2,opt,name=destination_cluster,json=destinationCluster,proto3,oneof" json:"destination_cluster,omitempty"`
}
type Action_RequestHeaders_ struct {
	RequestHeaders *Action_RequestHeaders `protobuf:"bytes,3,opt,name=request_headers,json=requestHeaders,proto3,oneof" json:"request_headers,omitempty"`
}
type Action_RemoteAddress_ struct {
	RemoteAddress *Action_RemoteAddress `protobuf:"bytes,4,opt,name=remote_address,json=remoteAddress,proto3,oneof" json:"remote_address,omitempty"`
}
type Action_GenericKey_ struct {
	GenericKey *Action_GenericKey `protobuf:"bytes,5,opt,name=generic_key,json=genericKey,proto3,oneof" json:"generic_key,omitempty"`
}
type Action_HeaderValueMatch_ struct {
	HeaderValueMatch *Action_HeaderValueMatch `protobuf:"bytes,6,opt,name=header_value_match,json=headerValueMatch,proto3,oneof" json:"header_value_match,omitempty"`
}

func (*Action_SourceCluster_) isAction_ActionSpecifier()      {}
func (*Action_DestinationCluster_) isAction_ActionSpecifier() {}
func (*Action_RequestHeaders_) isAction_ActionSpecifier()     {}
func (*Action_RemoteAddress_) isAction_ActionSpecifier()      {}
func (*Action_GenericKey_) isAction_ActionSpecifier()         {}
func (*Action_HeaderValueMatch_) isAction_ActionSpecifier()   {}

func (m *Action) GetActionSpecifier() isAction_ActionSpecifier {
	if m != nil {
		return m.ActionSpecifier
	}
	return nil
}

func (m *Action) GetSourceCluster() *Action_SourceCluster {
	if x, ok := m.GetActionSpecifier().(*Action_SourceCluster_); ok {
		return x.SourceCluster
	}
	return nil
}

func (m *Action) GetDestinationCluster() *Action_DestinationCluster {
	if x, ok := m.GetActionSpecifier().(*Action_DestinationCluster_); ok {
		return x.DestinationCluster
	}
	return nil
}

func (m *Action) GetRequestHeaders() *Action_RequestHeaders {
	if x, ok := m.GetActionSpecifier().(*Action_RequestHeaders_); ok {
		return x.RequestHeaders
	}
	return nil
}

func (m *Action) GetRemoteAddress() *Action_RemoteAddress {
	if x, ok := m.GetActionSpecifier().(*Action_RemoteAddress_); ok {
		return x.RemoteAddress
	}
	return nil
}

func (m *Action) GetGenericKey() *Action_GenericKey {
	if x, ok := m.GetActionSpecifier().(*Action_GenericKey_); ok {
		return x.GenericKey
	}
	return nil
}

func (m *Action) GetHeaderValueMatch() *Action_HeaderValueMatch {
	if x, ok := m.GetActionSpecifier().(*Action_HeaderValueMatch_); ok {
		return x.HeaderValueMatch
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Action) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Action_SourceCluster_)(nil),
		(*Action_DestinationCluster_)(nil),
		(*Action_RequestHeaders_)(nil),
		(*Action_RemoteAddress_)(nil),
		(*Action_GenericKey_)(nil),
		(*Action_HeaderValueMatch_)(nil),
	}
}

// The following descriptor entry is appended to the descriptor:
//
// ```
//   ("source_cluster", "<local service cluster>")
// ```
//
// <local service cluster> is derived from the :option:`--service-cluster` option.
type Action_SourceCluster struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Action_SourceCluster) Reset()         { *m = Action_SourceCluster{} }
func (m *Action_SourceCluster) String() string { return proto.CompactTextString(m) }
func (*Action_SourceCluster) ProtoMessage()    {}
func (*Action_SourceCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{5, 0}
}
func (m *Action_SourceCluster) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action_SourceCluster.Unmarshal(m, b)
}
func (m *Action_SourceCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action_SourceCluster.Marshal(b, m, deterministic)
}
func (m *Action_SourceCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action_SourceCluster.Merge(m, src)
}
func (m *Action_SourceCluster) XXX_Size() int {
	return xxx_messageInfo_Action_SourceCluster.Size(m)
}
func (m *Action_SourceCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Action_SourceCluster.DiscardUnknown(m)
}

var xxx_messageInfo_Action_SourceCluster proto.InternalMessageInfo

// The following descriptor entry is appended to the descriptor:
//
// ```
//   ("destination_cluster", "<routed target cluster>")
// ```
//
// Once a request matches against a route table rule, a routed cluster is determined by one of
// the following `route table configuration (envoy_api_msg_RouteConfiguration)`
// settings:
//
// * `cluster (envoy_api_field_route.RouteAction.cluster)` indicates the upstream cluster
//   to route to.
// * `weighted_clusters (envoy_api_field_route.RouteAction.weighted_clusters)`
//   chooses a cluster randomly from a set of clusters with attributed weight.
// * `cluster_header (envoy_api_field_route.RouteAction.cluster_header)` indicates which
//   header in the request contains the target cluster.
type Action_DestinationCluster struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Action_DestinationCluster) Reset()         { *m = Action_DestinationCluster{} }
func (m *Action_DestinationCluster) String() string { return proto.CompactTextString(m) }
func (*Action_DestinationCluster) ProtoMessage()    {}
func (*Action_DestinationCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{5, 1}
}
func (m *Action_DestinationCluster) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action_DestinationCluster.Unmarshal(m, b)
}
func (m *Action_DestinationCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action_DestinationCluster.Marshal(b, m, deterministic)
}
func (m *Action_DestinationCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action_DestinationCluster.Merge(m, src)
}
func (m *Action_DestinationCluster) XXX_Size() int {
	return xxx_messageInfo_Action_DestinationCluster.Size(m)
}
func (m *Action_DestinationCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Action_DestinationCluster.DiscardUnknown(m)
}

var xxx_messageInfo_Action_DestinationCluster proto.InternalMessageInfo

// The following descriptor entry is appended when a header contains a key that matches the
// *header_name*:
//
// ```
//   ("<descriptor_key>", "<header_value_queried_from_header>")
// ```
type Action_RequestHeaders struct {
	// The header name to be queried from the request headers. The header’s
	// value is used to populate the value of the descriptor entry for the
	// descriptor_key.
	HeaderName string `protobuf:"bytes,1,opt,name=header_name,json=headerName,proto3" json:"header_name,omitempty"`
	// The key to use in the descriptor entry.
	DescriptorKey        string   `protobuf:"bytes,2,opt,name=descriptor_key,json=descriptorKey,proto3" json:"descriptor_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Action_RequestHeaders) Reset()         { *m = Action_RequestHeaders{} }
func (m *Action_RequestHeaders) String() string { return proto.CompactTextString(m) }
func (*Action_RequestHeaders) ProtoMessage()    {}
func (*Action_RequestHeaders) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{5, 2}
}
func (m *Action_RequestHeaders) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action_RequestHeaders.Unmarshal(m, b)
}
func (m *Action_RequestHeaders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action_RequestHeaders.Marshal(b, m, deterministic)
}
func (m *Action_RequestHeaders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action_RequestHeaders.Merge(m, src)
}
func (m *Action_RequestHeaders) XXX_Size() int {
	return xxx_messageInfo_Action_RequestHeaders.Size(m)
}
func (m *Action_RequestHeaders) XXX_DiscardUnknown() {
	xxx_messageInfo_Action_RequestHeaders.DiscardUnknown(m)
}

var xxx_messageInfo_Action_RequestHeaders proto.InternalMessageInfo

func (m *Action_RequestHeaders) GetHeaderName() string {
	if m != nil {
		return m.HeaderName
	}
	return ""
}

func (m *Action_RequestHeaders) GetDescriptorKey() string {
	if m != nil {
		return m.DescriptorKey
	}
	return ""
}

// The following descriptor entry is appended to the descriptor and is populated using the
// trusted address from `x-forwarded-for (config_http_conn_man_headers_x-forwarded-for)`:
//
// ```
//   ("remote_address", "<trusted address from x-forwarded-for>")
// ```
type Action_RemoteAddress struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Action_RemoteAddress) Reset()         { *m = Action_RemoteAddress{} }
func (m *Action_RemoteAddress) String() string { return proto.CompactTextString(m) }
func (*Action_RemoteAddress) ProtoMessage()    {}
func (*Action_RemoteAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{5, 3}
}
func (m *Action_RemoteAddress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action_RemoteAddress.Unmarshal(m, b)
}
func (m *Action_RemoteAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action_RemoteAddress.Marshal(b, m, deterministic)
}
func (m *Action_RemoteAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action_RemoteAddress.Merge(m, src)
}
func (m *Action_RemoteAddress) XXX_Size() int {
	return xxx_messageInfo_Action_RemoteAddress.Size(m)
}
func (m *Action_RemoteAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_Action_RemoteAddress.DiscardUnknown(m)
}

var xxx_messageInfo_Action_RemoteAddress proto.InternalMessageInfo

// The following descriptor entry is appended to the descriptor:
//
// ```
//   ("generic_key", "<descriptor_value>")
// ```
type Action_GenericKey struct {
	// The value to use in the descriptor entry.
	DescriptorValue      string   `protobuf:"bytes,1,opt,name=descriptor_value,json=descriptorValue,proto3" json:"descriptor_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Action_GenericKey) Reset()         { *m = Action_GenericKey{} }
func (m *Action_GenericKey) String() string { return proto.CompactTextString(m) }
func (*Action_GenericKey) ProtoMessage()    {}
func (*Action_GenericKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{5, 4}
}
func (m *Action_GenericKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action_GenericKey.Unmarshal(m, b)
}
func (m *Action_GenericKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action_GenericKey.Marshal(b, m, deterministic)
}
func (m *Action_GenericKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action_GenericKey.Merge(m, src)
}
func (m *Action_GenericKey) XXX_Size() int {
	return xxx_messageInfo_Action_GenericKey.Size(m)
}
func (m *Action_GenericKey) XXX_DiscardUnknown() {
	xxx_messageInfo_Action_GenericKey.DiscardUnknown(m)
}

var xxx_messageInfo_Action_GenericKey proto.InternalMessageInfo

func (m *Action_GenericKey) GetDescriptorValue() string {
	if m != nil {
		return m.DescriptorValue
	}
	return ""
}

// The following descriptor entry is appended to the descriptor:
//
// ```
//   ("header_match", "<descriptor_value>")
// ```
type Action_HeaderValueMatch struct {
	// The value to use in the descriptor entry.
	DescriptorValue string `protobuf:"bytes,1,opt,name=descriptor_value,json=descriptorValue,proto3" json:"descriptor_value,omitempty"`
	// If set to true, the action will append a descriptor entry when the
	// request matches the headers. If set to false, the action will append a
	// descriptor entry when the request does not match the headers. The
	// default value is true.
	ExpectMatch *types.BoolValue `protobuf:"bytes,2,opt,name=expect_match,json=expectMatch,proto3" json:"expect_match,omitempty"`
	// Specifies a set of headers that the rate limit action should match
	// on. The action will check the request’s headers against all the
	// specified headers in the config. A match will happen if all the
	// headers in the config are present in the request with the same values
	// (or based on presence if the value field is not in the config).
	Headers              []*Action_HeaderValueMatch_HeaderMatcher `protobuf:"bytes,3,rep,name=headers,proto3" json:"headers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *Action_HeaderValueMatch) Reset()         { *m = Action_HeaderValueMatch{} }
func (m *Action_HeaderValueMatch) String() string { return proto.CompactTextString(m) }
func (*Action_HeaderValueMatch) ProtoMessage()    {}
func (*Action_HeaderValueMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{5, 5}
}
func (m *Action_HeaderValueMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action_HeaderValueMatch.Unmarshal(m, b)
}
func (m *Action_HeaderValueMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action_HeaderValueMatch.Marshal(b, m, deterministic)
}
func (m *Action_HeaderValueMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action_HeaderValueMatch.Merge(m, src)
}
func (m *Action_HeaderValueMatch) XXX_Size() int {
	return xxx_messageInfo_Action_HeaderValueMatch.Size(m)
}
func (m *Action_HeaderValueMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_Action_HeaderValueMatch.DiscardUnknown(m)
}

var xxx_messageInfo_Action_HeaderValueMatch proto.InternalMessageInfo

func (m *Action_HeaderValueMatch) GetDescriptorValue() string {
	if m != nil {
		return m.DescriptorValue
	}
	return ""
}

func (m *Action_HeaderValueMatch) GetExpectMatch() *types.BoolValue {
	if m != nil {
		return m.ExpectMatch
	}
	return nil
}

func (m *Action_HeaderValueMatch) GetHeaders() []*Action_HeaderValueMatch_HeaderMatcher {
	if m != nil {
		return m.Headers
	}
	return nil
}

type Action_HeaderValueMatch_HeaderMatcher struct {
	// Specifies the name of the header in the request.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Specifies how the header match will be performed to route the request.
	//
	// Types that are valid to be assigned to HeaderMatchSpecifier:
	//	*Action_HeaderValueMatch_HeaderMatcher_ExactMatch
	//	*Action_HeaderValueMatch_HeaderMatcher_RegexMatch
	//	*Action_HeaderValueMatch_HeaderMatcher_RangeMatch
	//	*Action_HeaderValueMatch_HeaderMatcher_PresentMatch
	//	*Action_HeaderValueMatch_HeaderMatcher_PrefixMatch
	//	*Action_HeaderValueMatch_HeaderMatcher_SuffixMatch
	HeaderMatchSpecifier isAction_HeaderValueMatch_HeaderMatcher_HeaderMatchSpecifier `protobuf_oneof:"header_match_specifier"`
	// If specified, the match result will be inverted before checking. Defaults to false.
	//
	// Examples:
	//
	// * The regex *\d{3}* does not match the value *1234*, so it will match when inverted.
	// * The range [-10,0) will match the value -1, so it will not match when inverted.
	InvertMatch          bool     `protobuf:"varint,8,opt,name=invert_match,json=invertMatch,proto3" json:"invert_match,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Action_HeaderValueMatch_HeaderMatcher) Reset()         { *m = Action_HeaderValueMatch_HeaderMatcher{} }
func (m *Action_HeaderValueMatch_HeaderMatcher) String() string { return proto.CompactTextString(m) }
func (*Action_HeaderValueMatch_HeaderMatcher) ProtoMessage()    {}
func (*Action_HeaderValueMatch_HeaderMatcher) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{5, 5, 0}
}
func (m *Action_HeaderValueMatch_HeaderMatcher) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action_HeaderValueMatch_HeaderMatcher.Unmarshal(m, b)
}
func (m *Action_HeaderValueMatch_HeaderMatcher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action_HeaderValueMatch_HeaderMatcher.Marshal(b, m, deterministic)
}
func (m *Action_HeaderValueMatch_HeaderMatcher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action_HeaderValueMatch_HeaderMatcher.Merge(m, src)
}
func (m *Action_HeaderValueMatch_HeaderMatcher) XXX_Size() int {
	return xxx_messageInfo_Action_HeaderValueMatch_HeaderMatcher.Size(m)
}
func (m *Action_HeaderValueMatch_HeaderMatcher) XXX_DiscardUnknown() {
	xxx_messageInfo_Action_HeaderValueMatch_HeaderMatcher.DiscardUnknown(m)
}

var xxx_messageInfo_Action_HeaderValueMatch_HeaderMatcher proto.InternalMessageInfo

type isAction_HeaderValueMatch_HeaderMatcher_HeaderMatchSpecifier interface {
	isAction_HeaderValueMatch_HeaderMatcher_HeaderMatchSpecifier()
	Equal(interface{}) bool
}

type Action_HeaderValueMatch_HeaderMatcher_ExactMatch struct {
	ExactMatch string `protobuf:"bytes,4,opt,name=exact_match,json=exactMatch,proto3,oneof" json:"exact_match,omitempty"`
}
type Action_HeaderValueMatch_HeaderMatcher_RegexMatch struct {
	RegexMatch string `protobuf:"bytes,5,opt,name=regex_match,json=regexMatch,proto3,oneof" json:"regex_match,omitempty"`
}
type Action_HeaderValueMatch_HeaderMatcher_RangeMatch struct {
	RangeMatch *Action_HeaderValueMatch_HeaderMatcher_Int64Range `protobuf:"bytes,6,opt,name=range_match,json=rangeMatch,proto3,oneof" json:"range_match,omitempty"`
}
type Action_HeaderValueMatch_HeaderMatcher_PresentMatch struct {
	PresentMatch bool `protobuf:"varint,7,opt,name=present_match,json=presentMatch,proto3,oneof" json:"present_match,omitempty"`
}
type Action_HeaderValueMatch_HeaderMatcher_PrefixMatch struct {
	PrefixMatch string `protobuf:"bytes,9,opt,name=prefix_match,json=prefixMatch,proto3,oneof" json:"prefix_match,omitempty"`
}
type Action_HeaderValueMatch_HeaderMatcher_SuffixMatch struct {
	SuffixMatch string `protobuf:"bytes,10,opt,name=suffix_match,json=suffixMatch,proto3,oneof" json:"suffix_match,omitempty"`
}

func (*Action_HeaderValueMatch_HeaderMatcher_ExactMatch) isAction_HeaderValueMatch_HeaderMatcher_HeaderMatchSpecifier() {
}
func (*Action_HeaderValueMatch_HeaderMatcher_RegexMatch) isAction_HeaderValueMatch_HeaderMatcher_HeaderMatchSpecifier() {
}
func (*Action_HeaderValueMatch_HeaderMatcher_RangeMatch) isAction_HeaderValueMatch_HeaderMatcher_HeaderMatchSpecifier() {
}
func (*Action_HeaderValueMatch_HeaderMatcher_PresentMatch) isAction_HeaderValueMatch_HeaderMatcher_HeaderMatchSpecifier() {
}
func (*Action_HeaderValueMatch_HeaderMatcher_PrefixMatch) isAction_HeaderValueMatch_HeaderMatcher_HeaderMatchSpecifier() {
}
func (*Action_HeaderValueMatch_HeaderMatcher_SuffixMatch) isAction_HeaderValueMatch_HeaderMatcher_HeaderMatchSpecifier() {
}

func (m *Action_HeaderValueMatch_HeaderMatcher) GetHeaderMatchSpecifier() isAction_HeaderValueMatch_HeaderMatcher_HeaderMatchSpecifier {
	if m != nil {
		return m.HeaderMatchSpecifier
	}
	return nil
}

func (m *Action_HeaderValueMatch_HeaderMatcher) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Action_HeaderValueMatch_HeaderMatcher) GetExactMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*Action_HeaderValueMatch_HeaderMatcher_ExactMatch); ok {
		return x.ExactMatch
	}
	return ""
}

func (m *Action_HeaderValueMatch_HeaderMatcher) GetRegexMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*Action_HeaderValueMatch_HeaderMatcher_RegexMatch); ok {
		return x.RegexMatch
	}
	return ""
}

func (m *Action_HeaderValueMatch_HeaderMatcher) GetRangeMatch() *Action_HeaderValueMatch_HeaderMatcher_Int64Range {
	if x, ok := m.GetHeaderMatchSpecifier().(*Action_HeaderValueMatch_HeaderMatcher_RangeMatch); ok {
		return x.RangeMatch
	}
	return nil
}

func (m *Action_HeaderValueMatch_HeaderMatcher) GetPresentMatch() bool {
	if x, ok := m.GetHeaderMatchSpecifier().(*Action_HeaderValueMatch_HeaderMatcher_PresentMatch); ok {
		return x.PresentMatch
	}
	return false
}

func (m *Action_HeaderValueMatch_HeaderMatcher) GetPrefixMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*Action_HeaderValueMatch_HeaderMatcher_PrefixMatch); ok {
		return x.PrefixMatch
	}
	return ""
}

func (m *Action_HeaderValueMatch_HeaderMatcher) GetSuffixMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*Action_HeaderValueMatch_HeaderMatcher_SuffixMatch); ok {
		return x.SuffixMatch
	}
	return ""
}

func (m *Action_HeaderValueMatch_HeaderMatcher) GetInvertMatch() bool {
	if m != nil {
		return m.InvertMatch
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Action_HeaderValueMatch_HeaderMatcher) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Action_HeaderValueMatch_HeaderMatcher_ExactMatch)(nil),
		(*Action_HeaderValueMatch_HeaderMatcher_RegexMatch)(nil),
		(*Action_HeaderValueMatch_HeaderMatcher_RangeMatch)(nil),
		(*Action_HeaderValueMatch_HeaderMatcher_PresentMatch)(nil),
		(*Action_HeaderValueMatch_HeaderMatcher_PrefixMatch)(nil),
		(*Action_HeaderValueMatch_HeaderMatcher_SuffixMatch)(nil),
	}
}

// Specifies the int64 start and end of the range using half-open interval semantics [start,
// end).
type Action_HeaderValueMatch_HeaderMatcher_Int64Range struct {
	// start of the range (inclusive)
	Start int64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	// end of the range (exclusive)
	End                  int64    `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Action_HeaderValueMatch_HeaderMatcher_Int64Range) Reset() {
	*m = Action_HeaderValueMatch_HeaderMatcher_Int64Range{}
}
func (m *Action_HeaderValueMatch_HeaderMatcher_Int64Range) String() string {
	return proto.CompactTextString(m)
}
func (*Action_HeaderValueMatch_HeaderMatcher_Int64Range) ProtoMessage() {}
func (*Action_HeaderValueMatch_HeaderMatcher_Int64Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4c63a1091f3b44, []int{5, 5, 0, 0}
}
func (m *Action_HeaderValueMatch_HeaderMatcher_Int64Range) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action_HeaderValueMatch_HeaderMatcher_Int64Range.Unmarshal(m, b)
}
func (m *Action_HeaderValueMatch_HeaderMatcher_Int64Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action_HeaderValueMatch_HeaderMatcher_Int64Range.Marshal(b, m, deterministic)
}
func (m *Action_HeaderValueMatch_HeaderMatcher_Int64Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action_HeaderValueMatch_HeaderMatcher_Int64Range.Merge(m, src)
}
func (m *Action_HeaderValueMatch_HeaderMatcher_Int64Range) XXX_Size() int {
	return xxx_messageInfo_Action_HeaderValueMatch_HeaderMatcher_Int64Range.Size(m)
}
func (m *Action_HeaderValueMatch_HeaderMatcher_Int64Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Action_HeaderValueMatch_HeaderMatcher_Int64Range.DiscardUnknown(m)
}

var xxx_messageInfo_Action_HeaderValueMatch_HeaderMatcher_Int64Range proto.InternalMessageInfo

func (m *Action_HeaderValueMatch_HeaderMatcher_Int64Range) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Action_HeaderValueMatch_HeaderMatcher_Int64Range) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func init() {
	proto.RegisterEnum("ratelimit.api.solo.io.RateLimitConfigStatus_State", RateLimitConfigStatus_State_name, RateLimitConfigStatus_State_value)
	proto.RegisterEnum("ratelimit.api.solo.io.RateLimit_Unit", RateLimit_Unit_name, RateLimit_Unit_value)
	proto.RegisterType((*RateLimitConfigSpec)(nil), "ratelimit.api.solo.io.RateLimitConfigSpec")
	proto.RegisterType((*RateLimitConfigSpec_Raw)(nil), "ratelimit.api.solo.io.RateLimitConfigSpec.Raw")
	proto.RegisterType((*RateLimitConfigStatus)(nil), "ratelimit.api.solo.io.RateLimitConfigStatus")
	proto.RegisterType((*Descriptor)(nil), "ratelimit.api.solo.io.Descriptor")
	proto.RegisterType((*RateLimitActions)(nil), "ratelimit.api.solo.io.RateLimitActions")
	proto.RegisterType((*RateLimit)(nil), "ratelimit.api.solo.io.RateLimit")
	proto.RegisterType((*Action)(nil), "ratelimit.api.solo.io.Action")
	proto.RegisterType((*Action_SourceCluster)(nil), "ratelimit.api.solo.io.Action.SourceCluster")
	proto.RegisterType((*Action_DestinationCluster)(nil), "ratelimit.api.solo.io.Action.DestinationCluster")
	proto.RegisterType((*Action_RequestHeaders)(nil), "ratelimit.api.solo.io.Action.RequestHeaders")
	proto.RegisterType((*Action_RemoteAddress)(nil), "ratelimit.api.solo.io.Action.RemoteAddress")
	proto.RegisterType((*Action_GenericKey)(nil), "ratelimit.api.solo.io.Action.GenericKey")
	proto.RegisterType((*Action_HeaderValueMatch)(nil), "ratelimit.api.solo.io.Action.HeaderValueMatch")
	proto.RegisterType((*Action_HeaderValueMatch_HeaderMatcher)(nil), "ratelimit.api.solo.io.Action.HeaderValueMatch.HeaderMatcher")
	proto.RegisterType((*Action_HeaderValueMatch_HeaderMatcher_Int64Range)(nil), "ratelimit.api.solo.io.Action.HeaderValueMatch.HeaderMatcher.Int64Range")
}

func init() {
	proto.RegisterFile("github.com/solo-io/solo-apis/api/rate-limiter/v1alpha1/ratelimit.proto", fileDescriptor_bd4c63a1091f3b44)
}

var fileDescriptor_bd4c63a1091f3b44 = []byte{
	// 1135 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0x4d, 0x73, 0xdb, 0x44,
	0x18, 0xb6, 0x2c, 0x3b, 0x1f, 0xaf, 0xe2, 0x54, 0x6c, 0x3f, 0xc6, 0xe3, 0x19, 0x8a, 0x63, 0xa6,
	0x83, 0xf9, 0xa8, 0xdc, 0x86, 0x0e, 0x1d, 0x66, 0x80, 0x4e, 0xe2, 0x98, 0x38, 0x0d, 0x75, 0x3b,
	0xdb, 0xa6, 0x05, 0x0e, 0x68, 0x36, 0xf2, 0x1b, 0x45, 0xd4, 0x96, 0xc4, 0xee, 0x3a, 0x89, 0xff,
	0x07, 0x47, 0xb8, 0x73, 0xe6, 0xc4, 0x1f, 0xe0, 0x6f, 0x70, 0xe0, 0x3f, 0xf4, 0x0c, 0xb3, 0xbb,
	0x92, 0x15, 0xa7, 0x6d, 0xd2, 0xc2, 0x49, 0xbb, 0xcf, 0xbe, 0xcf, 0xb3, 0xef, 0xd7, 0xee, 0x0a,
	0xbe, 0x0e, 0x23, 0x79, 0x38, 0xd9, 0xf7, 0x82, 0x64, 0xdc, 0x11, 0xc9, 0x28, 0xb9, 0x19, 0x25,
	0xe6, 0xcb, 0xd2, 0x48, 0x74, 0x58, 0x1a, 0x75, 0x38, 0x93, 0x78, 0x73, 0x14, 0x8d, 0x23, 0x89,
	0xbc, 0x73, 0x74, 0x9b, 0x8d, 0xd2, 0x43, 0x76, 0x5b, 0xa3, 0x1a, 0xf4, 0x52, 0x9e, 0xc8, 0x84,
	0x5c, 0x2d, 0x00, 0x96, 0x46, 0x9e, 0x92, 0xf0, 0xa2, 0xa4, 0x71, 0x3d, 0x4c, 0x92, 0x70, 0x84,
	0x1d, 0x6d, 0xb4, 0x3f, 0x39, 0xe8, 0x1c, 0x73, 0x96, 0xa6, 0xc8, 0x85, 0xa1, 0x35, 0xae, 0x84,
	0x49, 0x98, 0xe8, 0x61, 0x47, 0x8d, 0x32, 0x94, 0xe0, 0x89, 0x34, 0x20, 0x9e, 0x64, 0x1b, 0xb4,
	0xfe, 0xb1, 0xe0, 0x32, 0x65, 0x12, 0xbf, 0x51, 0x7b, 0x74, 0x93, 0xf8, 0x20, 0x0a, 0x1f, 0xa7,
	0x18, 0x90, 0x4d, 0xb0, 0x39, 0x3b, 0xae, 0x5b, 0x4d, 0xab, 0xed, 0xac, 0x7b, 0xde, 0x2b, 0xdd,
	0xf0, 0x5e, 0x41, 0xf4, 0x28, 0x3b, 0xee, 0x97, 0xa8, 0x22, 0x37, 0x7e, 0xb6, 0xc0, 0xa6, 0xec,
	0x98, 0x74, 0xc1, 0x19, 0xa2, 0x08, 0x78, 0x94, 0xca, 0x84, 0x8b, 0xba, 0xd5, 0xb4, 0xdb, 0xce,
	0xfa, 0xda, 0x6b, 0x34, 0xb7, 0x66, 0x96, 0xf4, 0x34, 0x8b, 0xf4, 0xc1, 0x51, 0x04, 0x5f, 0x33,
	0x44, 0xbd, 0xac, 0x45, 0x3e, 0xb8, 0xc8, 0xb1, 0x8d, 0x40, 0x46, 0x49, 0x2c, 0x28, 0xf0, 0x1c,
	0x11, 0x9b, 0x35, 0x70, 0x02, 0xed, 0xaf, 0x2f, 0xa7, 0x29, 0xb6, 0xfe, 0xb2, 0xe0, 0xea, 0xd9,
	0x40, 0x24, 0x93, 0x13, 0xb5, 0x65, 0x55, 0x48, 0x26, 0x51, 0x67, 0x61, 0x75, 0x7d, 0xfd, 0x0d,
	0xb3, 0xa0, 0xc9, 0x9e, 0xfa, 0x20, 0x35, 0x02, 0xa4, 0x0e, 0x8b, 0x63, 0x14, 0x82, 0x85, 0x58,
	0x2f, 0x37, 0xad, 0xf6, 0x32, 0xcd, 0xa7, 0xa4, 0x03, 0x97, 0x93, 0x7d, 0x81, 0xfc, 0x08, 0x87,
	0x7e, 0x88, 0x31, 0x72, 0xa6, 0x1c, 0xae, 0xdb, 0x4d, 0xab, 0x6d, 0x53, 0x92, 0x2f, 0x6d, 0xcf,
	0x56, 0x5a, 0xb7, 0xa0, 0xaa, 0xa5, 0x89, 0x03, 0x8b, 0x8f, 0x7a, 0x83, 0xad, 0x9d, 0xc1, 0xb6,
	0x5b, 0x22, 0x2b, 0xb0, 0xb4, 0xd1, 0xed, 0xf6, 0x1e, 0x3d, 0xe9, 0x6d, 0xb9, 0x96, 0x9a, 0xd1,
	0xde, 0xfd, 0x5e, 0x57, 0xcd, 0xca, 0xad, 0x17, 0x16, 0x40, 0x91, 0x55, 0xe2, 0x82, 0xfd, 0x1c,
	0xa7, 0x3a, 0xa6, 0x65, 0xaa, 0x86, 0xe4, 0x0a, 0x54, 0x8f, 0xd8, 0x68, 0x92, 0xfb, 0x66, 0x26,
	0xe4, 0x1e, 0x40, 0x91, 0x70, 0xed, 0x90, 0xb3, 0xde, 0xbc, 0x28, 0x05, 0x74, 0x79, 0x96, 0xe8,
	0xb3, 0x65, 0xaf, 0xfc, 0xa7, 0xb2, 0x5f, 0x83, 0x85, 0x63, 0x8c, 0xc2, 0x43, 0x59, 0xaf, 0x36,
	0xad, 0x76, 0x8d, 0x66, 0x33, 0xb2, 0x06, 0x2b, 0x6c, 0x74, 0xcc, 0xa6, 0xc2, 0x67, 0x69, 0x3a,
	0x9a, 0xd6, 0x17, 0x9a, 0x56, 0x7b, 0x89, 0x3a, 0x06, 0xdb, 0x50, 0x50, 0x6b, 0x17, 0xdc, 0xb3,
	0x7d, 0x40, 0xee, 0xc2, 0x22, 0x33, 0xc3, 0xac, 0x0d, 0xdf, 0x7d, 0x8d, 0x3f, 0x86, 0x40, 0x73,
	0xeb, 0xd6, 0xef, 0x16, 0x2c, 0xcf, 0xd4, 0xc8, 0xe7, 0x50, 0x99, 0xc4, 0x91, 0xcc, 0x1a, 0xe3,
	0xc6, 0x45, 0x59, 0xf1, 0xf6, 0xe2, 0x48, 0x52, 0x4d, 0x21, 0x1f, 0xc1, 0x3b, 0x1c, 0x7f, 0x9a,
	0xa0, 0x90, 0xc2, 0x4f, 0x91, 0xfb, 0x5a, 0xa7, 0xac, 0x63, 0xbb, 0x94, 0x2f, 0x3c, 0x42, 0xae,
	0x18, 0xad, 0xaf, 0xa0, 0xa2, 0xbe, 0xaa, 0xd4, 0x7b, 0x83, 0xdd, 0xc1, 0xc3, 0x67, 0x03, 0xb7,
	0x44, 0x00, 0x16, 0x1e, 0xf7, 0xba, 0x0f, 0x07, 0xaa, 0xd0, 0x00, 0x0b, 0x0f, 0x76, 0x06, 0x7b,
	0x4f, 0x7a, 0x6e, 0x99, 0x2c, 0x41, 0xa5, 0xff, 0x70, 0x8f, 0xba, 0x36, 0x59, 0x04, 0x7b, 0x6b,
	0xe3, 0x3b, 0xb7, 0xd2, 0xfa, 0xd5, 0x81, 0x05, 0x13, 0x08, 0x79, 0x02, 0xab, 0x22, 0x99, 0xf0,
	0x00, 0xfd, 0x60, 0x34, 0x11, 0x12, 0x79, 0x76, 0xb4, 0x3f, 0x3e, 0x37, 0x7e, 0xef, 0xb1, 0xe6,
	0x74, 0x0d, 0xa5, 0x5f, 0xa2, 0x35, 0x71, 0x1a, 0x20, 0x01, 0x5c, 0x1e, 0xa2, 0x90, 0x51, 0xac,
	0x7b, 0x73, 0x26, 0x5d, 0xd6, 0xd2, 0xb7, 0xce, 0x97, 0xde, 0x2a, 0x88, 0x85, 0x3e, 0x19, 0xbe,
	0x84, 0x92, 0x67, 0x90, 0x27, 0xc6, 0x3f, 0x44, 0x36, 0x44, 0x2e, 0xb2, 0x6e, 0xfc, 0xe4, 0xfc,
	0x0d, 0xa8, 0x21, 0xf5, 0x0d, 0xa7, 0x5f, 0xa2, 0xab, 0x7c, 0x0e, 0x51, 0x39, 0xe1, 0x38, 0x4e,
	0x24, 0xfa, 0x6c, 0x38, 0xe4, 0x28, 0x54, 0x8f, 0xbe, 0x41, 0x4e, 0xa8, 0xe6, 0x6c, 0x18, 0x8a,
	0xca, 0x09, 0x3f, 0x0d, 0x90, 0x5d, 0x70, 0xf4, 0x41, 0x8e, 0x02, 0x5f, 0x9d, 0xb3, 0xaa, 0x96,
	0x6c, 0x9f, 0x2f, 0xb9, 0x6d, 0x08, 0xbb, 0x38, 0xed, 0x97, 0x28, 0x84, 0xb3, 0x19, 0xf9, 0x01,
	0x88, 0x89, 0xd9, 0xd7, 0x87, 0xd2, 0x1f, 0x33, 0x19, 0x1c, 0xea, 0x66, 0x7f, 0xfd, 0xad, 0x9c,
	0x69, 0x9a, 0x28, 0x9f, 0x2a, 0xda, 0x03, 0xc5, 0xea, 0x97, 0xa8, 0x7b, 0x78, 0x06, 0x6b, 0x5c,
	0x82, 0xda, 0x5c, 0x89, 0x1b, 0x57, 0x80, 0xbc, 0x5c, 0x98, 0xc6, 0xb7, 0xb0, 0x3a, 0x9f, 0x4d,
	0xf2, 0x1e, 0x38, 0x99, 0x63, 0x31, 0x1b, 0x63, 0x76, 0x9b, 0x80, 0x81, 0x06, 0x6c, 0x8c, 0xe4,
	0x06, 0xac, 0x16, 0xe7, 0x58, 0x67, 0xc2, 0xdc, 0x2e, 0xb5, 0x02, 0xdd, 0xc5, 0xa9, 0x72, 0x60,
	0x2e, 0x9f, 0x8d, 0xbb, 0x00, 0x45, 0x36, 0xc8, 0x87, 0xe0, 0x9e, 0x52, 0x31, 0xb7, 0x94, 0xd9,
	0xeb, 0x52, 0x81, 0xeb, 0x78, 0x1a, 0xbf, 0x54, 0xc1, 0x3d, 0x1b, 0xf3, 0x5b, 0xf0, 0xc9, 0x97,
	0xb0, 0x82, 0x27, 0x29, 0x06, 0x32, 0x4b, 0xb2, 0x69, 0xe2, 0x86, 0x67, 0x9e, 0x5a, 0x2f, 0x7f,
	0x6a, 0xbd, 0xcd, 0x24, 0x19, 0x69, 0x06, 0x75, 0x8c, 0xbd, 0xd9, 0xe9, 0x29, 0x2c, 0x16, 0xdd,
	0xa9, 0x6e, 0x96, 0x2f, 0xde, 0xae, 0x3c, 0x19, 0xa0, 0xc7, 0xc8, 0x69, 0x2e, 0xd6, 0xf8, 0xd3,
	0x86, 0xda, 0xdc, 0x12, 0x21, 0x50, 0x39, 0x95, 0x73, 0x3d, 0x26, 0x6b, 0xe0, 0xe0, 0x09, 0x9b,
	0xf9, 0xae, 0xfa, 0x78, 0x59, 0xb5, 0x92, 0x06, 0x8d, 0x83, 0x6b, 0xe0, 0x70, 0x0c, 0xf1, 0x24,
	0x33, 0xa9, 0xe6, 0x26, 0x1a, 0x34, 0x26, 0x3f, 0xaa, 0x37, 0x36, 0x0e, 0xe7, 0xdb, 0x6c, 0xfb,
	0xff, 0xc4, 0xe1, 0xed, 0xc4, 0xf2, 0xb3, 0x3b, 0x54, 0x89, 0xea, 0xbd, 0xd4, 0xc0, 0xec, 0x75,
	0x03, 0x6a, 0x29, 0x47, 0x81, 0x71, 0xee, 0xf3, 0xa2, 0xba, 0xc1, 0xfb, 0x25, 0xba, 0x92, 0xc1,
	0xc6, 0xec, 0x7d, 0x50, 0xf3, 0x83, 0x28, 0x77, 0x7b, 0x39, 0x73, 0xdb, 0x31, 0xe8, 0xcc, 0x48,
	0x4c, 0x0e, 0x0a, 0x23, 0xc8, 0x8d, 0x0c, 0x9a, 0xc7, 0xbf, 0x12, 0xc5, 0x47, 0xc8, 0xf3, 0xfd,
	0x96, 0xcc, 0x8b, 0x61, 0x30, 0x73, 0x1a, 0xee, 0x00, 0x14, 0xfe, 0xaa, 0x67, 0x51, 0x48, 0xc6,
	0xcd, 0x2d, 0x6f, 0x53, 0x33, 0x51, 0xcf, 0x27, 0xc6, 0x43, 0xdd, 0x1d, 0x36, 0x55, 0xc3, 0xcd,
	0x3a, 0x5c, 0xcb, 0x8e, 0x82, 0x16, 0xf6, 0x45, 0x8a, 0x41, 0x74, 0x10, 0x21, 0xbf, 0x5f, 0x59,
	0x2a, 0xbb, 0xf6, 0xfd, 0xca, 0x92, 0xed, 0x56, 0x36, 0x09, 0xb8, 0xe6, 0x2d, 0x29, 0xd6, 0x37,
	0x77, 0xfe, 0x78, 0x51, 0xb1, 0x7e, 0xfb, 0xfb, 0xba, 0xf5, 0xfd, 0xbd, 0x73, 0xff, 0x17, 0xd3,
	0xe7, 0xe1, 0xec, 0x9f, 0xd1, 0x14, 0x22, 0x2b, 0xc2, 0xec, 0xc7, 0x71, 0x7f, 0x41, 0xf7, 0xe7,
	0xa7, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x9b, 0x06, 0x3a, 0xca, 0x79, 0x0a, 0x00, 0x00,
}

func (this *RateLimitConfigSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimitConfigSpec)
	if !ok {
		that2, ok := that.(RateLimitConfigSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConfigType == nil {
		if this.ConfigType != nil {
			return false
		}
	} else if this.ConfigType == nil {
		return false
	} else if !this.ConfigType.Equal(that1.ConfigType) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RateLimitConfigSpec_Raw_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimitConfigSpec_Raw_)
	if !ok {
		that2, ok := that.(RateLimitConfigSpec_Raw_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Raw.Equal(that1.Raw) {
		return false
	}
	return true
}
func (this *RateLimitConfigSpec_Raw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimitConfigSpec_Raw)
	if !ok {
		that2, ok := that.(RateLimitConfigSpec_Raw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Descriptors) != len(that1.Descriptors) {
		return false
	}
	for i := range this.Descriptors {
		if !this.Descriptors[i].Equal(that1.Descriptors[i]) {
			return false
		}
	}
	if len(this.RateLimits) != len(that1.RateLimits) {
		return false
	}
	for i := range this.RateLimits {
		if !this.RateLimits[i].Equal(that1.RateLimits[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RateLimitConfigStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimitConfigStatus)
	if !ok {
		that2, ok := that.(RateLimitConfigStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if this.ObservedGeneration != that1.ObservedGeneration {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Descriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Descriptor)
	if !ok {
		that2, ok := that.(Descriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if !this.RateLimit.Equal(that1.RateLimit) {
		return false
	}
	if len(this.Descriptors) != len(that1.Descriptors) {
		return false
	}
	for i := range this.Descriptors {
		if !this.Descriptors[i].Equal(that1.Descriptors[i]) {
			return false
		}
	}
	if this.Weight != that1.Weight {
		return false
	}
	if this.AlwaysApply != that1.AlwaysApply {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RateLimitActions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimitActions)
	if !ok {
		that2, ok := that.(RateLimitActions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Actions) != len(that1.Actions) {
		return false
	}
	for i := range this.Actions {
		if !this.Actions[i].Equal(that1.Actions[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RateLimit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimit)
	if !ok {
		that2, ok := that.(RateLimit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Unit != that1.Unit {
		return false
	}
	if this.RequestsPerUnit != that1.RequestsPerUnit {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action)
	if !ok {
		that2, ok := that.(Action)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ActionSpecifier == nil {
		if this.ActionSpecifier != nil {
			return false
		}
	} else if this.ActionSpecifier == nil {
		return false
	} else if !this.ActionSpecifier.Equal(that1.ActionSpecifier) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action_SourceCluster_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_SourceCluster_)
	if !ok {
		that2, ok := that.(Action_SourceCluster_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SourceCluster.Equal(that1.SourceCluster) {
		return false
	}
	return true
}
func (this *Action_DestinationCluster_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_DestinationCluster_)
	if !ok {
		that2, ok := that.(Action_DestinationCluster_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DestinationCluster.Equal(that1.DestinationCluster) {
		return false
	}
	return true
}
func (this *Action_RequestHeaders_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_RequestHeaders_)
	if !ok {
		that2, ok := that.(Action_RequestHeaders_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RequestHeaders.Equal(that1.RequestHeaders) {
		return false
	}
	return true
}
func (this *Action_RemoteAddress_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_RemoteAddress_)
	if !ok {
		that2, ok := that.(Action_RemoteAddress_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RemoteAddress.Equal(that1.RemoteAddress) {
		return false
	}
	return true
}
func (this *Action_GenericKey_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_GenericKey_)
	if !ok {
		that2, ok := that.(Action_GenericKey_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GenericKey.Equal(that1.GenericKey) {
		return false
	}
	return true
}
func (this *Action_HeaderValueMatch_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_HeaderValueMatch_)
	if !ok {
		that2, ok := that.(Action_HeaderValueMatch_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HeaderValueMatch.Equal(that1.HeaderValueMatch) {
		return false
	}
	return true
}
func (this *Action_SourceCluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_SourceCluster)
	if !ok {
		that2, ok := that.(Action_SourceCluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action_DestinationCluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_DestinationCluster)
	if !ok {
		that2, ok := that.(Action_DestinationCluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action_RequestHeaders) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_RequestHeaders)
	if !ok {
		that2, ok := that.(Action_RequestHeaders)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HeaderName != that1.HeaderName {
		return false
	}
	if this.DescriptorKey != that1.DescriptorKey {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action_RemoteAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_RemoteAddress)
	if !ok {
		that2, ok := that.(Action_RemoteAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action_GenericKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_GenericKey)
	if !ok {
		that2, ok := that.(Action_GenericKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DescriptorValue != that1.DescriptorValue {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action_HeaderValueMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_HeaderValueMatch)
	if !ok {
		that2, ok := that.(Action_HeaderValueMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DescriptorValue != that1.DescriptorValue {
		return false
	}
	if !this.ExpectMatch.Equal(that1.ExpectMatch) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action_HeaderValueMatch_HeaderMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_HeaderValueMatch_HeaderMatcher)
	if !ok {
		that2, ok := that.(Action_HeaderValueMatch_HeaderMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.HeaderMatchSpecifier == nil {
		if this.HeaderMatchSpecifier != nil {
			return false
		}
	} else if this.HeaderMatchSpecifier == nil {
		return false
	} else if !this.HeaderMatchSpecifier.Equal(that1.HeaderMatchSpecifier) {
		return false
	}
	if this.InvertMatch != that1.InvertMatch {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Action_HeaderValueMatch_HeaderMatcher_ExactMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_HeaderValueMatch_HeaderMatcher_ExactMatch)
	if !ok {
		that2, ok := that.(Action_HeaderValueMatch_HeaderMatcher_ExactMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExactMatch != that1.ExactMatch {
		return false
	}
	return true
}
func (this *Action_HeaderValueMatch_HeaderMatcher_RegexMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_HeaderValueMatch_HeaderMatcher_RegexMatch)
	if !ok {
		that2, ok := that.(Action_HeaderValueMatch_HeaderMatcher_RegexMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RegexMatch != that1.RegexMatch {
		return false
	}
	return true
}
func (this *Action_HeaderValueMatch_HeaderMatcher_RangeMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_HeaderValueMatch_HeaderMatcher_RangeMatch)
	if !ok {
		that2, ok := that.(Action_HeaderValueMatch_HeaderMatcher_RangeMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RangeMatch.Equal(that1.RangeMatch) {
		return false
	}
	return true
}
func (this *Action_HeaderValueMatch_HeaderMatcher_PresentMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_HeaderValueMatch_HeaderMatcher_PresentMatch)
	if !ok {
		that2, ok := that.(Action_HeaderValueMatch_HeaderMatcher_PresentMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PresentMatch != that1.PresentMatch {
		return false
	}
	return true
}
func (this *Action_HeaderValueMatch_HeaderMatcher_PrefixMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_HeaderValueMatch_HeaderMatcher_PrefixMatch)
	if !ok {
		that2, ok := that.(Action_HeaderValueMatch_HeaderMatcher_PrefixMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PrefixMatch != that1.PrefixMatch {
		return false
	}
	return true
}
func (this *Action_HeaderValueMatch_HeaderMatcher_SuffixMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_HeaderValueMatch_HeaderMatcher_SuffixMatch)
	if !ok {
		that2, ok := that.(Action_HeaderValueMatch_HeaderMatcher_SuffixMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SuffixMatch != that1.SuffixMatch {
		return false
	}
	return true
}
func (this *Action_HeaderValueMatch_HeaderMatcher_Int64Range) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_HeaderValueMatch_HeaderMatcher_Int64Range)
	if !ok {
		that2, ok := that.(Action_HeaderValueMatch_HeaderMatcher_Int64Range)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
