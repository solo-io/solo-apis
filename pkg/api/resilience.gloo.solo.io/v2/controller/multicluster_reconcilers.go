// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./multicluster_reconcilers.go -destination mocks/multicluster_reconcilers.go

// Definitions for the multicluster Kubernetes Controllers
package controller

import (
	"context"

	resilience_gloo_solo_io_v2 "github.com/solo-io/solo-apis/pkg/api/resilience.gloo.solo.io/v2"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/multicluster"
	mc_reconcile "github.com/solo-io/skv2/pkg/multicluster/reconcile"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the FailoverPolicy Resource across clusters.
// implemented by the user
type MulticlusterFailoverPolicyReconciler interface {
	ReconcileFailoverPolicy(clusterName string, obj *resilience_gloo_solo_io_v2.FailoverPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the FailoverPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterFailoverPolicyDeletionReconciler interface {
	ReconcileFailoverPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterFailoverPolicyReconcilerFuncs struct {
	OnReconcileFailoverPolicy         func(clusterName string, obj *resilience_gloo_solo_io_v2.FailoverPolicy) (reconcile.Result, error)
	OnReconcileFailoverPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterFailoverPolicyReconcilerFuncs) ReconcileFailoverPolicy(clusterName string, obj *resilience_gloo_solo_io_v2.FailoverPolicy) (reconcile.Result, error) {
	if f.OnReconcileFailoverPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileFailoverPolicy(clusterName, obj)
}

func (f *MulticlusterFailoverPolicyReconcilerFuncs) ReconcileFailoverPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileFailoverPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileFailoverPolicyDeletion(clusterName, req)
}

type MulticlusterFailoverPolicyReconcileLoop interface {
	// AddMulticlusterFailoverPolicyReconciler adds a MulticlusterFailoverPolicyReconciler to the MulticlusterFailoverPolicyReconcileLoop.
	AddMulticlusterFailoverPolicyReconciler(ctx context.Context, rec MulticlusterFailoverPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterFailoverPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterFailoverPolicyReconcileLoop) AddMulticlusterFailoverPolicyReconciler(ctx context.Context, rec MulticlusterFailoverPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericFailoverPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterFailoverPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterFailoverPolicyReconcileLoop {
	return &multiclusterFailoverPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &resilience_gloo_solo_io_v2.FailoverPolicy{}, options)}
}

type genericFailoverPolicyMulticlusterReconciler struct {
	reconciler MulticlusterFailoverPolicyReconciler
}

func (g genericFailoverPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterFailoverPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileFailoverPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericFailoverPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_gloo_solo_io_v2.FailoverPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: FailoverPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileFailoverPolicy(cluster, obj)
}

// Reconcile Upsert events for the OutlierDetectionPolicy Resource across clusters.
// implemented by the user
type MulticlusterOutlierDetectionPolicyReconciler interface {
	ReconcileOutlierDetectionPolicy(clusterName string, obj *resilience_gloo_solo_io_v2.OutlierDetectionPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the OutlierDetectionPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterOutlierDetectionPolicyDeletionReconciler interface {
	ReconcileOutlierDetectionPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterOutlierDetectionPolicyReconcilerFuncs struct {
	OnReconcileOutlierDetectionPolicy         func(clusterName string, obj *resilience_gloo_solo_io_v2.OutlierDetectionPolicy) (reconcile.Result, error)
	OnReconcileOutlierDetectionPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterOutlierDetectionPolicyReconcilerFuncs) ReconcileOutlierDetectionPolicy(clusterName string, obj *resilience_gloo_solo_io_v2.OutlierDetectionPolicy) (reconcile.Result, error) {
	if f.OnReconcileOutlierDetectionPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileOutlierDetectionPolicy(clusterName, obj)
}

func (f *MulticlusterOutlierDetectionPolicyReconcilerFuncs) ReconcileOutlierDetectionPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileOutlierDetectionPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileOutlierDetectionPolicyDeletion(clusterName, req)
}

type MulticlusterOutlierDetectionPolicyReconcileLoop interface {
	// AddMulticlusterOutlierDetectionPolicyReconciler adds a MulticlusterOutlierDetectionPolicyReconciler to the MulticlusterOutlierDetectionPolicyReconcileLoop.
	AddMulticlusterOutlierDetectionPolicyReconciler(ctx context.Context, rec MulticlusterOutlierDetectionPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterOutlierDetectionPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterOutlierDetectionPolicyReconcileLoop) AddMulticlusterOutlierDetectionPolicyReconciler(ctx context.Context, rec MulticlusterOutlierDetectionPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericOutlierDetectionPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterOutlierDetectionPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterOutlierDetectionPolicyReconcileLoop {
	return &multiclusterOutlierDetectionPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &resilience_gloo_solo_io_v2.OutlierDetectionPolicy{}, options)}
}

type genericOutlierDetectionPolicyMulticlusterReconciler struct {
	reconciler MulticlusterOutlierDetectionPolicyReconciler
}

func (g genericOutlierDetectionPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterOutlierDetectionPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileOutlierDetectionPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericOutlierDetectionPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_gloo_solo_io_v2.OutlierDetectionPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: OutlierDetectionPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileOutlierDetectionPolicy(cluster, obj)
}

// Reconcile Upsert events for the FaultInjectionPolicy Resource across clusters.
// implemented by the user
type MulticlusterFaultInjectionPolicyReconciler interface {
	ReconcileFaultInjectionPolicy(clusterName string, obj *resilience_gloo_solo_io_v2.FaultInjectionPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the FaultInjectionPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterFaultInjectionPolicyDeletionReconciler interface {
	ReconcileFaultInjectionPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterFaultInjectionPolicyReconcilerFuncs struct {
	OnReconcileFaultInjectionPolicy         func(clusterName string, obj *resilience_gloo_solo_io_v2.FaultInjectionPolicy) (reconcile.Result, error)
	OnReconcileFaultInjectionPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterFaultInjectionPolicyReconcilerFuncs) ReconcileFaultInjectionPolicy(clusterName string, obj *resilience_gloo_solo_io_v2.FaultInjectionPolicy) (reconcile.Result, error) {
	if f.OnReconcileFaultInjectionPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileFaultInjectionPolicy(clusterName, obj)
}

func (f *MulticlusterFaultInjectionPolicyReconcilerFuncs) ReconcileFaultInjectionPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileFaultInjectionPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileFaultInjectionPolicyDeletion(clusterName, req)
}

type MulticlusterFaultInjectionPolicyReconcileLoop interface {
	// AddMulticlusterFaultInjectionPolicyReconciler adds a MulticlusterFaultInjectionPolicyReconciler to the MulticlusterFaultInjectionPolicyReconcileLoop.
	AddMulticlusterFaultInjectionPolicyReconciler(ctx context.Context, rec MulticlusterFaultInjectionPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterFaultInjectionPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterFaultInjectionPolicyReconcileLoop) AddMulticlusterFaultInjectionPolicyReconciler(ctx context.Context, rec MulticlusterFaultInjectionPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericFaultInjectionPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterFaultInjectionPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterFaultInjectionPolicyReconcileLoop {
	return &multiclusterFaultInjectionPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &resilience_gloo_solo_io_v2.FaultInjectionPolicy{}, options)}
}

type genericFaultInjectionPolicyMulticlusterReconciler struct {
	reconciler MulticlusterFaultInjectionPolicyReconciler
}

func (g genericFaultInjectionPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterFaultInjectionPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileFaultInjectionPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericFaultInjectionPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_gloo_solo_io_v2.FaultInjectionPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: FaultInjectionPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileFaultInjectionPolicy(cluster, obj)
}

// Reconcile Upsert events for the RetryTimeoutPolicy Resource across clusters.
// implemented by the user
type MulticlusterRetryTimeoutPolicyReconciler interface {
	ReconcileRetryTimeoutPolicy(clusterName string, obj *resilience_gloo_solo_io_v2.RetryTimeoutPolicy) (reconcile.Result, error)
}

// Reconcile deletion events for the RetryTimeoutPolicy Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterRetryTimeoutPolicyDeletionReconciler interface {
	ReconcileRetryTimeoutPolicyDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterRetryTimeoutPolicyReconcilerFuncs struct {
	OnReconcileRetryTimeoutPolicy         func(clusterName string, obj *resilience_gloo_solo_io_v2.RetryTimeoutPolicy) (reconcile.Result, error)
	OnReconcileRetryTimeoutPolicyDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterRetryTimeoutPolicyReconcilerFuncs) ReconcileRetryTimeoutPolicy(clusterName string, obj *resilience_gloo_solo_io_v2.RetryTimeoutPolicy) (reconcile.Result, error) {
	if f.OnReconcileRetryTimeoutPolicy == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileRetryTimeoutPolicy(clusterName, obj)
}

func (f *MulticlusterRetryTimeoutPolicyReconcilerFuncs) ReconcileRetryTimeoutPolicyDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileRetryTimeoutPolicyDeletion == nil {
		return nil
	}
	return f.OnReconcileRetryTimeoutPolicyDeletion(clusterName, req)
}

type MulticlusterRetryTimeoutPolicyReconcileLoop interface {
	// AddMulticlusterRetryTimeoutPolicyReconciler adds a MulticlusterRetryTimeoutPolicyReconciler to the MulticlusterRetryTimeoutPolicyReconcileLoop.
	AddMulticlusterRetryTimeoutPolicyReconciler(ctx context.Context, rec MulticlusterRetryTimeoutPolicyReconciler, predicates ...predicate.Predicate)
}

type multiclusterRetryTimeoutPolicyReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterRetryTimeoutPolicyReconcileLoop) AddMulticlusterRetryTimeoutPolicyReconciler(ctx context.Context, rec MulticlusterRetryTimeoutPolicyReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericRetryTimeoutPolicyMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterRetryTimeoutPolicyReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterRetryTimeoutPolicyReconcileLoop {
	return &multiclusterRetryTimeoutPolicyReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &resilience_gloo_solo_io_v2.RetryTimeoutPolicy{}, options)}
}

type genericRetryTimeoutPolicyMulticlusterReconciler struct {
	reconciler MulticlusterRetryTimeoutPolicyReconciler
}

func (g genericRetryTimeoutPolicyMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterRetryTimeoutPolicyDeletionReconciler); ok {
		return deletionReconciler.ReconcileRetryTimeoutPolicyDeletion(cluster, req)
	}
	return nil
}

func (g genericRetryTimeoutPolicyMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*resilience_gloo_solo_io_v2.RetryTimeoutPolicy)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: RetryTimeoutPolicy handler received event for %T", object)
	}
	return g.reconciler.ReconcileRetryTimeoutPolicy(cluster, obj)
}
