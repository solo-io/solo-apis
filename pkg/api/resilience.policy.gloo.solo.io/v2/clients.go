// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./clients.go -destination mocks/clients.go

package v2

import (
	"context"

	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// MulticlusterClientset for the resilience.policy.gloo.solo.io/v2 APIs
type MulticlusterClientset interface {
	// Cluster returns a Clientset for the given cluster
	Cluster(cluster string) (Clientset, error)
}

type multiclusterClientset struct {
	client multicluster.Client
}

func NewMulticlusterClientset(client multicluster.Client) MulticlusterClientset {
	return &multiclusterClientset{client: client}
}

func (m *multiclusterClientset) Cluster(cluster string) (Clientset, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

// clienset for the resilience.policy.gloo.solo.io/v2 APIs
type Clientset interface {
	// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
	FailoverPolicies() FailoverPolicyClient
	// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
	OutlierDetectionPolicies() OutlierDetectionPolicyClient
	// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
	FaultInjectionPolicies() FaultInjectionPolicyClient
	// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
	RetryTimeoutPolicies() RetryTimeoutPolicyClient
}

type clientSet struct {
	client client.Client
}

func NewClientsetFromConfig(cfg *rest.Config) (Clientset, error) {
	scheme := scheme.Scheme
	if err := SchemeBuilder.AddToScheme(scheme); err != nil {
		return nil, err
	}
	client, err := client.New(cfg, client.Options{
		Scheme: scheme,
	})
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

func NewClientset(client client.Client) Clientset {
	return &clientSet{client: client}
}

// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) FailoverPolicies() FailoverPolicyClient {
	return NewFailoverPolicyClient(c.client)
}

// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) OutlierDetectionPolicies() OutlierDetectionPolicyClient {
	return NewOutlierDetectionPolicyClient(c.client)
}

// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) FaultInjectionPolicies() FaultInjectionPolicyClient {
	return NewFaultInjectionPolicyClient(c.client)
}

// clienset for the resilience.policy.gloo.solo.io/v2/v2 APIs
func (c *clientSet) RetryTimeoutPolicies() RetryTimeoutPolicyClient {
	return NewRetryTimeoutPolicyClient(c.client)
}

// Reader knows how to read and list FailoverPolicys.
type FailoverPolicyReader interface {
	// Get retrieves a FailoverPolicy for the given object key
	GetFailoverPolicy(ctx context.Context, key client.ObjectKey) (*FailoverPolicy, error)

	// List retrieves list of FailoverPolicys for a given namespace and list options.
	ListFailoverPolicy(ctx context.Context, opts ...client.ListOption) (*FailoverPolicyList, error)
}

// FailoverPolicyTransitionFunction instructs the FailoverPolicyWriter how to transition between an existing
// FailoverPolicy object and a desired on an Upsert
type FailoverPolicyTransitionFunction func(existing, desired *FailoverPolicy) error

// Writer knows how to create, delete, and update FailoverPolicys.
type FailoverPolicyWriter interface {
	// Create saves the FailoverPolicy object.
	CreateFailoverPolicy(ctx context.Context, obj *FailoverPolicy, opts ...client.CreateOption) error

	// Delete deletes the FailoverPolicy object.
	DeleteFailoverPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given FailoverPolicy object.
	UpdateFailoverPolicy(ctx context.Context, obj *FailoverPolicy, opts ...client.UpdateOption) error

	// Patch patches the given FailoverPolicy object.
	PatchFailoverPolicy(ctx context.Context, obj *FailoverPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all FailoverPolicy objects matching the given options.
	DeleteAllOfFailoverPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the FailoverPolicy object.
	UpsertFailoverPolicy(ctx context.Context, obj *FailoverPolicy, transitionFuncs ...FailoverPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a FailoverPolicy object.
type FailoverPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given FailoverPolicy object.
	UpdateFailoverPolicyStatus(ctx context.Context, obj *FailoverPolicy, opts ...client.UpdateOption) error

	// Patch patches the given FailoverPolicy object's subresource.
	PatchFailoverPolicyStatus(ctx context.Context, obj *FailoverPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on FailoverPolicys.
type FailoverPolicyClient interface {
	FailoverPolicyReader
	FailoverPolicyWriter
	FailoverPolicyStatusWriter
}

type failoverPolicyClient struct {
	client client.Client
}

func NewFailoverPolicyClient(client client.Client) *failoverPolicyClient {
	return &failoverPolicyClient{client: client}
}

func (c *failoverPolicyClient) GetFailoverPolicy(ctx context.Context, key client.ObjectKey) (*FailoverPolicy, error) {
	obj := &FailoverPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *failoverPolicyClient) ListFailoverPolicy(ctx context.Context, opts ...client.ListOption) (*FailoverPolicyList, error) {
	list := &FailoverPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *failoverPolicyClient) CreateFailoverPolicy(ctx context.Context, obj *FailoverPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *failoverPolicyClient) DeleteFailoverPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &FailoverPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *failoverPolicyClient) UpdateFailoverPolicy(ctx context.Context, obj *FailoverPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *failoverPolicyClient) PatchFailoverPolicy(ctx context.Context, obj *FailoverPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *failoverPolicyClient) DeleteAllOfFailoverPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &FailoverPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *failoverPolicyClient) UpsertFailoverPolicy(ctx context.Context, obj *FailoverPolicy, transitionFuncs ...FailoverPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*FailoverPolicy), desired.(*FailoverPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *failoverPolicyClient) UpdateFailoverPolicyStatus(ctx context.Context, obj *FailoverPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *failoverPolicyClient) PatchFailoverPolicyStatus(ctx context.Context, obj *FailoverPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides FailoverPolicyClients for multiple clusters.
type MulticlusterFailoverPolicyClient interface {
	// Cluster returns a FailoverPolicyClient for the given cluster
	Cluster(cluster string) (FailoverPolicyClient, error)
}

type multiclusterFailoverPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterFailoverPolicyClient(client multicluster.Client) MulticlusterFailoverPolicyClient {
	return &multiclusterFailoverPolicyClient{client: client}
}

func (m *multiclusterFailoverPolicyClient) Cluster(cluster string) (FailoverPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewFailoverPolicyClient(client), nil
}

// Reader knows how to read and list OutlierDetectionPolicys.
type OutlierDetectionPolicyReader interface {
	// Get retrieves a OutlierDetectionPolicy for the given object key
	GetOutlierDetectionPolicy(ctx context.Context, key client.ObjectKey) (*OutlierDetectionPolicy, error)

	// List retrieves list of OutlierDetectionPolicys for a given namespace and list options.
	ListOutlierDetectionPolicy(ctx context.Context, opts ...client.ListOption) (*OutlierDetectionPolicyList, error)
}

// OutlierDetectionPolicyTransitionFunction instructs the OutlierDetectionPolicyWriter how to transition between an existing
// OutlierDetectionPolicy object and a desired on an Upsert
type OutlierDetectionPolicyTransitionFunction func(existing, desired *OutlierDetectionPolicy) error

// Writer knows how to create, delete, and update OutlierDetectionPolicys.
type OutlierDetectionPolicyWriter interface {
	// Create saves the OutlierDetectionPolicy object.
	CreateOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, opts ...client.CreateOption) error

	// Delete deletes the OutlierDetectionPolicy object.
	DeleteOutlierDetectionPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given OutlierDetectionPolicy object.
	UpdateOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, opts ...client.UpdateOption) error

	// Patch patches the given OutlierDetectionPolicy object.
	PatchOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all OutlierDetectionPolicy objects matching the given options.
	DeleteAllOfOutlierDetectionPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the OutlierDetectionPolicy object.
	UpsertOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, transitionFuncs ...OutlierDetectionPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a OutlierDetectionPolicy object.
type OutlierDetectionPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given OutlierDetectionPolicy object.
	UpdateOutlierDetectionPolicyStatus(ctx context.Context, obj *OutlierDetectionPolicy, opts ...client.UpdateOption) error

	// Patch patches the given OutlierDetectionPolicy object's subresource.
	PatchOutlierDetectionPolicyStatus(ctx context.Context, obj *OutlierDetectionPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on OutlierDetectionPolicys.
type OutlierDetectionPolicyClient interface {
	OutlierDetectionPolicyReader
	OutlierDetectionPolicyWriter
	OutlierDetectionPolicyStatusWriter
}

type outlierDetectionPolicyClient struct {
	client client.Client
}

func NewOutlierDetectionPolicyClient(client client.Client) *outlierDetectionPolicyClient {
	return &outlierDetectionPolicyClient{client: client}
}

func (c *outlierDetectionPolicyClient) GetOutlierDetectionPolicy(ctx context.Context, key client.ObjectKey) (*OutlierDetectionPolicy, error) {
	obj := &OutlierDetectionPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *outlierDetectionPolicyClient) ListOutlierDetectionPolicy(ctx context.Context, opts ...client.ListOption) (*OutlierDetectionPolicyList, error) {
	list := &OutlierDetectionPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *outlierDetectionPolicyClient) CreateOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *outlierDetectionPolicyClient) DeleteOutlierDetectionPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &OutlierDetectionPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *outlierDetectionPolicyClient) UpdateOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *outlierDetectionPolicyClient) PatchOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *outlierDetectionPolicyClient) DeleteAllOfOutlierDetectionPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &OutlierDetectionPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *outlierDetectionPolicyClient) UpsertOutlierDetectionPolicy(ctx context.Context, obj *OutlierDetectionPolicy, transitionFuncs ...OutlierDetectionPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*OutlierDetectionPolicy), desired.(*OutlierDetectionPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *outlierDetectionPolicyClient) UpdateOutlierDetectionPolicyStatus(ctx context.Context, obj *OutlierDetectionPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *outlierDetectionPolicyClient) PatchOutlierDetectionPolicyStatus(ctx context.Context, obj *OutlierDetectionPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides OutlierDetectionPolicyClients for multiple clusters.
type MulticlusterOutlierDetectionPolicyClient interface {
	// Cluster returns a OutlierDetectionPolicyClient for the given cluster
	Cluster(cluster string) (OutlierDetectionPolicyClient, error)
}

type multiclusterOutlierDetectionPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterOutlierDetectionPolicyClient(client multicluster.Client) MulticlusterOutlierDetectionPolicyClient {
	return &multiclusterOutlierDetectionPolicyClient{client: client}
}

func (m *multiclusterOutlierDetectionPolicyClient) Cluster(cluster string) (OutlierDetectionPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewOutlierDetectionPolicyClient(client), nil
}

// Reader knows how to read and list FaultInjectionPolicys.
type FaultInjectionPolicyReader interface {
	// Get retrieves a FaultInjectionPolicy for the given object key
	GetFaultInjectionPolicy(ctx context.Context, key client.ObjectKey) (*FaultInjectionPolicy, error)

	// List retrieves list of FaultInjectionPolicys for a given namespace and list options.
	ListFaultInjectionPolicy(ctx context.Context, opts ...client.ListOption) (*FaultInjectionPolicyList, error)
}

// FaultInjectionPolicyTransitionFunction instructs the FaultInjectionPolicyWriter how to transition between an existing
// FaultInjectionPolicy object and a desired on an Upsert
type FaultInjectionPolicyTransitionFunction func(existing, desired *FaultInjectionPolicy) error

// Writer knows how to create, delete, and update FaultInjectionPolicys.
type FaultInjectionPolicyWriter interface {
	// Create saves the FaultInjectionPolicy object.
	CreateFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, opts ...client.CreateOption) error

	// Delete deletes the FaultInjectionPolicy object.
	DeleteFaultInjectionPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given FaultInjectionPolicy object.
	UpdateFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, opts ...client.UpdateOption) error

	// Patch patches the given FaultInjectionPolicy object.
	PatchFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all FaultInjectionPolicy objects matching the given options.
	DeleteAllOfFaultInjectionPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the FaultInjectionPolicy object.
	UpsertFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, transitionFuncs ...FaultInjectionPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a FaultInjectionPolicy object.
type FaultInjectionPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given FaultInjectionPolicy object.
	UpdateFaultInjectionPolicyStatus(ctx context.Context, obj *FaultInjectionPolicy, opts ...client.UpdateOption) error

	// Patch patches the given FaultInjectionPolicy object's subresource.
	PatchFaultInjectionPolicyStatus(ctx context.Context, obj *FaultInjectionPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on FaultInjectionPolicys.
type FaultInjectionPolicyClient interface {
	FaultInjectionPolicyReader
	FaultInjectionPolicyWriter
	FaultInjectionPolicyStatusWriter
}

type faultInjectionPolicyClient struct {
	client client.Client
}

func NewFaultInjectionPolicyClient(client client.Client) *faultInjectionPolicyClient {
	return &faultInjectionPolicyClient{client: client}
}

func (c *faultInjectionPolicyClient) GetFaultInjectionPolicy(ctx context.Context, key client.ObjectKey) (*FaultInjectionPolicy, error) {
	obj := &FaultInjectionPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *faultInjectionPolicyClient) ListFaultInjectionPolicy(ctx context.Context, opts ...client.ListOption) (*FaultInjectionPolicyList, error) {
	list := &FaultInjectionPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *faultInjectionPolicyClient) CreateFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *faultInjectionPolicyClient) DeleteFaultInjectionPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &FaultInjectionPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *faultInjectionPolicyClient) UpdateFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *faultInjectionPolicyClient) PatchFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *faultInjectionPolicyClient) DeleteAllOfFaultInjectionPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &FaultInjectionPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *faultInjectionPolicyClient) UpsertFaultInjectionPolicy(ctx context.Context, obj *FaultInjectionPolicy, transitionFuncs ...FaultInjectionPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*FaultInjectionPolicy), desired.(*FaultInjectionPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *faultInjectionPolicyClient) UpdateFaultInjectionPolicyStatus(ctx context.Context, obj *FaultInjectionPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *faultInjectionPolicyClient) PatchFaultInjectionPolicyStatus(ctx context.Context, obj *FaultInjectionPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides FaultInjectionPolicyClients for multiple clusters.
type MulticlusterFaultInjectionPolicyClient interface {
	// Cluster returns a FaultInjectionPolicyClient for the given cluster
	Cluster(cluster string) (FaultInjectionPolicyClient, error)
}

type multiclusterFaultInjectionPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterFaultInjectionPolicyClient(client multicluster.Client) MulticlusterFaultInjectionPolicyClient {
	return &multiclusterFaultInjectionPolicyClient{client: client}
}

func (m *multiclusterFaultInjectionPolicyClient) Cluster(cluster string) (FaultInjectionPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewFaultInjectionPolicyClient(client), nil
}

// Reader knows how to read and list RetryTimeoutPolicys.
type RetryTimeoutPolicyReader interface {
	// Get retrieves a RetryTimeoutPolicy for the given object key
	GetRetryTimeoutPolicy(ctx context.Context, key client.ObjectKey) (*RetryTimeoutPolicy, error)

	// List retrieves list of RetryTimeoutPolicys for a given namespace and list options.
	ListRetryTimeoutPolicy(ctx context.Context, opts ...client.ListOption) (*RetryTimeoutPolicyList, error)
}

// RetryTimeoutPolicyTransitionFunction instructs the RetryTimeoutPolicyWriter how to transition between an existing
// RetryTimeoutPolicy object and a desired on an Upsert
type RetryTimeoutPolicyTransitionFunction func(existing, desired *RetryTimeoutPolicy) error

// Writer knows how to create, delete, and update RetryTimeoutPolicys.
type RetryTimeoutPolicyWriter interface {
	// Create saves the RetryTimeoutPolicy object.
	CreateRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, opts ...client.CreateOption) error

	// Delete deletes the RetryTimeoutPolicy object.
	DeleteRetryTimeoutPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given RetryTimeoutPolicy object.
	UpdateRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, opts ...client.UpdateOption) error

	// Patch patches the given RetryTimeoutPolicy object.
	PatchRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all RetryTimeoutPolicy objects matching the given options.
	DeleteAllOfRetryTimeoutPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the RetryTimeoutPolicy object.
	UpsertRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, transitionFuncs ...RetryTimeoutPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a RetryTimeoutPolicy object.
type RetryTimeoutPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given RetryTimeoutPolicy object.
	UpdateRetryTimeoutPolicyStatus(ctx context.Context, obj *RetryTimeoutPolicy, opts ...client.UpdateOption) error

	// Patch patches the given RetryTimeoutPolicy object's subresource.
	PatchRetryTimeoutPolicyStatus(ctx context.Context, obj *RetryTimeoutPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on RetryTimeoutPolicys.
type RetryTimeoutPolicyClient interface {
	RetryTimeoutPolicyReader
	RetryTimeoutPolicyWriter
	RetryTimeoutPolicyStatusWriter
}

type retryTimeoutPolicyClient struct {
	client client.Client
}

func NewRetryTimeoutPolicyClient(client client.Client) *retryTimeoutPolicyClient {
	return &retryTimeoutPolicyClient{client: client}
}

func (c *retryTimeoutPolicyClient) GetRetryTimeoutPolicy(ctx context.Context, key client.ObjectKey) (*RetryTimeoutPolicy, error) {
	obj := &RetryTimeoutPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *retryTimeoutPolicyClient) ListRetryTimeoutPolicy(ctx context.Context, opts ...client.ListOption) (*RetryTimeoutPolicyList, error) {
	list := &RetryTimeoutPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *retryTimeoutPolicyClient) CreateRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *retryTimeoutPolicyClient) DeleteRetryTimeoutPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &RetryTimeoutPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *retryTimeoutPolicyClient) UpdateRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *retryTimeoutPolicyClient) PatchRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *retryTimeoutPolicyClient) DeleteAllOfRetryTimeoutPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &RetryTimeoutPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *retryTimeoutPolicyClient) UpsertRetryTimeoutPolicy(ctx context.Context, obj *RetryTimeoutPolicy, transitionFuncs ...RetryTimeoutPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*RetryTimeoutPolicy), desired.(*RetryTimeoutPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *retryTimeoutPolicyClient) UpdateRetryTimeoutPolicyStatus(ctx context.Context, obj *RetryTimeoutPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *retryTimeoutPolicyClient) PatchRetryTimeoutPolicyStatus(ctx context.Context, obj *RetryTimeoutPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides RetryTimeoutPolicyClients for multiple clusters.
type MulticlusterRetryTimeoutPolicyClient interface {
	// Cluster returns a RetryTimeoutPolicyClient for the given cluster
	Cluster(cluster string) (RetryTimeoutPolicyClient, error)
}

type multiclusterRetryTimeoutPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterRetryTimeoutPolicyClient(client multicluster.Client) MulticlusterRetryTimeoutPolicyClient {
	return &multiclusterRetryTimeoutPolicyClient{client: client}
}

func (m *multiclusterRetryTimeoutPolicyClient) Cluster(cluster string) (RetryTimeoutPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewRetryTimeoutPolicyClient(client), nil
}
