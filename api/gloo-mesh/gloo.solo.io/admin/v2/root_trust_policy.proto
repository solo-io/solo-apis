syntax = "proto3";
package admin.gloo.solo.io;
option go_package = "github.com/solo-io/solo-apis/pkg/api/admin.gloo.solo.io/v2";

import "github.com/solo-io/skv2/api/core/v1/core.proto";
import "github.com/solo-io/solo-apis/api/gloo-mesh/gloo.solo.io/policy/v2/security/tls/ca_options.proto";
import "github.com/solo-io/solo-apis/api/gloo-mesh/gloo.solo.io/common/v2/selectors.proto";
import "github.com/solo-io/solo-apis/api/gloo-mesh/gloo.solo.io/common/v2/approval_state.proto";

import "extproto/ext.proto";
option (extproto.equal_all) = true;
option (extproto.hash_all) = true;
option (extproto.clone_all) = true;

// RootTrustPolicy is used to designate the root of trust, including the trust domain and root certificates used by one or more service meshes.
// A shared RootTrustPolicy is currently required to support communication between workloads and destinations running in different meshes. In the future Gloo Mesh will support cross-mesh connectivity using a Limited Trust model (where participating meshes are permitted to use separate roots of trust).
message RootTrustPolicySpec {

    // select the meshes where the root of trust will be applied.
    // if left empty, will apply to all Meshes in the workspace.
    repeated .common.gloo.solo.io.MeshSelector apply_to_meshes = 1;

    // The details of the root of trust to apply to the selected meshes.
    Config config = 2;

    message Config {

        // different options for choosing the CA used to provide the root cert
        oneof certificate_authority_type {

            // Configure a Root Certificate Authority which will be shared by all Meshes associated with this RootTrustPolicy.
            // If this is not provided, a self-signed certificate will be generated by Gloo Mesh.
            MgmtServerCertificateAuthority mgmt_server_ca = 1;

            // Configures an Intermediate Certificate Authority which selected meshes will use to generate intermediate certificates.
            // The CA being used must be configured to generate the intermediate certificates.
            .tls.security.policy.gloo.solo.io.AgentCertificateAuthority agent_ca = 2;
        }

        // Configuration options for generated intermediate certs.
        .tls.security.policy.gloo.solo.io.CommonCertOptions intermediate_cert_options = 3;

        // This setting specifies whether or not workload pods should be automatically restarted
        // upon completion of a successful certificate issuance.
        bool auto_restart_pods = 4;

        // Specify parameters for configuring the root certificate authority for a RootTrustPolicy.
        message MgmtServerCertificateAuthority {

            // Specify the source of the Root CA data which Gloo Mesh will use for the RootTrustPolicy.
            oneof ca_source {

                // Generate a self-signed root certificate with the given options.
                .tls.security.policy.gloo.solo.io.CommonCertOptions generated = 1;

                // Name of a Kubernetes Secret in the same namespace as the RootTrustPolicy containing the root certificate authority.
                // Provided certificates must conform to a specified format, [documented here]({{< versioned_link_path fromRoot="/setup/prod/certs/cert-architecture/#required-certificates" >}}).
                .core.skv2.solo.io.ObjectRef secret_ref = 2;

            }
        }

    }
}

// reflects the status of the RootTrustPolicy
message RootTrustPolicyStatus {

    // The most recent generation observed in the the object's metadata.
    // If the `observedGeneration` does not match `metadata.generation`, Gloo Mesh has not processed the most
    // recent version of this object.
    int64 observed_generation = 1;

    // Whether the resource has been accepted as valid and processed in the Gloo Mesh config translation.
    .common.gloo.solo.io.ApprovalState state = 2;

    // TODO(ilackarms): should we also show other qualities of the policy? e.g. where it is applied?
}
