syntax = "proto3";

package resilience.policy.gloo.solo.io;

import "extproto/ext.proto";
import "github.com/solo-io/solo-apis/api/gloo-mesh/gloo.solo.io/common/v2/references.proto";
import "github.com/solo-io/solo-apis/api/gloo-mesh/gloo.solo.io/common/v2/selectors.proto";
import "github.com/solo-io/solo-apis/api/gloo-mesh/gloo.solo.io/common/v2/status.proto";
import "github.com/solo-io/solo-apis/api/gloo-mesh/gloo.solo.io/common/v2/status_new.proto";
import "google/protobuf/wrappers.proto";

option go_package = "github.com/solo-io/solo-apis/pkg/api/resilience.policy.gloo.solo.io/v2";

option (extproto.equal_all) = true;
option (extproto.hash_all) = true;
option (extproto.clone_all) = true;

// FailoverPolicy is used to enable or configure failover routing for traffic being sent to selected destinations.
// When traffic is being routed to a backing service within a selected virtual destination, if that backing service is detected as being in an unhealthy state, traffic will be re-routed to another healthy backing service by locality as specified in the FailoverPolicy config.
// FailoverPolicy can be used to reroute traffic across clusters when the local instance of a destination service fails. This requires that the backing destinations of the selected virtual destination belong to meshes in the same TrustDomain.
// FailoverPolicies are applied at the *Destination* level.
//
// Note: To remove unhealthy destinations from the pool of routable destinations, you must use an [OutlierDetectionPolicy]({{< versioned_link_path fromRoot="/policies/outlier-detection/">}})
// in addition to the FailoverPolicy.
message FailoverPolicySpec {

  // select the virtual destinations where the policy will be applied
  // if left empty, will apply to all destinations in the workspace.
  repeated .common.gloo.solo.io.DestinationSelector apply_to_destinations = 1;

  // The details of the failover policy to apply to the selected virtual destinations.
  //
  // You can exclude this if you wish to enable the locality load balancer
  // settings without mappings.
  Config config = 2;

  message Config {

    // Mappings between localities to provide failover for traffic
    // across regions, zones, and subzones.
    //
    // You can exclude this if you wish to enable the locality load balancer
    // settings without mappings.
    repeated LocalityMappings locality_mappings = 2;

    message LocalityMappings {
      // Originating locality of the client workload.
      OriginatingLocality from = 1;

      // The list of Destination localities that can be routed to if the instance local to the client workload is not available.
      repeated DestinationLocality to = 2;

      // A geographic location defined by a region, zone, and sub-zone.
      message OriginatingLocality {
        // The locality's region.
        string region = 1;

        // (Optional) The locality's zone.
        string zone = 2;

        // (Optional) The locality's sub-zone.
        string sub_zone = 3;
      }

      // A geographic location defined by a region, zone, and sub-zone
      // along with the weight for the destination.
      message DestinationLocality {

        // The locality's region.
        string region = 1;

        // (Optional) The locality's zone.
        string zone = 2;

        // (Optional) The locality's sub-zone.
        string sub_zone = 3;

        // (Optional) Weight for destination locality. All weights must add up to 100.
        // If not provided, we will determine the weight based on other
        // destination locality weights.
        // For information about the value format, see the [Google protocol buffer documentation](https://developers.google.com/protocol-buffers/docs/reference/csharp/class/google/protobuf/well-known-types/u-int32-value).
        google.protobuf.UInt32Value weight = 4;
      }
    }

  }

}

// reflects the status of the FailoverPolicy
message FailoverPolicyStatus {
  .common.gloo.solo.io.Status common = 1;

  // The number of destination ports selected by the policy.
  uint32 num_selected_destination_ports = 2;
}

message FailoverPolicyReport {
  map<string, .common.gloo.solo.io.Report> workspaces = 1;

  // A list of destination ports selected by the policy.
  repeated .common.gloo.solo.io.DestinationReference selected_destination_ports = 2;
}
