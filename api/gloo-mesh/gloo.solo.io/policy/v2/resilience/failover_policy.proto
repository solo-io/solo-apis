syntax = "proto3";
package resilience.policy.gloo.solo.io;
option go_package = "github.com/solo-io/solo-apis/pkg/api/resilience.policy.gloo.solo.io/v2";

import "github.com/solo-io/solo-apis/api/gloo-mesh/gloo.solo.io/common/v2/selectors.proto";
import "github.com/solo-io/solo-apis/api/gloo-mesh/gloo.solo.io/common/v2/status.proto";

import "google/protobuf/wrappers.proto";
import "extproto/ext.proto";
option (extproto.equal_all) = true;
option (extproto.hash_all) = true;
option (extproto.clone_all) = true;

// FailoverPolicy is used to enable failover routing for traffic being sent to selected destinations.
// When traffic is being routed to a backing service within a selected virtual destination, if that backing service is detected as being in an unhealthy state, traffic will be re-routed to another healthy backing service by locality as specified in the FailoverPolicy config.
// FailoverPolicy can be used to reroute traffic across clusters when the local instance of a destination service fails. This requires that the backing destinations of the selected virtual destination belong to meshes in the same TrustDomain.
// FailoverPolicies are applied at the *Destination* level.
//
// Note: If an OutlierDetectionPolicy is not configured for the same destinations,
// we will apply our default.
message FailoverPolicySpec {

    // select the virtual destinations where the policy will be applied
    // if left empty, will apply to all destinations in the workspace.
    repeated .common.gloo.solo.io.DestinationSelector apply_to_destinations = 1;

    // The details of the failover policy to apply to the selected virtual destinations.
    //
    // You can exclude this if you wish to enable the locality load balancer
    // settings without mappings.
    Config config = 2;

    message Config {

        // Mappings between localities to provide failover for traffic
        // across regions, zones, and subzones.
        //
        // You can exclude this if you wish to enable the locality load balancer
        // settings without mappings.
        repeated LocalityMappings locality_mappings = 2;

        message LocalityMappings {
            // Originating locality of the client workload.
            OriginatingLocality from = 1;

            // The list of Destination localities that can be routed to if the instance local to the client workload is not available.
            repeated DestinationLocality to = 2;

            // A geographic location defined by a region, zone, and sub-zone.
            message OriginatingLocality {
                // The locality's region.
                string region = 1;

                // (Optional) The locality's zone.
                string zone = 2;

                // (Optional) The locality's sub-zone.
                string sub_zone = 3;
            }

            // A geographic location defined by a region, zone, and sub-zone
            // along with the weight for the destination.
            message DestinationLocality {

                // The locality's region.
                string region = 1;

                // (Optional) The locality's zone.
                string zone = 2;

                // (Optional) The locality's sub-zone.
                string sub_zone = 3;

                // (Optional) Weight for destination locality. All weights must add up to 100.
                // If not provided, we will determine the weight based on other
                // destination locality weights.
                google.protobuf.UInt32Value weight = 4;
            }
        }

    }

}

// reflects the status of the FailoverPolicy
message FailoverPolicyStatus {

  .common.gloo.solo.io.GenericGlobalStatus global = 1;

  // The status of the resource in each workspace that it exists in.
  map<string, .common.gloo.solo.io.WorkspaceStatus> workspaces = 2;

  // Destination ports selected by the policy
  repeated .common.gloo.solo.io.DestinationReference selected_destination_ports = 3;

}
