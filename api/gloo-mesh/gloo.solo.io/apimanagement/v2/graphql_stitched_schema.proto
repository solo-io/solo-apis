syntax = "proto3";

package apimanagement.gloo.solo.io;

import "github.com/solo-io/solo-apis/api/gloo-mesh/external/cue/encoding/protobuf/cue/cue.proto";
import "extproto/ext.proto";
import "github.com/solo-io/solo-apis/api/gloo-mesh/gloo.solo.io/apimanagement/v2/graphql_resolver_map.proto";
import "github.com/solo-io/solo-apis/api/gloo-mesh/gloo.solo.io/common/v2/references.proto";
import "github.com/solo-io/solo-apis/api/gloo-mesh/gloo.solo.io/common/v2/status.proto";
import "github.com/solo-io/solo-apis/api/gloo-mesh/gloo.solo.io/common/v2/selectors.proto";
import "github.com/solo-io/skv2/api/core/v1/core.proto";


option go_package = "github.com/solo-io/solo-apis/pkg/api/apimanagement.gloo.solo.io/v2";

option (extproto.equal_all) = true;
option (extproto.hash_all) = true;
option (extproto.clone_all) = true;

message GraphQLStitchedSchemaSpec {
  // List of GraphQL Subschemas that compose this GraphQL stitched schema.
  repeated Subschema subschemas = 1;

  message Subschema {
    oneof graphql_schema {
      // Reference to a GraphQLSchema resource that contains the configuration for this subschema.
      core.skv2.solo.io.ClusterObjectRef schema = 1;

      // Reference to a GraphQLStitchedSchema resource that contains the configuration for this subschema.
      core.skv2.solo.io.ClusterObjectRef stitched_schema = 2;
    }

    /*
      Type merge configuration for this subschema. Let's say this subschema is a Users service schema
      and provides the User type (with a query to fetch a user given the username)
      ```gql
      type Query {
        GetUser(username: String): User
      }
      type User {
        username: String
        firstName: String
        lastName: String
      }
      ```
      and another subschema, e.g. Reviews schema, may have a partial User type:
      ```gql
      type Review {
        author: User
      }
      type User {
        username: String
      }
      ```
      We want to provide the relevant information from this Users service schema,
      so that another API that can give us a partial User type (with the username) will then
      be able to have access to the full user type. With the correct type merging config under the Users subschema, e.g.:
      ```yaml
      type_merge:
        User:
          selection_set: '{ username }'
          query_name: 'GetUser'
          args:
            username: username
      ```
      the stitched schema will now be able to provide the full user type to all types that require it. In this case,
      we can now get the first name of an author from the Review.author field even though the Reviews schema doesn't
      provide the full User type.
     */
    map<string, TypeMergeConfig> type_merge = 3;

    message TypeMergeConfig {
      // This specifies one or more key fields required from other services to perform this query.
      // Query planning will automatically resolve these fields from other subschemas in dependency order.
      // This is a graphql selection set specified as a string
      // e.g. '{ username }'
      string selection_set = 1;
      // specifies the root field from this subschema used to request the local type
      string query_name = 2;
      //       this provides the schema stitching engine the format to turn the initial object representation
      //       to query arguments
      //       so if the GetUser query was defined as
      //
      //      ```gql
      //      input UserSearch {
      //        username: String
      //      }
      //
      //      type Query {
      //        GetUser(user_search: UserSearch): User
      //      }
      //      ```
      //      we would want to set the user query argument with the correct username from an object.
      //      we can do that by setting the args as:
      //      ```yaml
      //      args:
      //        user_search.username: username
      //      ```
      //      where `user_search.username` is the "setter" path that we are setting the argument input value at and
      //      `username` is the "extraction" path that we are extracting from an object, such as `{"username": "wpatel"}`.

      map<string, string> args = 3;
    }
  }
}

message GraphQLStitchedSchemaStatus {
  .common.gloo.solo.io.GenericGlobalStatus global = 1;

  // The status of the resource in each workspace that it exists in.
  map<string, .common.gloo.solo.io.WorkspaceStatus> workspaces = 2;

  // Name of Workspace that owns the route table
  .common.gloo.solo.io.OwnerWorkspace owner_workspace = 3;
}
