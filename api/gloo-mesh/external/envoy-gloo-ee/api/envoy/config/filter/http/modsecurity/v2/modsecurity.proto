syntax = "proto3";

package envoy.config.filter.http.modsecurity.v2;

option go_package = "github.com/solo-io/solo-apis/pkg/api/envoy-gloo-ee/api/envoy/config/filter/http/modsecurity/v2";

option java_package = "io.envoyproxy.envoy.config.filter.http.modsecurity.v2";
option java_outer_classname = "ModsecurityProto";
option java_multiple_files = true;

import "api/envoy/config/filter/http/transformation_ee/v2/transformation_ee_filter.proto";

// ModSecurity native audit logging is not a good fit for envoy/kubernetes cloud
// native environments. ModSecurity has 3 logging engines. They are not a good
// fit for the following reasons:
// 1. Serial - all logs written to one file, which globally locks on each write.
// This will be horrendous
//    for performance, as all envoy worker threads will be blocked when trying
//    to log, while one of them writes to the file.
// 2. Parallel - each log entry is written to its unique file. This will impact
// performance as this file IO is
//    outside the envoy worker thread event loop, thus blocking it and
//    increasing latency. In addition now we will have many logs files to
//    collect from the pod. this means we'll need to attach another sidecar to
//    collect them which increases complexity.
// 3. Http - perform an http callout to an external logging server - like the
// other methods, this http call
//    is done outside of the envoy event loop, blocking it until it is
//    completed, which will increase latency.
//
// We take a different approach in this envoy integration. We aim to expose the
// audit logs as part of envoy's access logging. This means that directives that
// configure the audit engine itself
// (`SecAuditEngine`, `SecAuditLog`, `SecAuditLogStorageDir`, `SecAuditLogType`,
// ...) are ignored even if they are set. This is intentional - to make sure
// that ModSecurity doesn't degrade envoy performance. You can use the `action`
// property here instead of `SecAuditEngine`. You can still use the
// `SecAuditLogFormat`, `SecAuditLogParts`, `SecAuditLogRelevantStatus`
// (assuming action is RELEVANT_ONLY), `noauditlog` features of the ModSecurity.
// The format of the log is controlled by `SecAuditLogFormat`.
//
// We have two methods of logging the AuditLogging, offering different
// CPU/Memory trade-off. DynamicMetadata - this saves the audit log every time
// it is required. This may increase CPU
//                   as the audit log will be computed even if envoy doesn't
//                   end-up logging it.
// FilterState - this will only generate auditlog if the envoy access log
// requires it. This will use less CPU if the message is not logged, but may use
// more memory, as the ModSecurity transaction will linger in memory longer. We
// recommend testing both in settings similar to your prod environment, to
// understand which approach is better for your usecase.

// Instead of matching properties of the request in the modsecurity language,
// matching will be done using envoy's access log primitives.
message AuditLogging {
  enum AuditLogAction {
    // Never generate audit logs.
    NEVER = 0;
    // When set to RELEVANT_ONLY, this will have similar behavior to
    // `SecAuditEngine RelevantOnly`.
    RELEVANT_ONLY = 1;
    // Always generate an audit log entry (as long as the filter is not
    // disabled).
    ALWAYS = 2;
  }
  AuditLogAction action = 1;

  enum AuditLogLocation {
    // Add the audit log to the filter state.
    // it will be under the key "io.solo.modsecurity.audit_log".
    // You can use this formatter in the access log:
    // %FILTER_STATE(io.solo.modsecurity.audit_log)%
    FILTER_STATE = 0;
    // Add the audit log to the dynamic metadata.
    // it will be under the filter name "io.solo.filters.http.modsecurity". with
    // "audit_log" as the key. You can use this formatter in the access log:
    // %DYNAMIC_METADATA(io.solo.filters.http.modsecurity:audit_log)%
    DYNAMIC_METADATA = 1;
  }
  AuditLogLocation location = 2;
}

message ModSecurity {
  // Disable all rules on the current route
  bool disabled = 1;
  // Global rule sets for the current http connection manager
  repeated RuleSet rule_sets = 2;
  // Custom message to display when an intervention occurs
  string custom_intervention_message = 3;
  // This instructs the filter what to do with the transaction's audit log.
  AuditLogging audit_logging = 5;
  // If set, the body will not be buffered and fed to ModSecurity. Only the
  // headers will. This can help improve perforance.
  bool request_headers_only = 6;
  bool response_headers_only = 7;

  // log in a format suited for the OWASP regression tests.
  // this format is a multiline log format, so it is disabled for regular use.
  // do not enable this in production!
  bool regression_logs = 4;

  envoy.config.filter.http.transformation_ee.v2.DlpTransformation dlp_transformation = 8;
}

message RuleSet {
  // String of rules which are added directly
  string rule_str = 1;
  // Array of files to include
  repeated string files = 3;

  // A directory to include. all *.conf files in this directory will be
  // included. sub directories will NOT be checked.
  string directory = 4;
}

message ModSecurityPerRoute {
  // Disable all rules on the current route
  bool disabled = 1;
  // Overwrite the global rules on this route
  repeated RuleSet rule_sets = 2;
  // Custom message to display when an intervention occurs
  string custom_intervention_message = 3;
  // This instructs the filter what to do with the transaction's audit log.
  AuditLogging audit_logging = 5;
  // If set, the body will not be buffered and fed to ModSecurity. Only the
  // headers will. This can help improve perforance.
  bool request_headers_only = 6;
  bool response_headers_only = 7;

  envoy.config.filter.http.transformation_ee.v2.DlpTransformation dlp_transformation = 8;
}
