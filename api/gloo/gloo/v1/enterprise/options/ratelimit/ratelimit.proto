syntax = "proto3";
package ratelimit.options.gloo.solo.io;
option go_package = "github.com/solo-io/solo-apis/pkg/api/gloo.solo.io/v1/enterprise/options/ratelimit";

import "solo-kit/api/v1/ref.proto";
import "google/protobuf/wrappers.proto";
import "google/protobuf/duration.proto";
import "gogoproto/gogo.proto";
option (gogoproto.equal_all) = true;
import "extproto/ext.proto";
option (extproto.hash_all) = true;

// Descriptors can be nested for your convenience and flexibility
message Descriptor {
    string key = 1;
    string value = 2;
   
    RateLimit rate_limit = 3;
    repeated Descriptor descriptors = 4;

    // Each top-level Descriptor defines a new Rate Limit "rule". When a request comes in, rate limit
    // actions are applied to the request to generate descriptor tuples that are sent to the rate limit
    // server. If any rule is triggered then the entire request returns HTTP 429 Too Many Requests.
    //
    // Typically, rule priority is signalled by nesting descriptors, as the most specific rule match for
    // the descriptor tuple generated by the rate limit actions is used. In rare cases this is too restrictive;
    // instead you can set rule priority by setting weights on your descriptors.
    //
    // All rules with the highest weight are processed, if any of these rules trigger rate limiting then the
    // entire request will return a 429. Rules that are not considered for rate limiting are ignored in the
    // rate limit server, and their request count is not incremented in the rate limit server cache.
    //
    // Defaults to 0; thus all rules are evaluated by default.
    uint32 weight = 5;
    // A boolean override for rule priority via weighted rules. Any rule with `alwaysApply` set to `true` will
    // always be considered for rate limiting, regardless of the rule's weight. The rule with the highest weight
    // will still be considered. (this can be a rule that also has `alwaysApply` set to `true`)
    //
    // Defaults to false.
    bool always_apply = 6;
}

message RateLimit {
    enum Unit {
        UNKNOWN = 0;
        SECOND = 1;
        MINUTE = 2;
        HOUR = 3;
        DAY = 4;
    }
    Unit unit = 1;
    uint32 requests_per_unit = 2;
}

// Basic rate-limiting API
message IngressRateLimit {
    RateLimit authorized_limits = 1;
    RateLimit anonymous_limits = 2;
}

message Settings {
  core.solo.io.ResourceRef ratelimit_server_ref = 1; 
  google.protobuf.Duration request_timeout = 2 [(gogoproto.stdduration) = true];

  bool deny_on_fail = 3;

  // Set this is set to true if you would like to rate limit traffic before applying external auth to it.
  // *Note*: When this is true, you will lose some features like being able to rate limit a request based on its auth state
  bool rate_limit_before_auth = 9;
}

// API based on Envoy's rate-limit service API. (reference here: https://github.com/lyft/ratelimit#configuration)
// Sample configuration below
//
// descriptors:
//- key: account_id
//  descriptors:
//  - key: plan
//    value: BASIC
//    rateLimit:
//      requestsPerUnit: 1
//      unit: MINUTE
//  - key: plan
//    value: PLUS
//    rateLimit:
//      requestsPerUnit: 20
//      unit: MINUTE
message ServiceSettings {
    repeated Descriptor descriptors = 1;
}

message RateLimitActions {
    // Each action in the list maps part of the request (or its context) to a descriptor. The tuple of
    // descriptors generated by the provided actions is sent to the rate limit server and matched against
    // rate limit rules as defined on the Gloo settings resource.
    // Order matters on the provided actions, e.g. the following actions:
    // - actions:
    //  - requestHeaders:
    //      descriptorKey: account_id
    //      headerName: x-account-id
    //  - requestHeaders:
    //      descriptorKey: plan
    //      headerName: x-plan
    // define an ordered descriptor tuple like so: ('account_id', '<x-account-id value>'), ('plan', '<x-plan value>')

    // While the current form matches, the same tuple in reverse order would not match the following descriptor
    // (which is configured on the Gloo Settings resource)

    // descriptors:
    //- key: account_id
    //  descriptors:
    //  - key: plan
    //    value: BASIC
    //    rateLimit:
    //      requestsPerUnit: 1
    //      unit: MINUTE
    //  - key: plan
    //    value: PLUS
    //    rateLimit:
    //      requestsPerUnit: 20
    //      unit: MINUTE
    repeated Action actions = 2 ;// [(validate.rules).repeated .min_items = 1];
}

message RateLimitVhostExtension {
    // Define individual rate limits here. Each rate limit will be evaluated, if any rate limit
    // would be throttled, the entire request returns a 429 (gets throttled)
    repeated RateLimitActions rate_limits = 1 ;// [(validate.rules).repeated .min_items = 1];
}

message RateLimitRouteExtension {
    // Whether or not to include rate limits as defined on the VirtualHost in addition to rate limits on the Route
    bool include_vh_rate_limits = 1;
    // Define individual rate limits here. Each rate limit will be evaluated, if any rate limit
    // would be throttled, the entire request returns a 429 (gets throttled)
    repeated RateLimitActions rate_limits = 2 ;// [(validate.rules).repeated .min_items = 1];
}


// TODO(yuval-k): copied from envoy; will be removed and imported properly in a future when we vendor protos
message Action {
    // The following descriptor entry is appended to the descriptor:
    //
    // ```
    //   ("source_cluster", "<local service cluster>")
    // ```
    //
    // <local service cluster> is derived from the :option:`--service-cluster` option.
    message SourceCluster {
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // ```
    //   ("destination_cluster", "<routed target cluster>")
    // ```
    //
    // Once a request matches against a route table rule, a routed cluster is determined by one of
    // the following `route table configuration (envoy_api_msg_RouteConfiguration)`
    // settings:
    //
    // * `cluster (envoy_api_field_route.RouteAction.cluster)` indicates the upstream cluster
    //   to route to.
    // * `weighted_clusters (envoy_api_field_route.RouteAction.weighted_clusters)`
    //   chooses a cluster randomly from a set of clusters with attributed weight.
    // * `cluster_header (envoy_api_field_route.RouteAction.cluster_header)` indicates which
    //   header in the request contains the target cluster.
    message DestinationCluster {
    }

    // The following descriptor entry is appended when a header contains a key that matches the
    // *header_name*:
    //
    // ```
    //   ("<descriptor_key>", "<header_value_queried_from_header>")
    // ```
    message RequestHeaders {
      // The header name to be queried from the request headers. The header’s
      // value is used to populate the value of the descriptor entry for the
      // descriptor_key.
      string header_name = 1 ;// [(validate.rules).string.min_bytes = 1];

      // The key to use in the descriptor entry.
      string descriptor_key = 2 ;// [(validate.rules).string.min_bytes = 1];
    }

    // The following descriptor entry is appended to the descriptor and is populated using the
    // trusted address from `x-forwarded-for (config_http_conn_man_headers_x-forwarded-for)`:
    //
    // ```
    //   ("remote_address", "<trusted address from x-forwarded-for>")
    // ```
    message RemoteAddress {
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // ```
    //   ("generic_key", "<descriptor_value>")
    // ```
    message GenericKey {
      // The value to use in the descriptor entry.
      string descriptor_value = 1 ;// [(validate.rules).string.min_bytes = 1];
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // ```
    //   ("header_match", "<descriptor_value>")
    // ```
    message HeaderValueMatch {
      // The value to use in the descriptor entry.
      string descriptor_value = 1 ;// [(validate.rules).string.min_bytes = 1];

      // If set to true, the action will append a descriptor entry when the
      // request matches the headers. If set to false, the action will append a
      // descriptor entry when the request does not match the headers. The
      // default value is true.
      google.protobuf.BoolValue expect_match = 2;

      // Specifies a set of headers that the rate limit action should match
      // on. The action will check the request’s headers against all the
      // specified headers in the config. A match will happen if all the
      // headers in the config are present in the request with the same values
      // (or based on presence if the value field is not in the config).
      repeated HeaderMatcher headers = 3 ;// [(validate.rules).repeated .min_items = 1];
    }

    oneof action_specifier {
      // option (validate.required) = true;

      // Rate limit on source cluster.
      SourceCluster source_cluster = 1;

      // Rate limit on destination cluster.
      DestinationCluster destination_cluster = 2;

      // Rate limit on request headers.
      RequestHeaders request_headers = 3;

      // Rate limit on remote address.
      RemoteAddress remote_address = 4;

      // Rate limit on a generic key.
      GenericKey generic_key = 5;

      // Rate limit on the existence of request headers.
      HeaderValueMatch header_value_match = 6;
    }
  }

// Specifies the int64 start and end of the range using half-open interval semantics [start,
// end).
message Int64Range {
    // start of the range (inclusive)
    int64 start = 1;
  
    // end of the range (exclusive)
    int64 end = 2;
  }
  
  message HeaderMatcher {
    // Specifies the name of the header in the request.
    string name = 1 ;// [(validate.rules).string.min_bytes = 1];
  
    reserved 2; // value deprecated by `exact_match
                // (envoy_api_field_route.HeaderMatcher.exact_match)`
  
    reserved 3; // regex deprecated by `regex_match
                // (envoy_api_field_route.HeaderMatcher.regex_match)`
  
    // Specifies how the header match will be performed to route the request.
    oneof header_match_specifier {
      // If specified, header match will be performed based on the value of the header.
      string exact_match = 4;
  
      // If specified, this regex string is a regular expression rule which implies the entire request
      // header value must match the regex. The rule will not match if only a subsequence of the
      // request header value matches the regex. The regex grammar used in the value field is defined
      // `(here)[https://en.cppreference.com/w/cpp/regex/ecmascript]`.
      //
      // Examples:
      //
      // * The regex *\d{3}* matches the value *123*
      // * The regex *\d{3}* does not match the value *1234*
      // * The regex *\d{3}* does not match the value *123.456*
      string regex_match = 5 ;// [(validate.rules).string.max_bytes = 1024];
  
      // If specified, header match will be performed based on range.
      // The rule will match if the request header value is within this range.
      // The entire request header value must represent an integer in base 10 notation: consisting of
      // an optional plus or minus sign followed by a sequence of digits. The rule will not match if
      // the header value does not represent an integer. Match will fail for empty values, floating
      // point numbers or if only a subsequence of the header value is an integer.
      //
      // Examples:
      //
      // * For range [-10,0), route will match for header value -1, but not for 0, "somestring", 10.9,
      //   "-1somestring"
      Int64Range range_match = 6;
  
      // If specified, header match will be performed based on whether the header is in the
      // request.
      bool present_match = 7;
  
      // If specified, header match will be performed based on the prefix of the header value.
      // Note: empty prefix is not allowed, please use present_match instead.
      //
      // Examples:
      //
      // * The prefix *abcd* matches the value *abcdxyz*, but not for *abcxyz*.
      string prefix_match = 9 ;// [(validate.rules).string.min_bytes = 1];
  
      // If specified, header match will be performed based on the suffix of the header value.
      // Note: empty suffix is not allowed, please use present_match instead.
      //
      // Examples:
      //
      // * The suffix *abcd* matches the value *xyzabcd*, but not for *xyzbcd*.
      string suffix_match = 10 ;// [(validate.rules).string.min_bytes = 1];
    }

    // If specified, the match result will be inverted before checking. Defaults to false.
    //
    // Examples:
    //
    // * The regex *\d{3}* does not match the value *1234*, so it will match when inverted.
    // * The range [-10,0) will match the value -1, so it will not match when inverted.
    bool invert_match = 8;
  }
  
  // Query parameter matching treats the query string of a request's :path header
  // as an ampersand-separated list of keys and/or key=value elements.
  message QueryParameterMatcher {
    // Specifies the name of a key that must be present in the requested
    // *path*'s query string.
    string name = 1 ;// [(validate.rules).string = {min_bytes: 1, max_bytes: 1024}];
  
    // Specifies the value of the key. If the value is absent, a request
    // that contains the key in its query string will match, whether the
    // key appears with a value (e.g., "?debug=true") or not (e.g., "?debug")
    string value = 3;
  
    // Specifies whether the query parameter value is a regular expression.
    // Defaults to false. The entire query parameter value (i.e., the part to
    // the right of the equals sign in "key=value") must match the regex.
    // E.g., the regex "\d+$" will match "123" but not "a123" or "123a".
    google.protobuf.BoolValue regex = 4;
  }
  
