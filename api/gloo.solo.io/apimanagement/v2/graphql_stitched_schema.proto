syntax = "proto3";

package apimanagement.gloo.solo.io;

import "extproto/ext.proto";
import "github.com/solo-io/solo-apis/api/gloo.solo.io/apimanagement/v2/graphql_resolver_map.proto";
import "github.com/solo-io/solo-apis/api/gloo.solo.io/common/v2/status.proto";
import "github.com/solo-io/skv2/api/core/v1/core.proto";

option go_package = "github.com/solo-io/solo-apis/client-go/apimanagement.gloo.solo.io/v2";

option (extproto.equal_all) = true;
option (extproto.hash_all) = true;
option (extproto.clone_all) = true;

message GraphQLStitchedSchemaSpec {
  // List of GraphQL Subschemas that compose this GraphQL stitched schema.
  repeated Subschema subschemas = 1;

  Options options = 2;

  message Subschema {
    oneof graphql_schema {
      // Reference to a GraphQLSchema resource that contains the configuration for this subschema.
      core.skv2.solo.io.ClusterObjectRef schema = 1;

      // Reference to a GraphQLStitchedSchema resource that contains the configuration for this subschema.
      core.skv2.solo.io.ClusterObjectRef stitched_schema = 2;
    }

    // Type merge configuration for this subschema.
    map<string, TypeMergeConfig> type_merge = 3;

    // Type merge configuration for this subschema. Let's say this subschema is a Users service schema
    // and provides the User type (with a query to fetch a user given the username)
    // ```gql
    // type Query {
    //   GetUser(username: String): User
    // }
    // type User {
    //   username: String
    //   firstName: String
    //   lastName: String
    // }
    // ```
    // and another subschema, e.g. Reviews schema, may have a partial User type:
    // ```gql
    // type Review {
    //   author: User
    // }
    // type User {
    //   username: String
    // }
    // ```
    // We want to provide the relevant information from this Users service schema,
    // so that another API that can give us a partial User type (with the username) will then
    // be able to have access to the full user type. With the correct type merging config under the Users subschema, e.g.:
    // ```yaml
    //
    // type_merge:
    //   User:
    //     selection_set: '{ username }'
    //     query_name: 'GetUser'
    //     args:
    //       username: username
    // ```
    // the stitched schema will now be able to provide the full user type to all types that require it. In this case,
    // we can now get the first name of an author from the Review.author field even though the Reviews schema doesn't
    // provide the full User type. Note: Type merging can be used for all GraphQL types except Mutations and Subscriptions.
    //
    // Note that the `args` option specifies the format to turn the initial object representation
    // into query arguments. For example, consider the following GetUser query:
    // ```gql
    // input UserSearch {
    //   username: String
    // }
    //
    // type Query {
    //   GetUser(user_search: UserSearch): User
    // }
    // ```
    // To set the user query argument with the correct username from an object,
    // you use the `args` option, such as the following:
    // ```yaml
    //
    // args:
    //   user_search.username: username
    // ```
    // where `user_search.username` is the "setter" path to set the argument input value at, and
    // `username` is the "extraction" path to extract from an object, such as `{"username": "wpatel"}`.
    message TypeMergeConfig {
      // This specifies one or more key fields required from other services to perform this query.
      // Query planning will automatically resolve these fields from other subschemas in dependency order.
      // This is a graphql selection set specified as a string
      // e.g. '{ username }'
      string selection_set = 1;
      // specifies the root field from this subschema used to request the local type
      string query_name = 2;
      // The format to turn the initial object representation into query arguments.
      map<string, string> args = 3;
    }
  }

  message Options {
    // Enable introspection queries on this GraphQL Stitched API.
    // Introspection queries are used by GraphQL developers to understand the schema of the GraphQL API and create
    // queries that are valid against the schema. Introspection is disabled by default, and should be disabled for
    // production environments.
    bool enable_introspection = 1;
  }
}

message GraphQLStitchedSchemaStatus {
  // The state and workspace conditions of the applied resource.
  .common.gloo.solo.io.Status common = 1;

  // The name of the workspace that owns the GraphQL stitched schema.
  string owned_by_workspace = 4;
}

message GraphQLStitchedSchemaReport {
  map<string, .common.gloo.solo.io.Report> workspaces = 1;

  // The name of the workspace that owns the GraphQL stitched schema.
  string owner_workspace = 2;
}
