syntax = "proto3";

package internal.gloo.solo.io;

import "extproto/ext.proto";

option go_package = "github.com/solo-io/solo-apis/client-go/internal.gloo.solo.io/v2";

option (extproto.equal_all) = true;
option (extproto.clone_all) = true;
option (extproto.hash_all) = true;

/*
    CertificateRequests are generated by the Gloo Mesh agent installed on workload clusters.
    They are used to request a signed certificate from the certificate issuer (the Gloo Mesh server) based on a private key
    generated by the agent (which never leaves the workload cluster).

    When Gloo Mesh server creates an IssuedCertificate on a workload cluster, the local Gloo Mesh agent
    will generate a CertificateRequest corresponding to it.

    Gloo Mesh will then process the certificate signing request contained in the
    `CertificateRequestSpec` and write the signed SSL certificate back as a Kubernetes secret in the workload cluster,
    and update the `CertificateRequestStatus` to point to that secret.

    The certificate requested here is for Gloo Mesh agents on workload clusters to securely establish communication 
    with Gloo Mesh server. This is not related to certificates for services running in the mesh.
*/
message CertificateRequestSpec {
  // Base64-encoded data for the PKCS#10 Certificate Signing Request issued
  // by the Gloo Mesh agent deployed in the workload cluster, corresponding
  // to the IssuedRequest received by the Gloo Mesh agent.
  bytes certificate_signing_request = 1;
}

message CertificateRequestStatus {

  // The most recent generation observed in the CertificateRequest metadata.
  // If the `observedGeneration` does not match `metadata.generation`, the issuer has not processed the most
  // recent version of this request.
  int64 observed_generation = 1;

  // Any error observed which prevented the CertificateRequest from being processed.
  // If the error is empty, the request has been processed successfully
  string error = 2;

  // The current state of the CertificateRequest workflow reported by the issuer.
  State state = 3;

  // Possible states in which a CertificateRequest can exist.
  enum State {
    // The CertificateRequest has yet to be picked up by the issuer.
    PENDING = 0;

    // The issuer has replied to the request and the `signedCertificate` and `signingRootCa`
    // status fields will be populated.
    FINISHED = 1;

    // Processing the certificate workflow failed.
    FAILED = 2;
  }

  // The signed intermediate certificate issued by the CA.
  bytes signed_certificate = 4;

  // The root CA used by the issuer to sign the certificate.
  bytes signing_root_ca = 5;

  // The cert chain of signing CA.
  bytes cert_chain = 6;
}
