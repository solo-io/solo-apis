syntax = "proto3";

package trafficcontrol.policy.gloo.solo.io;

import "extproto/ext.proto";
import "github.com/solo-io/solo-apis/api/gloo.solo.io/common/v2/status_new.proto";
import "google/protobuf/wrappers.proto";
import "github.com/solo-io/solo-apis/api/gloo.solo.io/common/v2/selectors.proto";
import "github.com/solo-io/solo-apis/api/gloo.solo.io/common/v2/status.proto";

option go_package = "github.com/solo-io/solo-apis/client-go/trafficcontrol.policy.gloo.solo.io/v2";

option (extproto.equal_all) = true;
option (extproto.hash_all) = true;
option (extproto.clone_all) = true;

// HTTPBufferPolicy is used to enable http buffers for routes
//
// For more details on HTTPBuffer, visit:
// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/buffer_filter
//
// ```
// apiVersion: trafficcontrol.policy.gloo.solo.io/v2
// kind: HTTPBufferPolicy
// metadata:
//   name: buffer
//   namespace: bookinfo
// spec:
//   config:
//     maxRequestBytes: 16384
//   applyToRoutes:
//   - route:
//       labels:
//         route: productpage
// ```
message HTTPBufferPolicySpec {
  repeated .common.gloo.solo.io.RouteSelector apply_to_routes = 1;

  message Config {
    // The maximum request size that the filter will buffer before
    // the connection manager will stop buffering and return a 413
    // response
    google.protobuf.UInt32Value max_request_bytes = 1;
  }

  Config config = 2;
}

// reflects the status of the HTTPBufferPolicy
message HTTPBufferPolicyStatus {
  .common.gloo.solo.io.Status common = 1;

  // The number of routes selected by the policy.
  uint32 num_selected_routes = 2;
}

message HTTPBufferPolicyReport {
  map<string, .common.gloo.solo.io.Report> workspaces = 1;

  // A list of references to all routes selected by the policy.
  repeated .common.gloo.solo.io.RouteReference selected_routes = 2;
}
