syntax = "proto3";

package trafficcontrol.policy.gloo.solo.io;

import "extproto/ext.proto";
import "github.com/solo-io/solo-apis/api/gloo.solo.io/common/v2/references.proto";
import "github.com/solo-io/solo-apis/api/gloo.solo.io/common/v2/selectors.proto";
import "github.com/solo-io/solo-apis/api/gloo.solo.io/common/v2/status.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

option go_package = "github.com/solo-io/solo-apis/client-go/trafficcontrol.policy.gloo.solo.io/v2";

option (extproto.equal_all) = true;
option (extproto.hash_all) = true;
option (extproto.clone_all) = true;

// LoadBalancerPolicy provides settings to configure traffic distribution among destination workloads.
message LoadBalancerPolicySpec {

  // The destinations to which the policy should apply.
  // If no selectors are specified, the policy will apply to all destinations in the workspace
  // Only one LoadBalancer policy can apply to a given destination. In case of multiple policies, only the oldest policy will apply
  // and the rest will be given an error status.
  repeated .common.gloo.solo.io.DestinationSelector apply_to_destinations = 1;

  // The configuration for the load balancer.
  //
  // +kubebuilder:validation:Required
  // +kubebuilder:validation:XValidation:rule="has(self.simple) || has(self.consistentHash)",message="config must have one of simple or consistentHash set."
  Config config = 2;

  message Config {

    // Upstream load balancing policy.
    oneof lb_policy {
      // +kubebuilder:validation:Enum=UNSPECIFIED;RANDOM;PASSTHROUGH;ROUND_ROBIN;LEAST_REQUEST
      SimpleLB simple = 1;
      ConsistentHashLB consistent_hash = 2;
    }

    // Represents the warmup duration of Service. If set, the newly created endpoint of service
    // remains in warmup mode starting from its creation time for the duration of this window and
    // Istio progressively increases amount of traffic for that endpoint instead of sending proportional amount of traffic.
    // This should be enabled for services that require warm up time to serve full production load with reasonable latency.
    // Please note that this is most effective when few new endpoints come up like scale event in Kubernetes. When all the 
    // endpoints are relatively new like new deployment, this is not very effective as all endpoints end up getting same 
    // amount of requests.
    // Currently this is only supported for ROUND_ROBIN and LEAST_REQUEST load balancers.
    //
    // +kubebuilder:validation:XValidation:rule="duration(self) >= duration('1ms')",message="The value must be at least 1ms."
    // +kubebuilder:validation:XValidation:rule="!self.contains('ns') && !self.contains('us')",message="The value cannot have granularity smaller than milliseconds."
    // +kubebuilder:validation:XValidation:rule="(duration(self)-duration('1ns')).getMilliseconds() == duration(self).getMilliseconds()-1",message="The value cannot have granularity smaller than milliseconds."
    google.protobuf.Duration warmup_duration_secs = 3;

    // A threshold at which Envoy will disregard health status and balance either among all hosts or no hosts.
    // If not specified, the default is 50%. To disable panic mode, set to 0%.
    //
    // +kubebuilder:validation:Minimum=0
    // +kubebuilder:validation:Maximum=100
    // +kubebuilder:validation:XValidation:rule="self == 0.0 || self >= 0.0001",message="Must be >= 0.0001 or equal to zero"
    google.protobuf.DoubleValue healthy_panic_threshold = 4;

    // Health check/weight/metadata updates that happen within this duration will be merged and delivered
    // in one shot when the duration expires.
    // If not specified, the default is 1000ms. To disable it, set the merge window to 0.
    //
    // +kubebuilder:validation:XValidation:rule="duration(self) >= duration('1ms')",message="The value must be at least 1ms."
    // +kubebuilder:validation:XValidation:rule="!self.contains('ns') && !self.contains('us')",message="The value cannot have granularity smaller than milliseconds."
    // +kubebuilder:validation:XValidation:rule="(duration(self)-duration('1ns')).getMilliseconds() == duration(self).getMilliseconds()-1",message="The value cannot have granularity smaller than milliseconds."
    google.protobuf.Duration update_merge_window = 5;

    // Standard load balancing algorithms that require no tuning.
    enum SimpleLB {
      // No load balancing algorithm has been specified by the user. Istio
      // will select an appropriate default.
      UNSPECIFIED = 0;

      // The random load balancer selects a random healthy host. The random
      // load balancer generally performs better than round robin if no health
      // checking policy is configured.
      RANDOM = 1;

      // This option will forward the connection to the original IP address
      // requested by the caller without doing any form of load
      // balancing. This option must be used with care. It is meant for
      // advanced use cases. Refer to Original Destination load balancer in
      // Envoy for further details.
      PASSTHROUGH = 2;

      // A basic round robin load balancing policy. This is generally unsafe
      // for many scenarios (e.g. when endpoint weighting is used) as it can
      // overburden endpoints. In general, we recommend using LEAST_REQUEST as a
      // drop-in replacement for ROUND_ROBIN.
      ROUND_ROBIN = 3;

      // The least request load balancer spreads load across endpoints, favoring
      // endpoints with the least outstanding requests. This is generally safer
      // and outperforms ROUND_ROBIN in nearly all cases. Prefer to use
      // LEAST_REQUEST as a drop-in replacement for ROUND_ROBIN.
      LEAST_REQUEST = 4;
    }

    // Consistent Hash-based load balancing can be used to provide soft
    // session affinity based on HTTP headers, cookies or other
    // properties. The affinity to a particular destination host may be
    // lost when one or more hosts are added/removed from the destination
    // service.
    //
    // Note: consistent hashing is less reliable at maintaining affinity than common
    // "sticky sessions" implementations, which often encode a specific destination in
    // a cookie, ensuring affinity is maintained as long as the backend remains.
    // With consistent hash, the guarantees are weaker; any host addition or removal can
    // break affinity for `1/backends` requests.
    //
    // Warning: consistent hashing depends on each proxy having a consistent view of endpoints.
    // This is not the case when locality load balancing is enabled. Locality load balancing
    // and consistent hash will only work together when all proxies are in the same locality,
    // or a high level load balancer handles locality affinity.
    //
    // +kubebuilder:validation:XValidation:rule="has(self.httpHeaderName) || has(self.httpCookie) || has(self.useSourceIp) || has(self.httpQueryParameterName)",message="One of httpHeaderName, httpCookie, useSourceIp, httpQueryParameterName must be set."
    message ConsistentHashLB {
      // The hash key to use.
      oneof hash_key {
        // Hash based on a specific HTTP header.
        //
        // +kubebuilder:validation:MinLength=1
        string http_header_name = 1;

        // Hash based on HTTP cookie.
        HTTPCookie http_cookie = 2;

        // Hash based on the source IP address.
        // This is applicable for both TCP and HTTP connections.
        bool use_source_ip = 3;

        // Hash based on a specific HTTP query parameter.
        //
        // +kubebuilder:validation:MinLength=1
        string http_query_parameter_name = 4;
      }

      // Describes a HTTP cookie that will be used as the hash key for the
      // Consistent Hash load balancer. If the cookie is not present, it will
      // be generated.
      message HTTPCookie {
        // Name of the cookie.
        //
        // +kubebuilder:validation:Required
        // +kubebuilder:validation:MinLength=1
        string name = 1;

        // Path to set for the cookie.
        string path = 2;

        // Lifetime of the cookie.
        //
        // +kubebuilder:validation:XValidation:rule="duration(self) >= duration('1ms')",message="The value must be at least 1ms."
        // +kubebuilder:validation:XValidation:rule="!self.contains('ns') && !self.contains('us')",message="The value cannot have granularity smaller than milliseconds."
        // +kubebuilder:validation:XValidation:rule="(duration(self)-duration('1ns')).getMilliseconds() == duration(self).getMilliseconds()-1",message="The value cannot have granularity smaller than milliseconds."
        google.protobuf.Duration ttl = 3;
      }
    };
  }
}

// The status of the policy after it is applied to your Gloo environment.Status
message LoadBalancerPolicyStatus {
  // The state and workspace conditions of the applied resource.
  .common.gloo.solo.io.Status common = 1;

  // The number of destination ports selected by the policy.
  uint32 num_selected_destination_ports = 2;
}

// Report on the state of the LoadBalancerPolicyReport
message LoadBalancerPolicyReport {
  // A list of workspaces in which the policy can apply to workloads.
  map<string, .common.gloo.solo.io.Report> workspaces = 1;

  // Destination ports selected by the policy
  repeated .common.gloo.solo.io.DestinationReference selected_destination_ports = 2;
}
